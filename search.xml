<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>---- &lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-skull&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-robot&quot;&gt;&lt;/i&gt;  ----</title>
    <url>/BassHero.github.io/2024/04/13/top/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><div style="text-align: center;color:#808080;">
      <i class="fas fa-crow"></i>
  <span id="sitetime"></span>

<script language=javascript>
    function siteTime(){
        //window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth()+1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* 
        Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数
        */
        var t1 = Date.UTC(2021,09,1,00,00,00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
        var diff = t2-t1;
        var diffYears = Math.floor(diff/years);
        var diffDays = Math.floor((diff/days)-diffYears*365);
        var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
        var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
        var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);

        //document.getElementById("sitetime").innerHTML=" 已运行"+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
        document.getElementById("sitetime").innerHTML=" 已运行"+diffYears+" 年 "+diffDays+" 天 ";
    }
    siteTime();
</script>
</div>

<br>

<div style="text-align: center;"><font size="4";color="#808080";>已看：1429/2500 | 已读： 198/300</font></div>
<br>
<div  style="text-align: center;">
   电影进度
  <div class="progress-bar" >
                    <div class="progress-film">
                    </div>
                </div>
                <br>
    阅读进度
  <div class="progress-bar">
                    <div class="progress-book">
                    </div>
</div>
<br>


</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
  </entry>
  <entry>
    <title>組込みエンジニアの教科書_CHAPTER07(Linux)</title>
    <url>/BassHero.github.io/2025/04/19/ISBN978-4-863-54275-4-07/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<p><strong>MMU(Memory Management unit)</strong>:メモリ管理ユニット<br>仮想アドレス空間から物理アドレス空間の変換を行う機能がある、物理メモリをページと呼ばれる最小単位で管理できる。ソフトウェアの<strong>プロセスごと</strong>にページ単位でメモリ割り当てする。<br>ページテーブルに参照する際に仮想空間に対応する物理空間が見つからないと「ページフォルト」が発生します。<br>ページアウトが発生すると不要とされるページを二次記憶に書き出して（ページアウト）、新たに必要なページを二次記憶装置から物理空間に読み込んで(ページイン)、ページを置換する。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>組込み系</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>組込みエンジニアの教科書_CHAPTER06(デバイスの選択)</title>
    <url>/BassHero.github.io/2025/04/15/ISBN978-4-863-54275-4-06/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>

<p><strong>Soc(System on Chip)</strong><br>システム<strong>LSI</strong>（Large Scale Integration）とは、異なる機能を持つ、複数の集積回路を1つのLSI上にまとめたもののことを指します<br><a href="/WestRoute.github.io/images/SoCBCM2837.png" class="gallery-item"><img src="/WestRoute.github.io/images/SoCBCM2837.png"></a></p>
<p><strong>リファレンスボード</strong><br>ICチップなどの製品を試用して評価を行うために作成・提供される、動作に必要な周辺チップや回路、端子などを搭載した半導体基板のこと。<br><strong>BSP(Borad Support Package)</strong><br><strong>HAL(Hardware Abstraction Layer)</strong> ハードウェア抽象化レイヤー</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>組込み系</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>組込みエンジニアの教科書_CHAPTER05(FreeRTOSと他のOS)</title>
    <url>/BassHero.github.io/2025/04/15/ISBN978-4-863-54275-4-05-03/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h2 id="FreeRTOSの構成"><a href="#FreeRTOSの構成" class="headerlink" title="FreeRTOSの構成"></a>FreeRTOSの構成</h2><p><strong>TCB(Task Control Block)</strong><br>タスクの情報を保持するものです。タスクの情報には, そのタスクの優先度, 状態, 前のプログラムコード位置(タスクが切り換えられ復帰するための現在実行中のプログラムコードの位置)などを含みます</p>
<p><strong>セマフォ</strong><br>複数のプロセスが同期して処理を進めることができます。</p>
<figure class="highlight c"><figcaption><span>seminit.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> semid;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">arg</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;sem.dat&quot;</span>, <span class="string">&#x27;S&#x27;</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* create a semaphore set with 1 semaphore: */</span></span><br><span class="line">    <span class="keyword">if</span> ((semid = semget(key, <span class="number">1</span>, <span class="number">0666</span> | IPC_CREAT)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;semget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* initialize semaphore #0 to 1: */</span></span><br><span class="line">    arg.val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (semctl(semid, <span class="number">0</span>, SETVAL, arg) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;semctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="FreeRTOSのサンプルコード"><a href="#FreeRTOSのサンプルコード" class="headerlink" title="FreeRTOSのサンプルコード"></a>FreeRTOSのサンプルコード</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Arduino_FreeRTOS.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// define two tasks for Blink &amp; AnalogRead</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskBlink</span><span class="params">( <span class="keyword">void</span> *pvParameters )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskAnalogRead</span><span class="params">( <span class="keyword">void</span> *pvParameters )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the setup function runs once when you press reset or power the board</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// initialize serial communication at 9600 bits per second:</span></span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (!Serial) &#123;</span><br><span class="line">    ; <span class="comment">// wait for serial port to connect. Needed for native USB, on LEONARDO, MICRO, YUN, and other 32u4 based boards.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now set up two tasks to run independently.</span></span><br><span class="line">  xTaskCreate(</span><br><span class="line">    TaskBlink</span><br><span class="line">    ,  (<span class="keyword">const</span> portCHAR *)<span class="string">&quot;Blink&quot;</span>   <span class="comment">// A name just for humans</span></span><br><span class="line">    ,  <span class="number">128</span>  <span class="comment">// This stack size can be checked &amp; adjusted by reading the Stack Highwater</span></span><br><span class="line">    ,  <span class="literal">NULL</span></span><br><span class="line">    ,  <span class="number">2</span>  <span class="comment">// Priority, with 3 (configMAX_PRIORITIES - 1) being the highest, and 0 being the lowest.</span></span><br><span class="line">    ,  <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">  xTaskCreate(</span><br><span class="line">    TaskAnalogRead</span><br><span class="line">    ,  (<span class="keyword">const</span> portCHAR *) <span class="string">&quot;AnalogRead&quot;</span></span><br><span class="line">    ,  <span class="number">128</span>  <span class="comment">// Stack size</span></span><br><span class="line">    ,  <span class="literal">NULL</span></span><br><span class="line">    ,  <span class="number">1</span>  <span class="comment">// Priority</span></span><br><span class="line">    ,  <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Empty. Things are done in Tasks.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/*---------------------- Tasks ---------------------*/</span></span><br><span class="line"><span class="comment">/*--------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskBlink</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span>  <span class="comment">// This is a task.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  (<span class="keyword">void</span>) pvParameters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Blink</span></span><br><span class="line"><span class="comment">  Turns on an LED on for one second, then off for one second, repeatedly.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Most Arduinos have an on-board LED you can control. On the UNO, LEONARDO, MEGA, and ZERO </span></span><br><span class="line"><span class="comment">  it is attached to digital pin 13, on MKR1000 on pin 6. LED_BUILTIN takes care </span></span><br><span class="line"><span class="comment">  of use the correct LED pin whatever is the board used.</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  The MICRO does not have a LED_BUILTIN available. For the MICRO board please substitute</span></span><br><span class="line"><span class="comment">  the LED_BUILTIN definition with either LED_BUILTIN_RX or LED_BUILTIN_TX.</span></span><br><span class="line"><span class="comment">  e.g. pinMode(LED_BUILTIN_RX, OUTPUT); etc.</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  If you want to know what pin the on-board LED is connected to on your Arduino model, check</span></span><br><span class="line"><span class="comment">  the Technical Specs of your board  at https://www.arduino.cc/en/Main/Products</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  This example code is in the public domain.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  modified 8 May 2014</span></span><br><span class="line"><span class="comment">  by Scott Fitzgerald</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  modified 2 Sep 2016</span></span><br><span class="line"><span class="comment">  by Arturo Guadalupi</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize digital LED_BUILTIN on pin 13 as an output.</span></span><br><span class="line">  pinMode(LED_BUILTIN, OUTPUT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) <span class="comment">// A Task shall never return or exit.</span></span><br><span class="line">  &#123;</span><br><span class="line">    digitalWrite(LED_BUILTIN, HIGH);   <span class="comment">// turn the LED on (HIGH is the voltage level)</span></span><br><span class="line">    vTaskDelay( <span class="number">1000</span> / portTICK_PERIOD_MS ); <span class="comment">// wait for one second</span></span><br><span class="line">    digitalWrite(LED_BUILTIN, LOW);    <span class="comment">// turn the LED off by making the voltage LOW</span></span><br><span class="line">    vTaskDelay( <span class="number">1000</span> / portTICK_PERIOD_MS ); <span class="comment">// wait for one second</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskAnalogRead</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span>  <span class="comment">// This is a task.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  (<span class="keyword">void</span>) pvParameters;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  AnalogReadSerial</span></span><br><span class="line"><span class="comment">  Reads an analog input on pin 0, prints the result to the serial monitor.</span></span><br><span class="line"><span class="comment">  Graphical representation is available using serial plotter (Tools &gt; Serial Plotter menu)</span></span><br><span class="line"><span class="comment">  Attach the center pin of a potentiometer to pin A0, and the outside pins to +5V and ground.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  This example code is in the public domain.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// read the input on analog pin 0:</span></span><br><span class="line">    <span class="keyword">int</span> sensorValue = analogRead(A0);</span><br><span class="line">    <span class="comment">// print out the value you read:</span></span><br><span class="line">    Serial.println(sensorValue);</span><br><span class="line">    vTaskDelay(<span class="number">1</span>);  <span class="comment">// one tick delay (15ms) in between reads for stability</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><p>オペレーティングシステム (OS) の標準的なインタフェースおよび環境を定義するIEEE規格。<br>POSIX準拠OSは、、ハードウェアを全てOSの管理下にあり、ハードウェアはドライバーで制御し、ユーザーはハードウェアを直接制御できない。<br>組込み機器に求めるリアルタイム性が高い場合は、求められる<strong>速度が満たさない</strong>。</p>
<h2 id="TRON-project"><a href="#TRON-project" class="headerlink" title="TRON project"></a>TRON project</h2><p>最小限度のシステムコールとスケジューラを仕様として公開している。</p>
<h2 id="T-Kernal仕様"><a href="#T-Kernal仕様" class="headerlink" title="T-Kernal仕様"></a>T-Kernal仕様</h2><p>T-KernelにおいてμITRONから拡張された機能</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>組込み系</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>プロセス間通信と共有メモリ</title>
    <url>/BassHero.github.io/2025/04/15/pipe2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<p>UNIX系のOSでは（一部特定の機能を除いて）それぞれのプロセスのメモリアドレス空間は独立している。このため、プロセス間でデータをやりとりしようとした場合には（独立したソフトウェア同士がデータのやりとりをしようとした場合には）、ファイルシステムを経由したり、パイプを使ったり、ソケットを使ってネットワーク通信などを実施する必要がある。</p>
<p>　インタラクティブシェルで、例えば「cat ファイル | grep キーワード」のような処理を実行したことがあると思うが、これはcat(1)とgrep(1)という異なるプロセス（ソフトウェア）に関して、シェルがpipe(2)を使ってパイプを生成し、cat(1)の標準出力をgrep(1)の標準入力に設定して一方通行でデータ通信できるようにしたものだ。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fdi, fdo, fsize = <span class="number">104857600</span>;</span><br><span class="line">    <span class="keyword">char</span> *i, *o;</span><br><span class="line">    fdi = open(<span class="string">&quot;in&quot;</span>, O_RDONLY);</span><br><span class="line">    fdo = open(<span class="string">&quot;out&quot;</span>, O_RDWR);</span><br><span class="line">    i = mmap(<span class="literal">NULL</span>, fsize, PROT_READ, MAP_SHARED, fdi, <span class="number">0</span>);</span><br><span class="line">    o = mmap(<span class="literal">NULL</span>, fsize, PROT_WRITE, MAP_SHARED, fdo, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (fsize--) &#123;</span><br><span class="line">        *o++ = *i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><figcaption><span>プロセス間通信：パイプを使う場合</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd[<span class="number">2</span>], i, rp=<span class="number">1000000</span>;</span><br><span class="line">        pipe(fd);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == fork()) &#123;</span><br><span class="line">                <span class="keyword">char</span> b[<span class="number">2</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rp; i++)</span><br><span class="line">                        read(fd[<span class="number">0</span>], b, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rp; i++)</span><br><span class="line">                        write(fd[<span class="number">1</span>], <span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>組込み系</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>組込みエンジニアの教科書_CHAPTER05(システムコール)</title>
    <url>/BassHero.github.io/2025/04/15/ISBN978-4-863-54275-4-05-02/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h2 id="システムコール"><a href="#システムコール" class="headerlink" title="システムコール"></a>システムコール</h2><p>「非特権モードで動作しているプログラム」が「特権モードで動作しているカーネル」に「仕事を依頼する」方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /bin/echo hello</span></span><br><span class="line">hello</span><br><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p>このコマンド実行するときに、システムコールが呼ばれる回数を表示させてみると、12種類のシステムコールが合計で30回呼ばれていることが分かる。<br>こでは調査するコマンドとして<code>truss</code>を使っているが、ユーザーランド<code>DTrace</code>を利用できる環境ならDTraceを利用できる。<br>C言語のプログラミングでは、入門段階で作成する簡単なコードだが、このような単純に見えるコードでも多くのシステムコールが実行されていることが分かるだろう。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># truss -S -c /bin/echo hello</span></span><br><span class="line">hello</span><br><span class="line">syscall                     seconds   calls  errors</span><br><span class="line">readlink                0.000429664       1       1</span><br><span class="line">lseek                   0.000171251       1       0</span><br><span class="line">mmap                    0.003209627       7       0</span><br><span class="line">mprotect                0.000157003       1       0</span><br><span class="line">open                    0.000940342       3       1</span><br><span class="line">close                   0.000433854       2       0</span><br><span class="line">fstat                   0.000649803       1       0</span><br><span class="line"><span class="built_in">break</span>                   0.000197232       1       0</span><br><span class="line">access                  0.000201422       1       0</span><br><span class="line">sigprocmask             0.006510885       8       0</span><br><span class="line">munmap                  0.002529093       2       0</span><br><span class="line"><span class="built_in">read</span>                    0.029569680       2       0</span><br><span class="line">------------- ------- -------</span><br><span class="line">0.044999856      30       2</span><br><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure>
<h2 id="システムコールと標準ライブラリ関数の違い"><a href="#システムコールと標準ライブラリ関数の違い" class="headerlink" title="システムコールと標準ライブラリ関数の違い"></a>システムコールと標準ライブラリ関数の違い</h2><p>しかし、一般的なソフトウェアのの開発現場でシステムコールを直接利用するようなプログラムを作ることはほとんどない。<br>その理由としては、システムコールそのものが扱いにくいことが多いというここと、基本的には<strong>システムコールを呼ばない方がプログラムの処理性能を高められる</strong>からだ。</p>
<figure class="highlight c"><figcaption><span>基本的なファイル読み書きプログラム</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    FILE *fi, *fo;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    fi = fopen(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fo = fopen(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    b = fgetc(fi);</span><br><span class="line">    <span class="keyword">while</span> (EOF != b) &#123;</span><br><span class="line">        fputc(b, fo);</span><br><span class="line">        b = fgetc(fi);</span><br><span class="line">    &#125; </span><br><span class="line">    fclose(fi);</span><br><span class="line">    fclose(fo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><figcaption><span>システムコールを利用したファイル読み書きプログラム</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fdi, fdo;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">1</span>];</span><br><span class="line">    fdi = open(<span class="string">&quot;in&quot;</span>, O_RDONLY);<span class="comment">//システムコール</span></span><br><span class="line">    fdo = open(<span class="string">&quot;out&quot;</span>, O_WRONLY);<span class="comment">//システムコール</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> &lt; read(fdi, b, <span class="number">1</span>)) &#123;</span><br><span class="line">        write(fdo, b, <span class="number">1</span>);<span class="comment">//システムコール</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(fdi);<span class="comment">//システムコール</span></span><br><span class="line">    close(fdo);<span class="comment">//システムコール</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```ps```コマンドを使ってプログラムが消費しているメモリ量を調べる。</span><br><span class="line">```bash</span><br><span class="line">% rm -f out</span><br><span class="line">% touch out</span><br><span class="line">% /usr/bin/time ./copy-read-write</span><br><span class="line">15.48 real         0.33 user        14.91 sys</span><br><span class="line">%</span><br></pre></td></tr></table></figure>
<p>標準ライブラリの関数を使うと、<strong>処理速度が速いく、メモリ使用量が少ない</strong>。</p>
<p>主なUNIX／Linux OSで使えるddコマンドの引数と、trussコマンドと同じ機能を持つコマンドの名前</p>
<table>
<thead>
<tr>
<th>OS</th>
<th>dd</th>
<th>truss</th>
</tr>
</thead>
<tbody><tr>
<td>FreeBSD 9.0</td>
<td>if=/dev/random bs=1m count=10</td>
<td>truss -Sc</td>
</tr>
<tr>
<td>Mac OS X Lion</td>
<td>if=/dev/random bs=1m count=10</td>
<td>sudo dtruss -c</td>
</tr>
<tr>
<td>Ubuntu 11.10</td>
<td>if=/dev/zero bs=1M count=10</td>
<td>strace -s</td>
</tr>
<tr>
<td>Solaris 11</td>
<td>if=/dev/zero bs=1M count=10</td>
<td>truss -c</td>
</tr>
</tbody></table>
<figure class="highlight c"><figcaption><span>標準ライブラリを使ったファイルのコピー</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    FILE *fi, *fo;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    fi = fopen(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fo = fopen(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    b = fgetc(fi);</span><br><span class="line">    <span class="keyword">while</span> (EOF != b) &#123;</span><br><span class="line">        fputc(b, fo);</span><br><span class="line">        b = fgetc(fi);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>システムコールに書き換えたファイルのコピー</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fdi, fdo, fsize = <span class="number">104857600</span>;</span><br><span class="line">    <span class="keyword">char</span> *i, *o;</span><br><span class="line">    fdi = open(<span class="string">&quot;in&quot;</span>, O_RDONLY);</span><br><span class="line">    fdo = open(<span class="string">&quot;out&quot;</span>, O_RDWR);</span><br><span class="line">    i = mmap(<span class="literal">NULL</span>, fsize, PROT_READ, MAP_SHARED, fdi, <span class="number">0</span>);</span><br><span class="line">    o = mmap(<span class="literal">NULL</span>, fsize, PROT_WRITE, MAP_SHARED, fdo, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (fsize--) &#123;</span><br><span class="line">        *o++ = *i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>なぜ<code>mmap</code>を使うと処理速度が上がるのか。これは「<strong>カーネルとコピープログラムの間でデータのコピーが発生しないから</strong>」と説明できる。</p>
<h2 id="高速化に効くシステムコールが犠牲にするもの"><a href="#高速化に効くシステムコールが犠牲にするもの" class="headerlink" title="高速化に効くシステムコールが犠牲にするもの"></a>高速化に効くシステムコールが犠牲にするもの</h2><p>コマンド<code>/usr/bin/time</code>を使って、プログラムが使用した物理メモリサイズやページフォールトの回数、コンテキストスイッチの回数などを見れる。</p>
<ul>
<li>real: プログラムの実行にかかった時間</li>
<li>maximum resident set size: プログラムが利用した物理メモリの最大値を表す（単位はKbytes）</li>
<li>page reclaims: 入出力の発生を伴わないページフォールトが発生した回数</li>
<li>block output operations: ファイルシステムがデータを出力した回数</li>
<li>voluntary context switches: 割り当てられたプロセッサ時間を消費する前に、自発的にコンテキストスイッチを実行した回数</li>
<li>involuntary context switches: 時間切れや、ほかの優先度の高いプロセスの実行のために強制的にコンテキストスイッチが発生した回数</li>
</ul>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>組込み系</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>組込みエンジニアの教科書_CHAPTER05(リアルタイムOS)</title>
    <url>/BassHero.github.io/2025/04/14/ISBN978-4-863-54275-4-05/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<p>RTOS(リアルタイムOS)：決められた時間を守ることを目的にスケジューリングが実行される。<br>汎用OS：処理ごとに時間を分け合いながらスケジューリングする。</p>
<p>基本的に汎用OS方が高機能ですが、汎用OSは多数の機能に時間を平等に与えるため、処理時間に制約条件がない。<br>RTOSはevent-driven型。汎用OSはTSS(Time Sharing System)<br>組込みOSがあると、<strong>ハードウェアを時間で効率よく使えるから</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;freertos/timers.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;freertos/queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// タスク優先度の定義</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIGH_PRIORITY_TASK_PRIO   3  <span class="comment">// 高優先度タスク</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEDIUM_PRIORITY_TASK_PRIO 2  <span class="comment">// 中優先度タスク</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOW_PRIORITY_TASK_PRIO    1  <span class="comment">// 低優先度タスク</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// タイマーハンドル</span></span><br><span class="line">TimerHandle_t xTimer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// タスク間通信用キュー</span></span><br><span class="line">QueueHandle_t xQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高優先度タスク</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vHighPriorityTask</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;高優先度タスク実行中 - カウント: %d\n&quot;</span>, count++);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>)); <span class="comment">// 1秒遅延</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// キューにメッセージを送信</span></span><br><span class="line">        <span class="keyword">int</span> message = <span class="number">100</span> + count;</span><br><span class="line">        xQueueSend(xQueue, &amp;message, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中優先度タスク</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vMediumPriorityTask</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;中優先度タスク実行中 - カウント: %d\n&quot;</span>, count++);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1500</span>)); <span class="comment">// 1.5秒遅延</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低優先度タスク</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vLowPriorityTask</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> received_value;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;低優先度タスク実行中 - カウント: %d\n&quot;</span>, count++);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// キューからメッセージを受信</span></span><br><span class="line">        <span class="keyword">if</span>(xQueueReceive(xQueue, &amp;received_value, pdMS_TO_TICKS(<span class="number">500</span>)) == pdTRUE) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;低優先度タスクが受信: %d\n&quot;</span>, received_value);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">2000</span>)); <span class="comment">// 2秒遅延</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// タイマーコールバック関数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vTimerCallback</span><span class="params">(TimerHandle_t xTimer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> timer_count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;タイマー期限切れ! カウント: %d\n&quot;</span>, timer_count++);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ここで定期的な操作を実行可能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// int型値を最大5個保持可能なキューを作成</span></span><br><span class="line">    xQueue = xQueueCreate(<span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(xQueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;キューの作成に失敗しました!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3秒周期の自動再ロードタイマーを作成</span></span><br><span class="line">    xTimer = xTimerCreate(</span><br><span class="line">        <span class="string">&quot;PeriodicTimer&quot;</span>,             <span class="comment">// タイマー名</span></span><br><span class="line">        pdMS_TO_TICKS(<span class="number">3000</span>),         <span class="comment">// タイマー周期(3秒)</span></span><br><span class="line">        pdTRUE,                      <span class="comment">// 自動再ロード</span></span><br><span class="line">        (<span class="keyword">void</span> *)<span class="number">0</span>,                   <span class="comment">// タイマーID</span></span><br><span class="line">        vTimerCallback               <span class="comment">// コールバック関数</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(xTimer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;タイマーの作成に失敗しました!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// タイマーを開始</span></span><br><span class="line">    <span class="keyword">if</span>(xTimerStart(xTimer, <span class="number">0</span>) != pdPASS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;タイマーの開始に失敗しました!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 異なる優先度の3つのタスクを作成</span></span><br><span class="line">    xTaskCreate(</span><br><span class="line">        vHighPriorityTask,           <span class="comment">// タスク関数</span></span><br><span class="line">        <span class="string">&quot;HighPriorityTask&quot;</span>,          <span class="comment">// タスク名</span></span><br><span class="line">        <span class="number">2048</span>,                        <span class="comment">// スタックサイズ</span></span><br><span class="line">        <span class="literal">NULL</span>,                        <span class="comment">// パラメータ</span></span><br><span class="line">        HIGH_PRIORITY_TASK_PRIO,     <span class="comment">// 優先度</span></span><br><span class="line">        <span class="literal">NULL</span>                         <span class="comment">// タスクハンドル</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    xTaskCreate(</span><br><span class="line">        vMediumPriorityTask,         <span class="comment">// タスク関数</span></span><br><span class="line">        <span class="string">&quot;MediumPriorityTask&quot;</span>,        <span class="comment">// タスク名</span></span><br><span class="line">        <span class="number">2048</span>,                        <span class="comment">// スタックサイズ</span></span><br><span class="line">        <span class="literal">NULL</span>,                        <span class="comment">// パラメータ</span></span><br><span class="line">        MEDIUM_PRIORITY_TASK_PRIO,  <span class="comment">// 優先度</span></span><br><span class="line">        <span class="literal">NULL</span>                         <span class="comment">// タスクハンドル</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    xTaskCreate(</span><br><span class="line">        vLowPriorityTask,            <span class="comment">// タスク関数</span></span><br><span class="line">        <span class="string">&quot;LowPriorityTask&quot;</span>,            <span class="comment">// タスク名</span></span><br><span class="line">        <span class="number">2048</span>,                        <span class="comment">// スタックサイズ</span></span><br><span class="line">        <span class="literal">NULL</span>,                        <span class="comment">// パラメータ</span></span><br><span class="line">        LOW_PRIORITY_TASK_PRIO,      <span class="comment">// 優先度</span></span><br><span class="line">        <span class="literal">NULL</span>                         <span class="comment">// タスクハンドル</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;すべてのタスクとタイマーが正常に作成されました!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="組込みOSのデメリット"><a href="#組込みOSのデメリット" class="headerlink" title="組込みOSのデメリット"></a>組込みOSのデメリット</h2><p><strong>処理時間のオーバーヘッド</strong><br>OSがタスクの切り替えやその他の処理を行うために消費するCPUリソースのことで、性能を低下させ、リアルタイム性を損なう可能性があります。<br><strong>スタックオーバーフロー</strong><br>他のタスクのスタック領域を破壊</p>
<p><strong>コルーチン型マルチタスク</strong><br>コルーチンはシングルスレッドであり、マルチスレッドとは異なって、外から切り替えを行うのではなく自身で中断ができることが利点です。<br>RAMの消費が抑える。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>組込み系</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>WindowsServer2016_01</title>
    <url>/BassHero.github.io/2025/04/13/WindowsServer2016-01/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h2 id="系统的安装"><a href="#系统的安装" class="headerlink" title="系统的安装"></a>系统的安装</h2><h2 id="检查设备驱动状态"><a href="#检查设备驱动状态" class="headerlink" title="检查设备驱动状态"></a>检查设备驱动状态</h2><p>「开始」–→　设备管理器</p>
<h2 id="接入工作组WorkGroup"><a href="#接入工作组WorkGroup" class="headerlink" title="接入工作组WorkGroup"></a>接入工作组WorkGroup</h2><p>控制面板 系统和安全 系统 高级系统设置</p>
<h2 id="Windows域介绍"><a href="#Windows域介绍" class="headerlink" title="Windows域介绍"></a>Windows域介绍</h2></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>OS</category>
        <category>WindowsServer2016</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>組込みエンジニアの教科書_CHAPTER04</title>
    <url>/BassHero.github.io/2025/04/13/ISBN978-4-863-54275-4-04/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h2 id="Arduinoのハードウェアを確認する"><a href="#Arduinoのハードウェアを確認する" class="headerlink" title="Arduinoのハードウェアを確認する"></a>Arduinoのハードウェアを確認する</h2><p>1.型番から<strong>データシート</strong>と言われるハードウェアマニュアルを入手できる。<br>2.ピン構成と基盤回路図を確認する<br>3.基盤のシルク名と端子構成、コネクタとマイコンの配線のドキュメントを作成</p>
<figure class="highlight c"><figcaption><span>LED点滅</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;avr/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    DDRB | =(<span class="number">1</span> &lt;&lt;PB1); <span class="comment">//ATmega328Pのピンの初期設定をする   </span></span><br><span class="line">    <span class="comment">// DDRB The Port B Data Direction Register</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        PORTB ^=(<span class="number">1</span> &lt;&lt;PB1);   <span class="comment">//ATmega328Pのピンから信号を出力</span></span><br><span class="line">        <span class="comment">// PORTB The Port B Data Register</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&gt;)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">10000</span>; j++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><figcaption><span>動作確認</span></figcaption><table><tr><td class="code"><pre><span class="line">//ビルド</span><br><span class="line">//最適化オプションを付けるとfor文なくなるので、最適化なしでビルド</span><br><span class="line">avr-gcc -g -mmcuatmega328p led_for .c -o lef_for.elf</span><br><span class="line">//HEXファイル生成</span><br><span class="line">avr-objcopy -I elf32-avr -O iehx led_for.elf led_for.hex</span><br><span class="line"></span><br><span class="line">//Arduino UNOボードへ転送</span><br><span class="line">avrdude -CC:\\Users\\userfolder\\arduino-1.8.8.\\hardware\\tools\\avr\\etc\\avrdude.conf -v -patamega328p -carduino -PCOM3 -b115200 -D -Uflash:w:led_for.hex:i</span><br></pre></td></tr></table></figure>

<h2 id="CPUから見た場合のレジスタ制御"><a href="#CPUから見た場合のレジスタ制御" class="headerlink" title="CPUから見た場合のレジスタ制御"></a>CPUから見た場合のレジスタ制御</h2><p><strong>先ずは、メモリーマップを確認</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DDRB |= (1 &lt;&lt; PB1&gt;&gt;);  //ATmega328Pのピンの初期設定をする</span><br><span class="line">8c: 84 e2  ldi r24, 0x24 ; 36</span><br><span class="line">8e: 90 e0  ldi r25, 0x00 ; 0</span><br><span class="line">90: 24 e2  Idi r18, 0x24 ; 36</span><br><span class="line">92: 30 e0  Idi r19, 0x00 ; 0</span><br><span class="line">94: f9 01  movw r30, r18</span><br><span class="line">96: 20 81  ld r18, Z</span><br><span class="line">98: 22 60  ori r18, 0x02 ; 2</span><br><span class="line">9a: fc 01  movw r30, r24</span><br><span class="line">9c: 20 83  st Z, r18</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>ldi命令</strong>:即値(immdiate value)をレジスタに書き込む<br><strong>movw命令</strong>:word(16bit)幅でレジスタ間のデータコピーを行う命令<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movw r30, r18と書い、実際　r30,r31 ←　r18,r19という書き込み<br><strong>ld命令</strong>:間接アドレッシング。0ⅹ0024番地の値がr18レジスタに書き込む<br><strong>ori命令</strong>:論理演算OR<br><strong>st命令</strong>:ori命令の結果を0ⅹ0024番地に書き込む。</p>
<p>つまり、CPUから見るレジスタ制御は以下のように<br>①CPU内蔵レジスタを使って、制御したい番地を指定する<br>②指定した番地をZレジスタに設定することで、CPU外部のペリフェラルをを制御する<br>③データバスを使って、CPU以外のペリフェラルに書き込む。GPIOを使って、LEDを制御する</p>
<figure class="highlight c"><figcaption><span>LED点滅(delay)</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_CPU 1000000UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;avr/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;util/delay.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DDRB | =(<span class="number">1</span> &lt;&lt;PB1); <span class="comment">//ATmega328Pのピンの初期設定をする   </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        PORTB ^=(<span class="number">1</span> &lt;&lt;PB1);   <span class="comment">//ATmega328Pのピンから信号を出力</span></span><br><span class="line">        </span><br><span class="line">        _delay_ms(<span class="number">500</span>);    <span class="comment">//500ms遅延</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>F_CPU</strong>:CPUコアの動作クロックを1MHz(1秒に100万回)として定義</p>
<p>_delay_msを使うことで、ビルドに最適化オプション付けて問題ないです。<br>但し、複数の処理を行う時はハードウェアのタイマーを利用すること。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>組込み系</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>組込みエンジニアの教科書_CHAPTER03(テスト環境とコンパイラ)</title>
    <url>/BassHero.github.io/2025/04/13/ISBN978-4-863-54275-4-03-2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>

<h2 id="組込みソフトウェアのテスト環境"><a href="#組込みソフトウェアのテスト環境" class="headerlink" title="組込みソフトウェアのテスト環境"></a>組込みソフトウェアのテスト環境</h2><p><strong>■ ICE(In-ircuit Emulator)</strong></p>
<table>
<thead>
<tr>
<th>ICE</th>
<th>概要</th>
<th>メリット</th>
<th>デメリット</th>
<th>価格</th>
</tr>
</thead>
<tbody><tr>
<td>JTAG ICE</td>
<td>JTAGインターフェースで組込み機器のCPUが持っているデバッグ機能を利用する</td>
<td>組込み機器のCPUが持っている機器のみ使える</td>
<td>組込み機器のCPUに機能がないと利用できない</td>
<td>安価</td>
</tr>
<tr>
<td>フルICE</td>
<td>組込み機器のCPUをエニュミレーションする</td>
<td>組込み機器のCPUの代わりに</td>
<td>価格が高価、最近はあまり利用されない</td>
<td>高価</td>
</tr>
</tbody></table>
<p>ICEの基本機能<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CPU上のプログラムの実行、停止（ブレーク）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;レジスタの表示、変更<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;メモリ内容の表示、変更<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ブレークポイント<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;強制ブレークの他にブレークポイントを指定してブレークさせることが可能である。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ステップ実行<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;プログラムトレース<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;プロファイル解析</p>
<p><strong>■ シリアルポート</strong><br>printf()を利用して、モニターに出力</p>
<p><strong>■ 波形の観測</strong><br><strong>ロジックアナライザー</strong>：ステート解析、タイミング解析<br><strong>オシロスコープ</strong>     ：タイミング解析、波形解析</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>ステート解析</strong>：CPUのクロックと同期。「同期解析」です。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CPUとペリフェラルの同期状態、CPUよメモリの同期状態を波形で観測。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;デコーダ、プロトコル解析、逆アセンブル、ソース相関、画像への変換、変調解析、パフォーマンス解析など。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>タイミング解析</strong>：測定機器の内部クロックを観測するため、「非同期解析」です。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>波形解析</strong>：信号の時間と電圧<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;信号の周波数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;信号で表される回路の「可動部分」<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;信号の特定部分の発生頻度<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正常に動作していない部品による信号への影響<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直流電流（DC）と交流電流（AC）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ノイズ成分の大きさやその時間変化<br><br><br></p>
<h2 id="コンパイル"><a href="#コンパイル" class="headerlink" title="コンパイル"></a>コンパイル</h2><p><strong>■ コンパイルの最適化(Optimize)オプション</strong></p>
<p>実行速度の向上、コードサイズの削減、メモリ使用量の削減:</p>
<ul>
<li>O0 (最適化なし):最適化を行わない設定です。デバッグに役立つ場合があります。</li>
<li>O1 (レベル1最適化):比較的シンプルな最適化を行います。</li>
<li>O2 (レベル2最適化):より高度な最適化を行います。</li>
<li>O3 (レベル3最適化):最も高度な最適化を行います。実行速度を優先する場合に使用します。</li>
<li>Os (サイズ最適化):コードのサイズを優先する最適化を行います。</li>
<li>Osize (サイズ最適化):コードのサイズをさらに優先する最適化を行います。</li>
<li>Og (デバッグ情報):デバッグ情報を保持したまま最適化を行います。</li>
<li>Ofast (最速最適化):実行速度を優先し、一部の最適化では、ANSI規格やIEEE規格に準拠しない場合があります。</li>
<li>fno-inline (インライン展開無効):関数をインライン展開しない設定です。デバッグに役立つ場合があります。</li>
</ul>
<p><strong>■ volatile宣言</strong></p>
<p>ハードウェアの状態を一定の間隔でチェックするプログラムは <strong>「ポーリング」</strong> と呼ばれています。<br>ポーリングはコンパイラ最適化によってコードが消えることがあります、コードが消えないように<code>volatile</code>宣言が必要です。</p>
<p><strong>■ unsignedとsigned</strong></p>
<p>signed/unsignedとは、変数に修飾子として付けることで符号有り（負数と正数）/符号無し（正数）を決めるもの。<br>符号有りの場合、先頭1bitを符号として扱うため、 <strong>表現できる値が少なくなります。</strong></p>
<p>ハードウェア制御において、ビット操作やレジスタの値が誤ってマイナスとして解釈されるのを防ぐために、無符号整数（unsigned）を使用することが重要です。<br>符号付き整数 0xFF（10進数で -1）<br>無符号整数で 0xFF（10進数で 255）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> control_bit :<span class="number">1</span>  <span class="comment">//1か0のどちかになる</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静的解析で引っかかったこと</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">example</span><span class="params">( <span class="keyword">int</span> iAug)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint uiTemp = <span class="number">0</span>;</span><br><span class="line">    uiTemp = iAug;</span><br><span class="line">    <span class="comment">// 変数同士でデータの受け渡しを行う場合、データ型、符号の有無は出来るだけ揃える</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h2 id="pragma"><a href="#pragma" class="headerlink" title="pragma"></a>pragma</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>メモリのセクション指定</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;組込みシステム開発においては、変数や関数をメモリ内の決められたアドレス範囲に配置することを要求される場合があります。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// my_sectionのアドレス範囲内に、変数 myaVariable を配置する例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_section=<span class="meta-string">&quot;.my_section&quot;</span></span></span><br><span class="line"><span class="keyword">int</span> myVariable;</span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>割り込み関数の指定</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;組込みシステム開発においては、ハードウェアの割り込みに対応する関数（割り込みハンドラ）を定義する必要があります。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;割り込み関数は、通常の関数とは使用する命令コードが異なる場合があり、#pragmaディレクティブを使用して、その関数が割り込みハンドラであることをコンパイラに指示する必要があります。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> interrupt</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myInterruptHandler</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// この関数は、割り込みハンドラとしてコンパイルされる</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h2 id="ポインターと配列"><a href="#ポインターと配列" class="headerlink" title="ポインターと配列"></a>ポインターと配列</h2><p>配列だけ使うソースコードはコンパイル後、<br>配列＋ポインターを使うソースコードをコンパイル後、より命令数が多い、ループ内処理命令も一つおおくなる。</p>
<p><br><br></p>
<h2 id="割り込みハンドラー"><a href="#割り込みハンドラー" class="headerlink" title="割り込みハンドラー"></a>割り込みハンドラー</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;avr/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;avr/interrupt.h&gt;</span><span class="comment">/*割り込みを使用するためのincLude定義*/</span></span></span><br><span class="line"></span><br><span class="line">ISR(TIMERO_COMPA_vct) <span class="comment">/*timereの割り込み関数の登録*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*ここに割り込み時の処理を書く*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*割り込み関連の初期化処理*/</span></span><br><span class="line">    TCCROA = <span class="number">0b10000010</span>;<span class="comment">/*10：コンペアマッチAでLOW,10:CTCモード*/</span></span><br><span class="line">    TCCROB = <span class="number">0b00000001</span>;<span class="comment">/*分周なし*/</span></span><br><span class="line">    TIMSKO=Ob00000010;<span class="comment">/*コンペアマッチAの割り込みを設定*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*コンペアマッチする時間の設定*/</span></span><br><span class="line">    OCROA = <span class="number">32499</span>;<span class="comment">/*32.5msでコンペアマッチ ＠1MHZ*/</span></span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    sei()；<span class="comment">/*割り込み許可*/</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;<span class="comment">/*無限ループ*/</span></span><br><span class="line">        ....</span><br><span class="line">    <span class="comment">/*main処理を記述する*/</span></span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>組込み系</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础自测问题_02</title>
    <url>/BassHero.github.io/2025/04/09/InternetNotes-02/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h3 id="一、基础协议问题"><a href="#一、基础协议问题" class="headerlink" title="一、基础协议问题"></a><strong>一、基础协议问题</strong></h3><ol>
<li><strong>TCP协议</strong></li>
</ol>
<ul>
<li>描述TCP三次握手和四次挥手的过程。为什么握手是三次，而挥手需要四次？</li>
<li>什么是TCP的滑动窗口机制？它如何实现流量控制？</li>
<li>如果TCP连接的一方突然宕机（未发送FIN包），另一方会如何处理？</li>
</ul>
<ol start="2">
<li><strong>UDP协议</strong></li>
</ol>
<ul>
<li>UDP是否绝对不可靠？举一个基于UDP但实现可靠传输的协议例子（如QUIC）。</li>
<li>为什么DNS查询默认使用UDP，但在某些情况下会切换到TCP？</li>
</ul>
<ol start="3">
<li><strong>HTTP/1.1 vs HTTP/2</strong></li>
</ol>
<ul>
<li>HTTP/1.1的队头阻塞（Head-of-Line Blocking）问题是什么？HTTP/2如何解决它？</li>
<li>什么是HTTP长连接（Keep-Alive）？如何通过Wireshark观察它的行为？</li>
</ul>
<ol start="4">
<li><strong>DNS协议</strong></li>
</ol>
<ul>
<li>递归查询 vs 迭代查询的区别是什么？</li>
<li>什么是DNS缓存投毒（DNS Cache Poisoning）？如何防御？</li>
</ul>
<ol start="5">
<li><strong>ARP协议</strong></li>
</ol>
<ul>
<li>ARP协议的作用是什么？如何用<code>arp -a</code>命令查看本地ARP缓存？</li>
<li>如何通过伪造ARP响应实现中间人攻击（MITM）？</li>
</ul>
<hr>
<h3 id="二、进阶协议与安全"><a href="#二、进阶协议与安全" class="headerlink" title="二、进阶协议与安全"></a><strong>二、进阶协议与安全</strong></h3><ol>
<li><strong>HTTPS与TLS</strong></li>
</ol>
<ul>
<li>TLS握手过程中，客户端和服务端如何协商加密套件（Cipher Suite）？</li>
<li>什么是SNI（Server Name Indication）？为什么它会影响HTTPS的安全性？</li>
<li>如果证书链中的中间CA私钥泄露，会引发什么风险？</li>
</ul>
<ol start="2">
<li><strong>WebSocket协议</strong></li>
</ol>
<ul>
<li>WebSocket如何通过HTTP完成握手？握手请求头中的<code>Upgrade</code>字段作用是什么？</li>
<li>如何防御WebSocket的跨站劫持（Cross-Site WebSocket Hijacking）？</li>
</ul>
<ol start="3">
<li><strong>ICMP协议</strong></li>
</ol>
<ul>
<li>Ping命令基于ICMP的哪类报文？如何用ICMP实现隐蔽通信（如ICMP隧道）？</li>
<li>什么是ICMP重定向攻击？如何防范？</li>
</ul>
<ol start="4">
<li><strong>DHCP协议</strong></li>
</ol>
<ul>
<li>DHCP的四步分配过程（DISCOVER-OFFER-REQUEST-ACK）是如何工作的？</li>
<li>什么是DHCP饥饿攻击（DHCP Starvation Attack）？如何防御？</li>
</ul>
<ol start="5">
<li><strong>SSH协议</strong></li>
</ol>
<ul>
<li>SSH密钥交换的过程（如Diffie-Hellman）是如何保证安全性的？</li>
<li>如何通过SSH隧道实现端口转发（Port Forwarding）？举例说明其应用场景。</li>
</ul>
<hr>
<h3 id="三、协议分析与实践"><a href="#三、协议分析与实践" class="headerlink" title="三、协议分析与实践"></a><strong>三、协议分析与实践</strong></h3><ol>
<li><strong>Wireshark实战</strong></li>
</ol>
<ul>
<li>抓取一次DNS查询过程，分析请求和响应的报文结构（如查询类型、响应记录）。</li>
<li>分析一次HTTPS握手过程，找到Client Hello和Server Hello报文中的加密套件列表。</li>
<li>如何通过Wireshark过滤出所有重传的TCP报文？重传的可能原因有哪些？</li>
</ul>
<ol start="2">
<li><strong>协议逆向与调试</strong></li>
</ol>
<ul>
<li>用Python的<code>scapy</code>库构造一个伪造源IP的SYN包（SYN Flood攻击的原理）。</li>
<li>如何通过修改Host头实现HTTP请求走私（HTTP Request Smuggling）？</li>
</ul>
<ol start="3">
<li><strong>协议漏洞场景</strong></li>
</ol>
<ul>
<li>为什么过时的SSLv2/SSLv3协议被认为不安全？列举它们已知的漏洞（如POODLE）。</li>
<li>什么是Slowloris攻击？它如何利用HTTP协议的特性耗尽服务器资源？</li>
</ul>
<hr>
<h3 id="四、开放性问题（面试常见）"><a href="#四、开放性问题（面试常见）" class="headerlink" title="四、开放性问题（面试常见）"></a><strong>四、开放性问题（面试常见）</strong></h3><ol>
<li><strong>设计类问题</strong></li>
</ol>
<ul>
<li>如果要设计一个实时视频传输协议，你会选择TCP还是UDP？为什么？</li>
<li>如何为一个物联网设备设计轻量级的通信协议（考虑功耗与安全）？</li>
</ul>
<ol start="2">
<li><strong>安全攻防</strong></li>
</ol>
<ul>
<li>如何通过篡改HTTP响应头实施XSS攻击？怎样通过CSP（Content Security Policy）防御？</li>
<li>什么是证书透明化（Certificate Transparency）？它如何防止恶意证书的签发？</li>
</ul>
<ol start="3">
<li><strong>协议扩展性</strong></li>
</ol>
<ul>
<li>HTTP/3为什么要基于QUIC协议？QUIC相比TCP有哪些优势？</li>
<li>在IPv6普及的背景下，NAT协议是否还有必要存在？为什么？</li>
</ul>
<hr>
<h3 id="五、学习建议"><a href="#五、学习建议" class="headerlink" title="五、学习建议"></a><strong>五、学习建议</strong></h3><ol>
<li><strong>动手实验</strong></li>
</ol>
<ul>
<li>用<code>telnet</code>或<code>nc</code>手动构造HTTP请求（如<code>GET / HTTP/1.1</code>），观察服务器响应。</li>
<li>在虚拟机中搭建DNS服务器（如Bind9），配置域名解析并测试投毒攻击。</li>
</ul>
<ol start="2">
<li><strong>协议文档</strong></li>
</ol>
<ul>
<li>阅读RFC文档（如TCP的RFC 793、HTTP/1.1的RFC 2616），理解协议设计细节。</li>
<li>对比不同协议的RFC，观察设计思路差异（如TCP的可靠性与UDP的简洁性）。</li>
</ul>
<ol start="3">
<li><strong>安全工具链</strong></li>
</ol>
<ul>
<li>使用<code>openssl s_client</code>命令调试TLS握手过程（如<code>openssl s_client -connect google.com:443</code>）。</li>
<li>用Nmap脚本引擎（NSE）检测协议漏洞（如<code>nmap --script ssl-enum-ciphers</code>）。</li>
</ul>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础自测问题</title>
    <url>/BassHero.github.io/2025/04/09/InternetNotes/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>

<h3 id="一、基础自测问题（适合初学者）"><a href="#一、基础自测问题（适合初学者）" class="headerlink" title="一、基础自测问题（适合初学者）"></a><strong>一、基础自测问题（适合初学者）</strong></h3><p>先测试你的基础网络知识，如果大部分不会，需要补基础；如果已掌握，可以跳到进阶部分。</p>
<h4 id="1-网络分层模型"><a href="#1-网络分层模型" class="headerlink" title="1. 网络分层模型"></a><strong>1. 网络分层模型</strong></h4><ul>
<li><strong>问题</strong>：OSI七层模型和TCP/IP四层模型的区别是什么？每层的核心功能是什么？</li>
<li><strong>问题</strong>：HTTP协议属于哪一层？路由器工作在哪一层？</li>
<li><strong>问题</strong>：为什么需要分层？如果物理层被攻击，可能引发什么问题？</li>
</ul>
<h4 id="2-IP与子网"><a href="#2-IP与子网" class="headerlink" title="2. IP与子网"></a><strong>2. IP与子网</strong></h4><ul>
<li><strong>问题</strong>：IPv4地址 <code>192.168.1.100/24</code> 的子网掩码是什么？这个子网最多容纳多少台设备？</li>
<li><strong>问题</strong>：解释NAT（网络地址转换）的作用，为什么家庭路由器需要它？</li>
<li><strong>问题</strong>：公网IP和私有IP的区别是什么？私有IP范围有哪些？</li>
</ul>
<h4 id="3-协议与端口"><a href="#3-协议与端口" class="headerlink" title="3. 协议与端口"></a><strong>3. 协议与端口</strong></h4><ul>
<li><strong>问题</strong>：TCP和UDP的区别是什么？举出各自的应用场景。</li>
<li><strong>问题</strong>：HTTP和HTTPS的核心区别是什么？HTTPS如何保证安全性？</li>
<li><strong>问题</strong>：DNS的作用是什么？描述一次DNS查询的完整过程。</li>
</ul>
<h4 id="4-网络工具实践"><a href="#4-网络工具实践" class="headerlink" title="4. 网络工具实践"></a><strong>4. 网络工具实践</strong></h4><ul>
<li><strong>问题</strong>：如何用<code>ping</code>命令测试网络连通性？TTL值的含义是什么？</li>
<li><strong>问题</strong>：用<code>traceroute</code>（Windows是<code>tracert</code>）追踪到<code>google.com</code>的路由路径，解释输出结果。</li>
<li><strong>问题</strong>：用Wireshark抓取一次HTTP请求，分析TCP三次握手过程。</li>
</ul>
<hr>
<h3 id="二、学习方法与提高路径"><a href="#二、学习方法与提高路径" class="headerlink" title="二、学习方法与提高路径"></a><strong>二、学习方法与提高路径</strong></h3><h4 id="1-基础夯实"><a href="#1-基础夯实" class="headerlink" title="1. 基础夯实"></a><strong>1. 基础夯实</strong></h4><ul>
<li><strong>书籍</strong>：《计算机网络：自顶向下方法》《TCP/IP详解 卷1》</li>
<li><strong>实验</strong>：</li>
<li>用VirtualBox搭建局域网，配置静态IP、DHCP、NAT。</li>
<li>使用Wireshark分析常见协议（如ARP、DNS、HTTP）。</li>
<li>用Python的<code>socket</code>库实现简单的TCP/UDP通信。</li>
</ul>
<h4 id="2-安全进阶"><a href="#2-安全进阶" class="headerlink" title="2. 安全进阶"></a><strong>2. 安全进阶</strong></h4><ul>
<li><strong>核心知识</strong>：</li>
<li>防火墙/ACL（访问控制列表）的工作原理。</li>
<li>中间人攻击（MITM）、DDoS、SQL注入的原理与防御。</li>
<li>SSL/TLS握手过程，证书体系（CA、公钥/私钥）。</li>
<li><strong>工具实践</strong>：</li>
<li>使用<code>nmap</code>扫描端口，识别网络服务。</li>
<li>用<code>tcpdump</code>分析网络流量。</li>
<li>在Metasploit或Burp Suite中尝试基础渗透测试。</li>
</ul>
<h4 id="3-项目实战"><a href="#3-项目实战" class="headerlink" title="3. 项目实战"></a><strong>3. 项目实战</strong></h4><ul>
<li><strong>场景</strong>：模拟企业网络，配置防火墙规则阻挡特定IP。</li>
<li><strong>场景</strong>：搭建HTTPS服务器（如用Let’s Encrypt申请免费证书）。</li>
<li><strong>场景</strong>：编写脚本检测异常流量（如SYN Flood攻击）。</li>
</ul>
<hr>
<h3 id="三、网络技术面试问题（含安全方向）"><a href="#三、网络技术面试问题（含安全方向）" class="headerlink" title="三、网络技术面试问题（含安全方向）"></a><strong>三、网络技术面试问题（含安全方向）</strong></h3><h4 id="初级问题"><a href="#初级问题" class="headerlink" title="初级问题"></a><strong>初级问题</strong></h4><ol>
<li>什么是ARP协议？如何防范ARP欺骗？</li>
<li>解释CSRF攻击的原理，如何防御？</li>
<li>什么是SYN洪水攻击？如何缓解？</li>
<li>描述HTTPS的握手过程，为什么需要非对称加密+对称加密结合？</li>
</ol>
<h4 id="高级问题"><a href="#高级问题" class="headerlink" title="高级问题"></a><strong>高级问题</strong></h4><ol>
<li>如何通过Wireshark判断一次TCP连接是否被劫持？</li>
<li>解释零信任网络（Zero Trust）的核心思想。</li>
<li>什么是DNS劫持？如何用DNSSEC防御？</li>
<li>如何设计一个安全的API认证机制？（结合OAuth2/JWT）</li>
</ol>
<h4 id="编程相关"><a href="#编程相关" class="headerlink" title="编程相关"></a><strong>编程相关</strong></h4><ul>
<li><strong>问题</strong>：用Python实现一个简单的端口扫描器。</li>
<li><strong>问题</strong>：如何检测HTTP请求中的SQL注入特征？（正则表达式或语义分析）</li>
<li>：设计一个防止暴力破解密码的算法（如封禁IP或延迟响应）。</li>
<li><strong>问题</strong>:理解协议细节（如解析HTTP头）、实现自动化安全检测。</li>
</ul>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>組込みエンジニアの教科書_CHAPTER03(OSなしソフトウェア)</title>
    <url>/BassHero.github.io/2025/04/07/ISBN978-4-863-54275-4-03/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h2 id="組込みソフトウェア開発の流れ"><a href="#組込みソフトウェア開発の流れ" class="headerlink" title="組込みソフトウェア開発の流れ"></a>組込みソフトウェア開発の流れ</h2><p><strong>クロス開発環境</strong><br>パソコンに入ってるgccはそのまま組込み環境では使えません、パソコンのCPUは組込み機器のCPUが異なっているためです。<br>Arduino向けコンパイラー avr-gcc<br><strong>ビルド</strong><br>コンパイル -→ アセンブル -→ リンク -→ HEXファイル(ROMファイル)</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>プリプロセス処理</span><br><span class="line"><span class="regexp">//</span>コンパイル処理</span><br><span class="line"><span class="regexp">//</span>アセンブル処理</span><br><span class="line"><span class="regexp">//</span>リンク処理</span><br><span class="line">avr-gcc -<span class="number">0</span>s -Wall -mmcu=atmega328p main.c -o test.elf</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>HEXファイル変換</span><br><span class="line">avr-objcopy b-l elf32-avr -O ihex test.elf test.hex</span><br></pre></td></tr></table></figure>


<p><strong>プリプロセス処理</strong><br>#include #ifdefなどのディレクティブを処理。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下のコマンドを実行し、プリプロセス処理だけ実行したファイルの中身を見れる</span></span><br><span class="line">avr-gcc -<span class="number">0s</span> -Wall -mmcu=atmega328p -E <span class="selector-tag">main</span><span class="selector-class">.c</span> &gt;preprocess.c</span><br></pre></td></tr></table></figure>

<p><strong>コンパイル処理</strong><br>コンパイル処理後、アセンブルファイルが生成される。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">avr</span>-gcc -<span class="number">0</span>s -Wall -mmcu=atmega<span class="number">328</span>p -S preprocess.c</span><br></pre></td></tr></table></figure>

<p><strong>アセンブル処理</strong><br>アセンブル処理後、OBJ形式ファイルが生成される。<br>OBJ形式ファイルはバイナリファイル。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">avr-gcc <span class="attribute">-mmcu</span>=atmega328p -o main.o preprocess.s</span><br></pre></td></tr></table></figure>

<p><strong>リンク処理</strong><br>依存しているライブラリを読み込む。</p>
<p><strong>HEXファイル変換</strong><br>ROMに書き込むためのHEXファイルが生成される。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">avr-objcopy b-l elf32-avr -O ihex <span class="keyword">test</span>.elf <span class="keyword">test</span>.hex</span><br></pre></td></tr></table></figure>

<h2 id="アセンブル言語"><a href="#アセンブル言語" class="headerlink" title="アセンブル言語"></a>アセンブル言語</h2><p><strong>スタートアップルーチン</strong><br>main関数を呼び出し前のハードウェアの初期設定、ソフトウェアを動作する前の初期設定。<br>プログラムが必要な初期設定：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ROMエリア<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RAMエリア<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;関数をコールするためのスタック領域<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;グローバル変数の初期化</p>
<p><strong>main関数が呼び出されるまでの流れ</strong><br>組込み機器の電源がONになると、リセット信号がCPUに送られます。</p>
<ul>
<li>リセット信号をCPUが受けることで、CPUの動作が始まります</li>
<li>メモリーアドレスの０番地からプログラムの実行がスタート</li>
<li>割り込みベクターの設定が行われ</li>
<li>スタック領域、データ領域などが初期化</li>
<li>main関数が呼び出される</li>
</ul>
<p>組込みソフトウェアは基本的に永久ループを作る。<br>テレビはリモートの操作で電源ON/OFFにできるのは、リモートの操作でソフトウェアを待機状態にするだけ。</p>
<p><strong>メモリーマップ</strong></p>
<table>
<thead>
<tr>
<th>セクション名</th>
<th>領域名</th>
<th>プログラムと言語</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>コード</td>
<td>機械語(プログラム)を格納</td>
</tr>
<tr>
<td>data</td>
<td>初期化済みデータ</td>
<td>初期値を持っている変数を格納</td>
</tr>
<tr>
<td>bss</td>
<td>非初期化済みデータ</td>
<td>初期値を持ってない変数を格納</td>
</tr>
</tbody></table>
<p><strong>スタック</strong><br>関数を呼び出す際に、割り込みが発生した場合に使用されるメモリエリア。LIFO。</p>
<p><strong>割り込みが発生した場合は、「割り込み発生前の戻りアドレス」と「CPUが持っている内部の状態」をスタックに保存する</strong></p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>組込み系</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>組込みエンジニアの教科書_CHAPTER02(CPU)</title>
    <url>/BassHero.github.io/2025/04/07/ISBN978-4-863-54275-4_02_2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h2 id="CPUとは"><a href="#CPUとは" class="headerlink" title="CPUとは"></a>CPUとは</h2><p><strong>PC(プログラムカウンタ)</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;次に実行すべき命令を読みだすアドレスをCPUに伝える役割<br><strong>デコーダー(decoder)</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;読みだされた命令を理解するハードウェア。<br><strong>ALU(Arithmetic and Logic Unit演算回路)</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;四則演算、論理演算<br><strong>汎用レジスタ</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内蔵高速メモリー<br><strong>システムレジスタ</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CPUが命令を実行する際に利用するレジスタ。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令レジスタ<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;アドレスレジスタ<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ステータスレジスタ</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Carry (C)</td>
<td>桁上がりフラグ</td>
<td>8ビットの演算で上位ビットに桁上がりが発生した場合に1に</td>
</tr>
<tr>
<td>Zero (Z)</td>
<td>ゼロフラグ</td>
<td>演算結果が0の場合に1に</td>
</tr>
<tr>
<td>Negative (N)</td>
<td>負数フラグ</td>
<td>演算結果が負の場合に1に</td>
</tr>
<tr>
<td>Sign (S)</td>
<td>符号フラグ</td>
<td>Nフラグと同じ意味で、演算結果が負の場合に1に</td>
</tr>
<tr>
<td>Interrupt (I)</td>
<td>割り込みフラグ</td>
<td>割り込み可能の状態を示す</td>
</tr>
</tbody></table>
<h2 id="CPUの命令実行の流れ"><a href="#CPUの命令実行の流れ" class="headerlink" title="CPUの命令実行の流れ"></a>CPUの命令実行の流れ</h2><p><strong>命令フェッチ (Instruction Fetch)</strong>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;メモリ(ROM)から命令を取り出す。<br><strong>命令デコード (Instruction Decode)</strong>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令を解読して、実行準備。<br><strong>命令実行 (Instruction Execute)</strong>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令を実行。例えば、ALU（演算論理ユニット）による演算などが該当する。<br><strong>結果書き込み (Write Back)</strong>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;結果をレジスタやメモリ(RAM)に書き込む。</p>
<h2 id="CPU-命令種類"><a href="#CPU-命令種類" class="headerlink" title="CPU 命令種類"></a>CPU 命令種類</h2><p><strong>算術演算命令</strong>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加算、減算、乗算、除算などの数値計算を行う命令です。<br><strong>論理演算命令</strong>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;論理積、論理和、否定などの論理演算を行う命令です。<br><strong>データ転送命令</strong>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CPUとメモリ、レジスタ間でのデータの移動を行う命令です。</p>
<h2 id="割り込み"><a href="#割り込み" class="headerlink" title="割り込み"></a>割り込み</h2><p><strong>ハードウェア割り込み:</strong> ペリフェラル<br><strong>ソフトウェア割り込み:</strong> タイマー</p>
<p><strong>割り込みベクタテーブル:</strong> 割り込みハンドラへのポインタを配列状に並べたもの。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>組込み系</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>Wireshark</title>
    <url>/BassHero.github.io/2025/04/06/ISBN978-7-115-36661-0/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>組込みエンジニアの教科書_CHAPTER02(マイコンの構成)</title>
    <url>/BassHero.github.io/2025/04/06/ISBN978-4-863-54275-4_02_1/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>

<h2 id="ハードウェアの種類"><a href="#ハードウェアの種類" class="headerlink" title="ハードウェアの種類"></a>ハードウェアの種類</h2><p><strong>1. マイコン:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CPU<br><strong>2. メモリー:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ROM(不揮発性メモリー、プログラム書き読み)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RAM(揮発性メモリー、データ書き読み)<br><strong>3. ペリフェラル(Peripheral):</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TIMER<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA Controller<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interrupt Controller<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Serial ontroller<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A/D Controller<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PWM Controller</p>
<hr>
<h2 id="バスの構成"><a href="#バスの構成" class="headerlink" title="バスの構成"></a>バスの構成</h2><p><strong>1. メインバス:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;アドレスバス<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;データバス<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;コントロールバス(ChipSelector,writeEnable,ReadEnable)<br><strong>2. クロック:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;各種のバス信号は、クロックと呼ばれるハードウェアを動作させるためのタイミング信号に同期される。<br><strong>3. ローカルバス:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;メインバスのクロック速度より低速。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>3.1. ブリッジ:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;メインバスとローカルバスを繋ぐコントローラのことで、<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高速に動作するメインバスと低速に動作するローカルバスの速度差を吸収してくれるハードウェア。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FIFOと呼ばれるハードウェア。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>3.2. UART(Universal Asynchronous Receiver/Transmitter):</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同期式シリアル信号　←→　パラレル信号<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>3.3. I2C:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SCL(シリアルロック)と双方向のSDA(シリアルデータ)の2本線を使って通信する同期式シリアル通信。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;タッチセンサー、加速度センサーなどに使われている。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>3.4. SPI:</strong> I2Cより高速。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SCK(シリアルロック)とSDI(入力)、SDO(出力)の3本線を使って通信する同期式シリアル通信。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Falsh Memory,CPU間通信などに使われている。</p>
<hr>
<h2 id="ペリフェラルとは"><a href="#ペリフェラルとは" class="headerlink" title="ペリフェラルとは"></a>ペリフェラルとは</h2><p><strong>1. DMA Controller</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常方式、PIO方式：CPUが書き読み命令を出す、CPUが渋滞になりやすい。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA方式：CPUの代わりに転送。<br><strong>2. RTC(Real Timer Controller)</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CPUの電源をとめても、起動する時にまた正確な時間を取得できる。<br><strong>3. GPIO(General Purose Input/Output)</strong></p>
<hr>
<h2 id="ペリフェラルの制御方式"><a href="#ペリフェラルの制御方式" class="headerlink" title="ペリフェラルの制御方式"></a>ペリフェラルの制御方式</h2><p>レジスタ(Regsiter)という制御用のメモリーを使って、CPUから制御されている。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>組込み系</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>組込みエンジニアの教科書_CHAPTER01</title>
    <url>/BassHero.github.io/2025/04/06/ISBN978-4-863-54275-4_01/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h2 id="NTCR要件"><a href="#NTCR要件" class="headerlink" title="NTCR要件"></a>NTCR要件</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Nature</td>
<td>自然法則</td>
</tr>
<tr>
<td>Time</td>
<td>リアルタイム性</td>
</tr>
<tr>
<td>Constraint</td>
<td>制約条件</td>
</tr>
<tr>
<td>Reliability</td>
<td>信頼性</td>
</tr>
</tbody></table>
<p><strong>ハードリアルタイム</strong>と<strong>ソフトリアルタイム</strong></p>
<table>
<thead>
<tr>
<th>機器</th>
<th>N</th>
<th>T</th>
<th>C</th>
<th>R</th>
</tr>
</thead>
<tbody><tr>
<td>カーナビ</td>
<td>角加速度センサー、タッチパネル</td>
<td>ソフトリアルタイム</td>
<td>振動、熱</td>
<td>ソフトウェア更新可</td>
</tr>
<tr>
<td>エアバッグ</td>
<td>衝突センサー、スクラブ</td>
<td>ハードリアルタイム</td>
<td>振動、熱</td>
<td>高信頼性</td>
</tr>
<tr>
<td>音楽プレイヤー</td>
<td>音声圧縮伸長、操作スイッチ</td>
<td>ソフトリアルタイム</td>
<td>消費電力、サイズ、熱</td>
<td>ソフトウェア更新可</td>
</tr>
<tr>
<td>KISOK端末</td>
<td>人感センサー、タッチパネル</td>
<td>ソフトリアルタイム</td>
<td>消費電力、熱</td>
<td>ソフトウェア更新可、セキュリティ</td>
</tr>
</tbody></table>
<p><strong>ファムウェア</strong></p>
<h2 id="キャリア"><a href="#キャリア" class="headerlink" title="キャリア"></a>キャリア</h2><h3 id="組込みスキル標準-ETSS"><a href="#組込みスキル標準-ETSS" class="headerlink" title="組込みスキル標準(ETSS)"></a>組込みスキル標準(ETSS)</h3><p><strong>組込みスキル標準</strong><br>技術要素スキルカテゴリ</p>
<table>
<thead>
<tr>
<th></th>
<th>第1階層</th>
<th></th>
<th>第2階層</th>
<th>説明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>通信</td>
<td>1</td>
<td>有線</td>
<td>WAN,LANなど有線通信技術</td>
</tr>
<tr>
<td></td>
<td></td>
<td>2</td>
<td>無線</td>
<td>電気通信事業用無線,一般業務用無線など無線通信技術</td>
</tr>
<tr>
<td></td>
<td></td>
<td>3</td>
<td>放送</td>
<td>デジタル放送,アナログ放送など放送技術</td>
</tr>
<tr>
<td></td>
<td></td>
<td>4</td>
<td>インターネット</td>
<td>透過的データ転送,アプリケーションなどインターネット通信技術</td>
</tr>
<tr>
<td>2</td>
<td>情報処理</td>
<td>1</td>
<td>情報入力</td>
<td>データ入力,音声入力など情報入力技術</td>
</tr>
<tr>
<td></td>
<td></td>
<td>2</td>
<td>セキュリティ</td>
<td>暗号,著作権保護などセキュリティ技術</td>
</tr>
<tr>
<td></td>
<td></td>
<td>3</td>
<td>データ処理</td>
<td>圧縮,データベースなどデータ処理技術</td>
</tr>
<tr>
<td></td>
<td></td>
<td>4</td>
<td>情報出力</td>
<td>マークアップランゲージや文書ビューアなど情報出力技術</td>
</tr>
<tr>
<td>3</td>
<td>マルチメディア</td>
<td>1</td>
<td>音声</td>
<td>データ処理,圧縮・伸張など音声処理技術</td>
</tr>
<tr>
<td></td>
<td></td>
<td>2</td>
<td>静止画</td>
<td>データ処理,圧縮・伸張など静止画処理技術</td>
</tr>
<tr>
<td></td>
<td></td>
<td>3</td>
<td>動画</td>
<td>データ処理,圧縮・伸張など動画処理技術</td>
</tr>
<tr>
<td></td>
<td></td>
<td>4</td>
<td>統合</td>
<td>音声・画像などの統合処理技術</td>
</tr>
<tr>
<td>4</td>
<td>ユーザインタフェース</td>
<td>1</td>
<td>人間系入力</td>
<td>ボタン,座標など人間系入力デバイス制御技</td>
</tr>
<tr>
<td></td>
<td></td>
<td>2</td>
<td>人間系出力</td>
<td>術表示,音声など人間系出力デバイス制御技術</td>
</tr>
<tr>
<td>5</td>
<td>ストレージ</td>
<td>1</td>
<td>メディア</td>
<td>リムーバブル,メモリなどストレージメディア技術</td>
</tr>
</tbody></table>
<p><strong>キャリア基準</strong><br>職種と責任の対応</p>
<table>
<thead>
<tr>
<th>職種名称</th>
<th>責任の範囲</th>
<th>責任の例</th>
</tr>
</thead>
<tbody><tr>
<td>プロダクトマネージャ</td>
<td>商品開発の事業</td>
<td>収益、貢献</td>
</tr>
<tr>
<td>プロジェクトマネージャ</td>
<td>プロジェクト</td>
<td>品質、コスト、納期</td>
</tr>
<tr>
<td>ドメインスペシャリスト</td>
<td>技術の展開</td>
<td>プロダクト（商品）開発の効率性</td>
</tr>
<tr>
<td>システムアーキテクト</td>
<td>システム構造・実現方式</td>
<td>開発の効率性・品質</td>
</tr>
<tr>
<td>ソフトウェアエンジニア</td>
<td>ソフトウェア開発の成果物</td>
<td>品質、生産性、納期</td>
</tr>
<tr>
<td>ブリッジSE</td>
<td>外部組織との共同作業</td>
<td>品質、コスト、納期</td>
</tr>
<tr>
<td>開発環境エンジニア</td>
<td>開発環境の品質</td>
<td>使用性、作業効率</td>
</tr>
<tr>
<td>開発プロセス改善スペシャリスト</td>
<td>組織の開発プロセス改善実施</td>
<td>プロセス改善効果</td>
</tr>
<tr>
<td>QAスペシャリスト</td>
<td>プロセス品質、プロダクト品質</td>
<td>出荷後の品質問題</td>
</tr>
<tr>
<td>テストエンジニア</td>
<td>システムの検証</td>
<td>品質、テスト効率性、テスト納期</td>
</tr>
</tbody></table>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>組込み系</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>特朗普的关税政策违反了WTO政策了吗</title>
    <url>/BassHero.github.io/2025/03/17/deepseekmemo/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>

<p>特朗普政府于2018年依据美国《贸易扩展法》第232条款，以“国家安全”为由对进口钢铁和铝产品分别加征25%和10%的关税。这一措施被广泛认为违反了世界贸易组织（WTO）的核心规则。</p>
<p>特朗普的钢铁关税政策因<strong>违反最惠国待遇原则</strong>、<strong>滥用国家安全例外条款</strong>，且<strong>规避贸易救济程序</strong>，被广泛视为对WTO规则的直接挑战。尽管美国援引GATT第21条自我辩护，但其措施的贸易保护主义本质和多边裁决机制的失效，暴露了当前国际贸易体系的脆弱性。这一事件不仅加剧了全球贸易冲突，也促使国际社会反思如何平衡国家安全与自由贸易的关系，以及如何改革多边机制以应对单边主义冲击。</p>
<hr>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
  </entry>
  <entry>
    <title>梵高笔记2025</title>
    <url>/BassHero.github.io/2025/03/15/podcast01Notes-2025/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h2 id="2025-02-18-国运级与民营企业：从杭州刘小龙看中国国际竞争格局"><a href="#2025-02-18-国运级与民营企业：从杭州刘小龙看中国国际竞争格局" class="headerlink" title="2025/02/18 国运级与民营企业：从杭州刘小龙看中国国际竞争格局"></a>2025/02/18 国运级与民营企业：从杭州刘小龙看中国国际竞争格局</h2><h4 id="斯坦福大学与人口外流与硅谷的形成"><a href="#斯坦福大学与人口外流与硅谷的形成" class="headerlink" title="斯坦福大学与人口外流与硅谷的形成"></a>斯坦福大学与人口外流与硅谷的形成</h4><p>在基因上和硅谷比较像的城市<br>1.有很好的教育资源<br>2.需要急迫地解决人才外流的问题</p>
<h2 id="2025-02-25-德国大选出炉老对手终上位俄乌局势突变老欧洲该怎么办"><a href="#2025-02-25-德国大选出炉老对手终上位俄乌局势突变老欧洲该怎么办" class="headerlink" title="2025/02/25　德国大选出炉老对手终上位俄乌局势突变老欧洲该怎么办"></a>2025/02/25　德国大选出炉老对手终上位俄乌局势突变老欧洲该怎么办</h2><p>默克尔：德国应该已发展中小企业为主流。<br>如果中小企业出了问题，你可以把它卖掉，但是大公司出了问题，没人愿意买它的。</p>
<h2 id="2025-03-15"><a href="#2025-03-15" class="headerlink" title="2025/03/15"></a>2025/03/15</h2><p><strong>巴菲特指数</strong></p>
<p><strong>海湖庄园协议</strong>是特朗普为“让美国再次伟大”而提出的一揽子全球贸易、金融、安全体系重构计划。<br>美联储 黄金价格重估</p>
<p><strong>进口配额</strong></p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>笔记</category>
        <category>播客笔记</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>欧阳编曲网课笔记</title>
    <url>/BassHero.github.io/2025/03/15/musicarrangementtheroy/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>笔记</category>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>播客读书不成林笔记</title>
    <url>/BassHero.github.io/2025/03/13/podcast02Notes/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h2 id="自由"><a href="#自由" class="headerlink" title="自由"></a>自由</h2><h4 id="102-自由主义咋在赢了冷战后迅速变成了人人嫌的过街老鼠"><a href="#102-自由主义咋在赢了冷战后迅速变成了人人嫌的过街老鼠" class="headerlink" title="102-自由主义咋在赢了冷战后迅速变成了人人嫌的过街老鼠"></a>102-自由主义咋在赢了冷战后迅速变成了人人嫌的过街老鼠</h4><h2 id="关于文学"><a href="#关于文学" class="headerlink" title="关于文学"></a>关于文学</h2></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>笔记</category>
        <category>播客笔记</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>梵高笔记2024</title>
    <url>/BassHero.github.io/2025/03/13/podcast01Notes_2024/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<p>读书和上课并不是唯一一种学习的方式，有时候听别人指点反而是条捷径。<br>这是我听梵高moneytalk时学到的知识，让我这样的门外汉无痛地开始了解经济学知识。</p>
<p>这个播客很久就开始听了，里面的话题并不是每一个都能文字化作为笔记记录下来，仅仅作为一种生活记录希望记录下去。</p>
<h2 id="2023-12-14-基辛格的百年激荡的人生"><a href="#2023-12-14-基辛格的百年激荡的人生" class="headerlink" title="2023/12/14 基辛格的百年激荡的人生"></a>2023/12/14 基辛格的百年激荡的人生</h2><p><strong>宏观分析法</strong>是通过分析一些主要宏观经济指标的变动</p>
<table>
<thead>
<tr>
<th>周期名称</th>
<th>提出者</th>
<th>引起因素</th>
<th>周期长度</th>
</tr>
</thead>
<tbody><tr>
<td>基钦周期</td>
<td>英国统计学家基钦</td>
<td>企业库存投资的变动</td>
<td>3-4年</td>
</tr>
<tr>
<td>朱格拉周期</td>
<td>法国经学家朱拉格</td>
<td>固定投资波动</td>
<td>8-10年</td>
</tr>
<tr>
<td>库茨涅茨周期</td>
<td>美国经济学家西蒙库茨涅茨</td>
<td>建筑投资的循环变动</td>
<td>15-25年</td>
</tr>
<tr>
<td>康德拉季耶夫周期</td>
<td>前苏联经济学家康德拉季耶夫</td>
<td>技术进步和革新等</td>
<td>45-60年</td>
</tr>
</tbody></table>
<h2 id="2024-04-21-汇率跌指数涨"><a href="#2024-04-21-汇率跌指数涨" class="headerlink" title="2024/04/21　汇率跌指数涨"></a>2024/04/21　汇率跌指数涨</h2><p><strong>利率平价理论（Rate Parity）</strong><br>由凯恩斯和爱因齐格提出的远期汇率决定理论。</p>
<details>
<summary>相关阅读 实际应用与市场意义</summary>

<p><strong>1. 外汇市场定价</strong></p>
<ul>
<li><strong>远期汇率决定</strong>：银行根据CIRP计算远期汇率报价（例如：若美元利率高于欧元，则欧元远期汇率升水）。</li>
<li><strong>套利机会判断</strong>：若实际远期汇率偏离CIRP理论值，投资者可通过“抛补套利”锁定无风险利润。</li>
</ul>
<p><strong>2. 货币政策与汇率联动</strong></p>
<ul>
<li><strong>加息与货币升值</strong>：<br>若一国加息（且市场预期汇率不变），套利资金流入会导致本币即期升值，直至符合利率平价。</li>
<li><strong>预期汇率的作用</strong>：<br>非抛补利率平价强调市场预期对即期汇率的影响（例如：若预期本币贬值，需更高的利率吸引外资）。</li>
</ul>
<p><strong>3. 汇率预测</strong></p>
<ul>
<li><strong>利差交易（Carry Trade）</strong>：<br>投资者借入低利率货币（如日元），投资高利率货币（如澳元），前提是汇率波动不会抵消利差收益（违背UIRP）。</details></li>
</ul>
<details>
<summary>相关阅读 经典案例</summary>

<p><strong>六、经典案例</strong><br><strong>1. 日元套利交易（2000-2007年）</strong></p>
<ul>
<li><strong>背景</strong>：日本长期维持零利率，投资者借入日元兑换高息货币（如澳元、新西兰元）投资。</li>
<li><strong>结果</strong>：利差收益显著，但2008年金融危机导致高息货币暴跌，套利交易巨亏（UIRP失效）。</li>
</ul>
<p><strong>2. 欧元区负利率与汇率（2014-2020年）</strong></p>
<ul>
<li><strong>背景</strong>：欧元区实施负利率，但欧元未持续贬值（因避险需求抵消利差影响）。</li>
<li><strong>意义</strong>：说明非抛补利率平价在极端政策下的局限性。</details></li>
</ul>
<h2 id="2024-05-08-听说过没见过的金融危机：人性驱使下的过热和过缩"><a href="#2024-05-08-听说过没见过的金融危机：人性驱使下的过热和过缩" class="headerlink" title="2024/05/08 听说过没见过的金融危机：人性驱使下的过热和过缩"></a>2024/05/08 听说过没见过的金融危机：人性驱使下的过热和过缩</h2><h4 id="美国大选和CPI消费者价格指数"><a href="#美国大选和CPI消费者价格指数" class="headerlink" title="美国大选和CPI消费者价格指数"></a>美国大选和CPI消费者价格指数</h4><blockquote><p>通胀是有基期效应的。2023年的下半年，美联储对通胀的制约，在他自己的角度上来说他觉得自己制约住了。为什么说制约住了，因为当时CPI一路下降3.9，3.6，然后一点点往下降。<br>他为什么这样，因为是在2022年下半年，通胀非常的高，基期效应打到了2023年显得加息是很有效的。可是由于在2023年下半年他的整个CPI的幅度被他控制住了，那就反射到了2024年，由于基期效应，2024年下半年的CPI会继续抬头，这个时候鲍老师就是骑虎难下，他本来加息就加晚了，现在又碰上要大选，你说让他怎么干？我要是他的话我只能叹口气，要不继续加点吧？</p>
<footer><strong>高蕾</strong></footer></blockquote>
<h4 id="什么是金融危机"><a href="#什么是金融危机" class="headerlink" title="什么是金融危机"></a>什么是金融危机</h4><p>人类为什么会有金融危机，是因为有了工业革命。有了分工，有了各个国家不同的生产效率。一个生产效率特别高的国家可以用非常低廉的成本把商品卖到外国去。（<strong>倾销</strong>）<br>s</p>
<h4 id="倾销自重商主义"><a href="#倾销自重商主义" class="headerlink" title="倾销自重商主义"></a>倾销自重商主义</h4><blockquote><p>“德意志，我们在织你的尸布，<br>我们织进去三重的诅咒——<br>我们织，我们织！</p>
<footer><strong>德国诗人亨利希·海涅 《西里西亚的纺织工人》</strong></footer></blockquote>
<p>指1844年6月4—6日的西里西亚纺织工人的起义（这是德国无产阶级和资产阶级之间第一次大规模的阶级搏斗）和1844年6月下半月捷克工人的起义。</p>
<h4 id="刘易斯拐点"><a href="#刘易斯拐点" class="headerlink" title="刘易斯拐点"></a>刘易斯拐点</h4><p>一个低收入经济体现代部门（例如工业）的持续扩张，将最终耗尽来自农村的剩余劳动力，当拐点到来之时，除了涨工资，没有其他办法可以招到工人。<br>只能把产业不断地往外移，造成产业空心化。</p>
<h4 id="1974年贸易法第301条"><a href="#1974年贸易法第301条" class="headerlink" title="1974年贸易法第301条"></a>1974年贸易法第301条</h4><p>美国政府为平衡进出口贸易的顺逆差，透过美国国会立法授权美国总统实施保护措施，以避免国内产业遭受国外竞争压力影响，其方法包括对进口产品设定高关税、限定或减少进口配额等经济政策。</p>
<blockquote><p>如果世间的企业家都是工作狂的话，那么离金融危机就不远了，因为产能必定过剩。</p>
</blockquote>

<h4 id="电影《大空头》"><a href="#电影《大空头》" class="headerlink" title="电影《大空头》"></a>电影《大空头》</h4><h2 id="2024-05-20-金融危机长啥样？（下）"><a href="#2024-05-20-金融危机长啥样？（下）" class="headerlink" title="2024/05/20 金融危机长啥样？（下）"></a>2024/05/20 金融危机长啥样？（下）</h2><h3 id="资本项下兑换"><a href="#资本项下兑换" class="headerlink" title="资本项下兑换"></a>资本项下兑换</h3><p>资本项下是指国与国之间发生的资本流出与流入的全部过程。</p>
<blockquote><p>市场是在分歧中上涨。</p>
</blockquote>

<blockquote><p>金融是天生的不存在垄断的领域，因为金融技术是没有专利的。大家只有在创新的金融体系下才能把蛋糕做大。</p>
</blockquote>

<blockquote><p>JP摩根，银行家，投行家，知道价值规律是如何地发现，以一种客观的方式站在价值回归的本身。<br>他在两次金融衰退时担任了央行的角色。</p>
</blockquote>


<h2 id="2024-06-04-我叫你一声“中产阶级”，你敢答应吗？"><a href="#2024-06-04-我叫你一声“中产阶级”，你敢答应吗？" class="headerlink" title="2024/06/04 我叫你一声“中产阶级”，你敢答应吗？"></a>2024/06/04 我叫你一声“中产阶级”，你敢答应吗？</h2><blockquote><p>如果在一个社会里面，一个受过非常好的高等教育的年轻人都挣不到钱，那这个社会不是最终会走向反智的道路？</p>
</blockquote>

<h2 id="2024-08-18-经济视角解读孟加拉局势：耄耋史努斯被迎回，诺奖银行家是否会成为银行家"><a href="#2024-08-18-经济视角解读孟加拉局势：耄耋史努斯被迎回，诺奖银行家是否会成为银行家" class="headerlink" title="2024/08/18　经济视角解读孟加拉局势：耄耋史努斯被迎回，诺奖银行家是否会成为银行家"></a>2024/08/18　经济视角解读孟加拉局势：耄耋史努斯被迎回，诺奖银行家是否会成为银行家</h2><h4 id="经济自由主义"><a href="#经济自由主义" class="headerlink" title="经济自由主义"></a>经济自由主义</h4><p>最初，经济自由主义是用来对抗支持封建特权、贵族传统和君主为了他们本身利益而运转国家经济的人士，而这些到了19世纪末到20世纪初被大量废除。</p>
<p>19世纪中期，首位共和党的美国总统亚伯拉罕·林肯遵循辉格党的经济自由主义，包括增加国家控制如铁路的供给和管理。太平洋铁路法（Pacific Railway Acts）提供了第一条跨大陆铁路的发展依据。</p>
<h4 id="效用曲线"><a href="#效用曲线" class="headerlink" title="效用曲线"></a>效用曲线</h4><p>用于反映决策者对风险态度的一种曲线。又称偏好曲线。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>笔记</category>
        <category>播客笔记</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>メモリー</title>
    <url>/BassHero.github.io/2025/03/13/MemoryManagement/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>たまに復習しないと忘れる内容。</p>
<span id="more"></span>
<p><strong>静的領域</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;プログラム実行中にずっとｓ存在するデータを保持する領域です。<br>&nbsp;&nbsp;&nbsp;&nbsp;（グローバル変数やプログラム実行可能な形式に変換したコード情報）</p>
<p><strong>ヒープ領域</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;プログラム実行時に動的に確保する為のメモリー領域。<br>&nbsp;&nbsp;&nbsp;&nbsp;ＯＳや仮想マシンが管理機能を提供しています。<br>&nbsp;&nbsp;&nbsp;&nbsp;ガベージコレクション。<br>| ヒープ | オブジェクト指向・インスタンス生成 |<br>|—–|——————-|<br>|     | 動的メモリ確保、malloc    |<br>|     | ビッグデータ            |</p>
<p><strong>スタック領域</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;関数の呼び出しとローカル変数を管理するメモリー領域。<br>&nbsp;&nbsp;&nbsp;&nbsp;終了時メモリー解放。<br>| スタック | 関数の呼び出し |<br>|——|———|<br>|      | 再帰的     |<br>|      | ローカル変数  |</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>默克尔回忆录读书笔记（上）</title>
    <url>/BassHero.github.io/2025/03/13/ISBN978-6-267-50633-2_01/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>

<details>
<summary>
<b>相关阅读 希腊人民为什么在希腊债务危机中投票不脱离欧元</b>
</summary>

<p>在希腊债务危机期间，尽管面临严苛的紧缩政策和社会经济困境，希腊人民最终选择留在欧元区而非退出欧元，主要基于以下几方面原因：</p>
<h3 id="一、经济风险的现实考量"><a href="#一、经济风险的现实考量" class="headerlink" title="一、经济风险的现实考量"></a><strong>一、经济风险的现实考量</strong></h3><ol>
<li><strong>退出欧元的直接冲击</strong>：</li>
</ol>
<ul>
<li><strong>货币贬值与通胀失控</strong>：若恢复旧货币德拉克马（Drachma），预计汇率可能暴跌 **50%-80%**，导致进口商品价格飙升（如能源、药品），民众生活成本激增。</li>
<li><strong>银行体系崩溃</strong>：退出欧元将引发挤兑和资本外逃，银行系统流动性枯竭，储蓄可能被强制转换为贬值的本国货币，财富大幅缩水。</li>
</ul>
<ol start="2">
<li><strong>国际融资渠道断裂</strong>：</li>
</ol>
<ul>
<li>脱离欧元后，希腊将失去欧洲央行（ECB）的流动性支持，且国际投资者对其新货币缺乏信心，主权信用评级进一步下调，融资成本飙升。</li>
</ul>
<ol start="3">
<li><strong>贸易与投资长期受损</strong>：</li>
</ol>
<ul>
<li>货币贬值虽短期提升出口竞争力，但希腊经济依赖旅游业和服务业（占GDP **80%**），退出欧元可能引发游客信心下降，外资撤离。</li>
</ul>
<hr>
<h3 id="二、政治与制度依赖"><a href="#二、政治与制度依赖" class="headerlink" title="二、政治与制度依赖"></a><strong>二、政治与制度依赖</strong></h3><ol>
<li><strong>欧盟结构性支持</strong>：</li>
</ol>
<ul>
<li>留在欧元区意味着可继续获得欧洲稳定机制（ESM）和欧盟的救助贷款（总计约 <strong>2890亿欧元</strong>），避免国家财政完全崩溃。</li>
<li>欧洲央行通过量化宽松（QE）等工具间接缓解希腊债务压力。</li>
</ul>
<ol start="2">
<li><strong>避免政治孤立</strong>：</li>
</ol>
<ul>
<li>希腊作为欧盟创始成员国之一，退出欧元将削弱其在欧洲事务中的话语权，甚至可能被边缘化，失去区域合作与安全保障。</li>
</ul>
<ol start="3">
<li><strong>国内政治博弈</strong>：</li>
</ol>
<ul>
<li>2015年公投中，民众投票反对紧缩政策（“反对票”占 **61%**），但并非明确支持退出欧元。左翼政府Syriza最终妥协，接受救助条件以换取留欧。</li>
</ul>
<hr>
<h3 id="三、社会与心理因素"><a href="#三、社会与心理因素" class="headerlink" title="三、社会与心理因素"></a><strong>三、社会与心理因素</strong></h3><ol>
<li><strong>欧元的社会认同</strong>：</li>
</ol>
<ul>
<li>自2001年加入欧元区后，希腊民众已习惯欧元的稳定性和便利性。退出欧元被视为“倒退”，可能引发社会心理动荡。</li>
</ul>
<ol start="2">
<li><strong>对未知的恐惧</strong>：</li>
</ol>
<ul>
<li>历史教训（如阿根廷2001年脱离货币局制度后的经济崩溃）使民众对货币自主化改革持怀疑态度，宁愿忍受已知的紧缩而非未知的风险。</li>
</ul>
<hr>
<h3 id="四、国际压力与地缘战略"><a href="#四、国际压力与地缘战略" class="headerlink" title="四、国际压力与地缘战略"></a><strong>四、国际压力与地缘战略</strong></h3><ol>
<li><strong>欧盟的施压与承诺</strong>：</li>
</ol>
<ul>
<li>德国等核心欧元区国家坚决反对希腊退出（“Grexit”），担心连锁反应威胁欧元区完整。欧盟通过谈判让步（如延长还款期限）换取希腊留欧。</li>
</ul>
<ol start="2">
<li><strong>地缘政治考量</strong>：</li>
</ol>
<ul>
<li>希腊地处巴尔干半岛和东地中海，是欧盟与中东、北非的缓冲地带。欧盟担忧希腊退出后可能转向俄罗斯或中国，影响西方战略利益。</li>
</ul>
<hr>
<h3 id="五、退出成本与长期代价"><a href="#五、退出成本与长期代价" class="headerlink" title="五、退出成本与长期代价"></a><strong>五、退出成本与长期代价</strong></h3><ol>
<li><strong>法律与合同复杂性</strong>：</li>
</ol>
<ul>
<li>重新启用本国货币需修改宪法、重订国际合同（如以欧元计价的债务），引发长期法律纠纷。</li>
</ul>
<ol start="2">
<li><strong>长期经济复苏不确定性</strong>：</li>
</ol>
<ul>
<li>历史案例（如冰岛2008年危机后保留货币自主权）表明，小国脱离国际货币体系后的复苏依赖特定条件（如资源禀赋、产业弹性），而希腊缺乏此类优势。</li>
</ul>
</details>


<details>
<summary>
<b>相关阅读 巴黎俱乐部（Paris Club）</b>
</summary>

<p>巴黎俱乐部是一个由 <strong>主权债权国</strong> 组成的非正式多边论坛，成立于 <strong>1956年</strong>，旨在通过协商解决债务国无法偿还官方债务（政府间贷款）的问题。其本质是债务国与主要债权国之间的 <strong>债务重组谈判平台</strong>。</p>
<p><strong>1. 成员组成</strong></p>
<ul>
<li><strong>核心债权国</strong>：22个永久成员国，包括美国、日本、德国、法国等发达国家（俄罗斯于2022年被暂停资格）。</li>
<li><strong>观察员</strong>：国际机构（如IMF、世界银行）和新兴债权国（如中国、印度）偶尔受邀参与。</li>
</ul>
<p><strong>2. 主要职能</strong></p>
<ul>
<li><strong>债务重组</strong>：重新安排债务国的还款期限、利率或减免部分债务。</li>
<li><strong>债务减免</strong>：针对最不发达国家（如“重债穷国倡议”，HIPC）。</li>
<li><strong>协调立场</strong>：确保债权国采取一致行动，避免“搭便车”问题。</li>
</ul>
<p><strong>3. 运作流程</strong></p>
<ol>
<li><strong>债务国申请</strong>：债务国因外汇短缺无法偿债时，向巴黎俱乐部提出援助请求。</li>
<li><strong>IMF评估</strong>：债务国需先与IMF达成经济改革协议，证明偿债意愿。</li>
<li><strong>谈判协商</strong>：债权国与债务国协商具体重组条款（如延长还款期、部分减免）。</li>
<li><strong>签署协议</strong>：达成“条款协议”（Agreed Minute），各债权国据此调整双边债务。</li>
</ol>
<p><strong>4. 典型案例</strong></p>
<ul>
<li><strong>拉美债务危机（1980年代）</strong>：重组墨西哥、巴西等国债务。</li>
<li><strong>伊拉克战后债务（2004年）</strong>：减免伊拉克80%的债务（约330亿美元）。</li>
<li><strong>新冠疫情应对（2020年）</strong>：暂停73个低收入国家的债务偿还（DSSI倡议）。</li>
</ul>
<p><strong>5. 局限性</strong></p>
<ul>
<li><strong>非正式性</strong>：无法律约束力，依赖成员自愿执行。</li>
<li><strong>新兴债权国缺位</strong>：中国等非成员国持有大量发展中国家债务（如“一带一路”项目），但未纳入传统重组框架。</li>
<li><strong>私人债务覆盖不足</strong>：仅处理政府间债务，私人债权需另行谈判。</li>
</ul>
</details>


<details>
<summary>
<b>相关阅读 如何在2008年希腊危机发生时，计算出需要延长的债务总额</b>
</summary>

<p>欧洲机构和成员国在评估债务援助规模时，主要基于以下因素：</p>
<ol>
<li><strong>到期债务规模</strong>：统计未来12-24个月内需偿还的<strong>主权债务本金和利息</strong>。</li>
</ol>
<ul>
<li>例如，希腊2010年需偿还约540亿欧元到期债务。</li>
</ul>
<ol start="2">
<li><strong>财政赤字缺口</strong>：政府年度预算赤字与通过市场融资的能力之间的差额。</li>
</ol>
<ul>
<li>希腊2010年财政赤字占GDP的10.6%，需外部资金填补。</li>
</ul>
<ol start="3">
<li><strong>银行体系流动性需求</strong>：银行系统因资本外流或挤兑所需的紧急支持。</li>
<li><strong>市场信心丧失后的融资成本</strong>：当一国失去市场融资能力时，需外部援助覆盖其全部融资需求。</li>
</ol>
<hr>
<h3 id="具体国家的债务压力（2010年5月）"><a href="#具体国家的债务压力（2010年5月）" class="headerlink" title="具体国家的债务压力（2010年5月）"></a><strong>具体国家的债务压力（2010年5月）</strong></h3><p><strong>1. 希腊</strong></p>
<ul>
<li><strong>到期债务（2010年）</strong>：约540亿欧元。</li>
<li><strong>财政赤字</strong>：2009年赤字占GDP的15.1%，2010年需外部资金填补赤字及债务展期。</li>
<li><strong>救助方案</strong>：2010年5月欧盟与IMF提供1100亿欧元（覆盖2010-2012年融资需求）。</li>
</ul>
<p><strong>2. 葡萄牙、西班牙、意大利</strong></p>
<ul>
<li><strong>2010年尚未正式申请救助</strong>，但市场已开始担忧：</li>
<li><strong>葡萄牙</strong>：2010年公共债务占GDP约93%，2011年4月申请780亿欧元救助。</li>
<li><strong>西班牙</strong>：债务占GDP较低（2010年约60%），但银行业风险高（2012年申请银行业救助）。</li>
<li><strong>意大利</strong>：债务占GDP约119%（2010年），但融资成本尚未失控（2011年下半年危机加剧）。</li>
</ul>
<hr>
<h3 id="争议与后续发展"><a href="#争议与后续发展" class="headerlink" title="争议与后续发展"></a><strong>争议与后续发展</strong></h3><ul>
<li><strong>低估风险</strong>：2010年的救助计划未充分预见到希腊债务的不可持续性（债务占GDP在2012年升至170%），最终需2012年债务减记。</li>
<li><strong>多米诺骨牌效应</strong>：希腊危机加剧了市场对其他南欧国家的恐慌，导致2011-2012年葡萄牙、爱尔兰、西班牙、塞浦路斯相继申请救助。</li>
<li><strong>德国的矛盾</strong>：Weidmann后来作为德国央行行长，批评欧洲央行的“直接货币交易（OMT）”政策，认为其模糊了财政与货币政策的界限。</details></li>
</ul>
<details>
<summary>
<b>相关阅读 什么是欧洲公共债务</b>
</summary>

<p><strong>欧洲公共债务</strong>（European Public Debt）是指欧洲国家政府为弥补财政赤字或资助公共项目而发行的债务总和。它是衡量一个国家或地区财政健康状况的重要指标，通常以<strong>债务占GDP的百分比</strong>来表示。以下是关于欧洲公共债务的详细说明：</p>
<hr>
<h3 id="1-公共债务的构成"><a href="#1-公共债务的构成" class="headerlink" title="1. 公共债务的构成"></a><strong>1. 公共债务的构成</strong></h3><ul>
<li><strong>政府债券</strong>：国家或地方政府发行的长期或短期债券（如德国国债、法国国债）。</li>
<li><strong>国际借款</strong>：从国际金融机构（如IMF、世界银行）或其他国家获得的贷款。</li>
<li><strong>社会保障债务</strong>：部分国家将养老金等社会保障负债纳入公共债务统计。</li>
</ul>
<hr>
<h3 id="2-欧洲公共债务的特点"><a href="#2-欧洲公共债务的特点" class="headerlink" title="2. 欧洲公共债务的特点"></a><strong>2. 欧洲公共债务的特点</strong></h3><h4 id="（1）欧元区的债务规则"><a href="#（1）欧元区的债务规则" class="headerlink" title="（1）欧元区的债务规则"></a><strong>（1）欧元区的债务规则</strong></h4><ul>
<li><strong>《稳定与增长公约》</strong>（Stability and Growth Pact, SGP）规定：</li>
<li>成员国公共债务不得超过GDP的60%。</li>
<li>年度财政赤字不得超过GDP的3%。</li>
<li><strong>例外情况</strong>：如经济危机或特殊事件（如新冠疫情、能源危机），规则可能放宽。</li>
</ul>
<h4 id="（2）债务水平的差异"><a href="#（2）债务水平的差异" class="headerlink" title="（2）债务水平的差异"></a><strong>（2）债务水平的差异</strong></h4><ul>
<li><strong>高债务国</strong>：希腊、意大利、葡萄牙等南欧国家债务率较高（超过GDP的100%）。</li>
<li><strong>低债务国</strong>：德国、荷兰等北欧国家债务率较低（低于GDP的60%）。</li>
</ul>
<h4 id="（3）共同债务工具"><a href="#（3）共同债务工具" class="headerlink" title="（3）共同债务工具"></a><strong>（3）共同债务工具</strong></h4><ul>
<li><strong>欧洲稳定机制（ESM）</strong>：为欧元区国家提供金融援助的常设机构。</li>
<li><strong>新冠复苏基金（Next Generation EU）</strong>：欧盟首次发行共同债券，用于疫情后的经济复苏。</li>
</ul>
<hr>
<h3 id="3-欧洲公共债务的挑战"><a href="#3-欧洲公共债务的挑战" class="headerlink" title="3. 欧洲公共债务的挑战"></a><strong>3. 欧洲公共债务的挑战</strong></h3><h4 id="（1）主权债务危机"><a href="#（1）主权债务危机" class="headerlink" title="（1）主权债务危机"></a><strong>（1）主权债务危机</strong></h4><ul>
<li><strong>2009年希腊债务危机</strong>：暴露了欧元区财政政策的分散性与结构性缺陷。</li>
<li><strong>连锁反应</strong>：危机蔓延至爱尔兰、葡萄牙、西班牙等国，威胁欧元区稳定。</li>
</ul>
<h4 id="（2）高债务与经济增长的矛盾"><a href="#（2）高债务与经济增长的矛盾" class="headerlink" title="（2）高债务与经济增长的矛盾"></a><strong>（2）高债务与经济增长的矛盾</strong></h4><ul>
<li>高债务国面临更高的借贷成本，可能挤占公共投资，抑制经济增长。</li>
<li>债务可持续性问题：部分国家债务率持续上升，可能引发市场信心危机。</li>
</ul>
<h4 id="（3）货币政策与财政政策的协调"><a href="#（3）货币政策与财政政策的协调" class="headerlink" title="（3）货币政策与财政政策的协调"></a><strong>（3）货币政策与财政政策的协调</strong></h4><ul>
<li>欧洲央行（ECB）通过量化宽松（QE）等措施购买成员国债券，缓解债务压力，但长期可能引发通胀风险。</li>
</ul>
<hr>
<h3 id="4-欧洲公共债务的管理"><a href="#4-欧洲公共债务的管理" class="headerlink" title="4. 欧洲公共债务的管理"></a><strong>4. 欧洲公共债务的管理</strong></h3><h4 id="（1）财政紧缩政策"><a href="#（1）财政紧缩政策" class="headerlink" title="（1）财政紧缩政策"></a><strong>（1）财政紧缩政策</strong></h4><ul>
<li>高债务国通过削减开支、增加税收来降低赤字（如希腊、意大利）。</li>
<li><strong>争议</strong>：紧缩政策可能导致经济衰退和社会不满。</li>
</ul>
<h4 id="（2）结构性改革"><a href="#（2）结构性改革" class="headerlink" title="（2）结构性改革"></a><strong>（2）结构性改革</strong></h4><ul>
<li>提高经济竞争力（如劳动力市场改革、税收改革）。</li>
<li>促进经济增长以降低债务率。</li>
</ul>
<h4 id="（3）欧盟层面的协调"><a href="#（3）欧盟层面的协调" class="headerlink" title="（3）欧盟层面的协调"></a><strong>（3）欧盟层面的协调</strong></h4><ul>
<li><strong>财政联盟</strong>：推动更紧密的财政一体化，如共同预算和税收政策。</li>
<li><strong>银行业联盟</strong>：通过统一监管和存款保险机制，降低金融风险。</li>
</ul>
</details></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>笔记</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>2025</tag>
      </tags>
  </entry>
  <entry>
    <title>《大众文化与文化理论》(2)</title>
    <url>/BassHero.github.io/2022/03/31/ISBN978-7-309-05840-6_02/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="第六章-结构主义与后结构主义"><a href="#第六章-结构主义与后结构主义" class="headerlink" title="第六章 结构主义与后结构主义"></a>第六章 结构主义与后结构主义</h2><p>在对结构主义文化理论展开讨论之前，有必要先对索绪尔的语言学著作做一介绍，并引入对于理解结构主义而言至关重要的一系列关键概念。<br></p>
<span id="more"></span>

<h3 id="费尔迪南·德·索绪尔"><a href="#费尔迪南·德·索绪尔" class="headerlink" title="费尔迪南·德·索绪尔"></a>费尔迪南·德·索绪尔</h3><p>索绪尔认为语言是由两个部分组成的。当我写下英文单词“cat”的时候，我既在纸上制造出了“cat”这个词的形状，又在头脑中勾勒出了一个“猫”的概念或图像：长着四条腿的猫科动物。索绪尔将前者（字词）称为*<em>“能指”（signifier）</em>，将后者（概念）称为<em>“所指”（signified）</em>。能指和所指是密不可分的（就像硬币或纸张的正反两面），共同构成了“符号”（sign）。<br></p>
<p>结构主义者认为我们对现实的感知是被语言建构出来的，不同的语言会勾画出不同的现实地图。<br></p>
<p>索绪尔对结构主义的发展做出的另一重要贡献是他对<em>语言 （langue）</em>和<em>言语 （parole）</em>的区分。<br></p>
<p>索绪尔还对语言学的两种研究路径做出了划分：<em>历时性（diachronic）</em>方法分析既定语言的历史变迁，而<em>共时性（synchronic）</em>方法对某一特定历史时期的语言加以考察。索绪尔指出，若想建立一门“语言科学”，就必须采用共时性的研究路径。因此，可以说，结构主义的文化研究方法通常是一种共时性的方法。结构主义者普遍认为，若要对文本与实践做出充分的阐释，只需重点关注它们的结构特征即可。这就不可避免地引发了种种争议——其他流派的理论家对结构主义的批评主要集中于其非<em>历史（ahistorical）</em>的视角。【119】</p>
<h3 id="克劳德·列维-斯特劳斯、威尔·赖特与美国的西部电影"><a href="#克劳德·列维-斯特劳斯、威尔·赖特与美国的西部电影" class="headerlink" title="克劳德·列维-斯特劳斯、威尔·赖特与美国的西部电影"></a>克劳德·列维-斯特劳斯、威尔·赖特与美国的西部电影</h3><p><em>克劳德·列维-斯特劳斯</em>利用索绪尔的理论来发掘所谓“原始”社会文化的*<em>“无意识基础”</em>（Lévi-Strauss, 1968: 18）。他将烹饪、礼仪、服饰、审美活动以及其他文化与社会实践当作语言来进行研究，指出每项实践都是一种独特的传播途径与表达形式。<br></p>
<p>列维-斯特劳斯声称，一切神话都具有相似的结构，而且都对社会发挥着类似的社会文化功能。尽管这并不是他的首要观点，但给文化研究带来了重要启发。神话之所以存在，就是为了让世界变得易于理解，用神秘的力量化解社会中的种种冲突与问题，即如列维-斯特劳斯所指出的那样：“神话思想对于站在自己对立面的事物总是保持警觉并采取行动……其作用就在于提供一个合理的模型，消弭社会中的矛盾”（224, 229）。于是，神话故事就成了一种文化，这种文化使冲突销声匿迹，让世界变得易懂而宜居，进而也就在人类与其自身、与其存在之间营造了和平的氛围。<br></p>
<p>威尔·赖特在<em>《六把枪与社会》（Sixguns and Society ）</em>一书中应用列维-斯特劳斯的结构主义方法来分析好莱坞出产的西部影片。他指出，西部片的绝大多数叙事能量（narrative power）源自影片自身的二元对立结构。然而，与列维-斯特劳斯不同，赖特关注的问题“并非如何揭示影片的精神结构，而在于探寻社会神话是如何通过自身的结构向社会成员传播某种观念或秩序的”（Wright, 1975: 17）。简言之，列维-斯特劳斯最关心的是人类心灵的结构，而赖特将注意力集中于西部片怎样“用简单的符号来传达深奥的含义，进而将美国人的社会信仰概念化”（23）。他指出，西部片总共经历了三个发展阶段，分别是“经典时期”（其中包括一个被他称为“复仇片”的变种）、“过渡主题时期”和“专业化时期”。尽管每个时期出品的影片类型彼此相异，但在其背后均潜藏着一系列基本二元对立结构（参见表6.2）。赖特坚持认为，若想完全理解一则神话的社会意义，不但要分析二元对立结构，还要分析神话自身的叙事结构，即“事件的进展与冲突的化解”（24）。而这正是赖特超越列维-斯特劳斯之处。<br></p>
<p>每一种影片类型都接合了各自的神话形式，通过不同的方式展示了美国梦 的实现过程：<br></p>
<p>古典的剧情告诉人们：若想赢得友情、尊敬和荣誉，就必须使自己卓尔不群，以独立的姿态用自身的力量去帮助他人……而复仇片淡化了个体与社会之间的兼容性，这类影片往往表明，要想受人尊敬、被人爱慕，一方面必须挺身而出，以一己之力对抗众多强大的敌人，另一方面则要时刻提醒自己，不要背弃包括婚姻和谦逊在内的温和的价值观。“过渡主题”西部片呼唤新的社会价值观，声称若想拥有爱情和友情，必须付出代价，那就是将自己从社会中驱逐出去，坚定地站在正义的立场上，与社会的褊狭无知做无畏的斗争。最后，专业化西部片的情节……告诉我们，要想获得人们的支持和尊重，需将自己培养成身怀绝技的技术人员，跻身专业精英人士之列，任劳任怨且只忠于团队，与一切负面的社会及社区价值观划清界限（186-187）。【123】<br><br></p>
<h3 id="罗兰·巴尔特：《神话学》"><a href="#罗兰·巴尔特：《神话学》" class="headerlink" title="罗兰·巴尔特：《神话学》"></a>罗兰·巴尔特：《神话学》</h3><p><em>《神话学》（Mythologies ）</em>一书就以法国的大众文化为考察的对象。在这部著作中，巴尔特对诸多文化形态进行了讨论，包括角斗、肥皂粉与清洁剂、玩具、牛排与薯片、旅游，以及公众对科学的态度，等等。其主要原则就是质疑日常生活中的种种“虚假的显见”（the falsely obvious）（Barthes, 1973: 11），将隐藏于大众文化之文本与实践中的意涵揭示出来。巴尔特怀有政治意图，他抨击的目标就是所谓的“中产阶级规范”（9）。他在1957年版《神话学》的前言中写道：“我讨厌看见人们将自然和历史搞得混乱不堪，我要将那些隐而未言之物（what-goes-without-saying）统统展示在人们面前，戳穿意识形态侮辱世人的假面”（11）。《神话学》是将<em>符号学（semiology）</em>  方法应用于大众文化分析的最重要的著作，而首位阐释符号学的潜在价值的学者是索绪尔：<br></p>
<p>语言是一个用符号来表达观念的系统，因此语言与书写、手语、象征性仪式、礼节规范以及军事信号等系统都具有可比性……于是，我们可以设想一种专门研究社会中符号的存在的科学……我称之为“符号学”（Saussure, 1974: 16）。<br></p>
<p>巴尔特指出，为人们所消费的神话是在次级指意系统或内涵的层面上被生产出来的。在他看来，神话就是包含了一整套观念与实践的意识形态，其功能在于积极推行统治阶级的利益与价值观，维护既存的社会权力结构。若想深入理解巴尔特的上述观点，需首先认清符号的多义性（polysemic）特征，即一个符号具有指向多重意义的潜能。<br></p>
<p>人们会应用哪种代码对文本做出解读，取决于三个要素：文本所在的场所、读者所处的历史时期与读者的文化背景。<br></p>
<p>还有第四种解读立场，那就是巴尔特自己的立场——神话学家的立场。这种解读立场可以形成巴尔特所谓之“结构性描述”（structural description），深掘影像中包孕的意识形态意义，揭示神话将历史转化为自然的过程。巴尔特指出：“是符号学使我们了解到神话的历史意向，及其妄图将政治观念自然化的野心。在当下，这一过程指的就是中产阶级的意识形态”（同上）。在巴尔特眼中，“神话是在历史质地（historical quality）丧失的过程中被建构出来的；在神话中，事物全然失去了自己曾经是‘人造之物’的记忆”（同上）。他以*<em>“去政治化的演讲”（depoliticized speech）</em>来描述。<br></p>
<h3 id="后结构主义"><a href="#后结构主义" class="headerlink" title="后结构主义"></a>后结构主义</h3><p><em>后结构主义（post-structuralism）</em>认为意义的背后并不存在任何牢不可破的潜在结构。意义始终处于生成的过程之中，而绝无固定的落脚处；我们眼中的文本的“意义”只是永无止境的阐释链上的一个转瞬即逝的停顿。<br></p>
<p>巴尔特已经从结构主义者转变为后结构主义者，他在<em>《作者之死》（“The Death of the Author”）</em>一文中指出：文本“乃是一个多维空间，而各种各样的非原创性书写（writings）就在其内交相混杂、此消彼长。文本仿若一张写满引语的棉纸，从不计其数的文化中心汲取着成分”（Barthes, 1977c: 146）。只有解读者才能暂时将一个文本统为整体。与图书馆架子上和书店里的那些结构完备的著作不同，文本“只能在生产行为中被人们体验”（157）。也就是说，文本与读者做出各种解读行为的过程是密不可分的。<br></p>
<h3 id="雅克·德里达"><a href="#雅克·德里达" class="headerlink" title="雅克·德里达"></a>雅克·德里达</h3><p>在德里达看来，对于结构主义而言至关重要的“二元对立”并非简单的结构性关系，而是一种权力关系，是将一种宰制性的词语体系凌驾于其他词语体系之上。而这种“凌驾性”（或者说优先性、特权性）并非在符号与符号的关系中“自然而然”地生成的，而是在关系的建构过程中被生产出来的。<br></p>
<p>我们绝不能“仅仅调和对立双方的矛盾……个别词语控制了其他词语……占据着至高无上的地位。要想将二元对立彻底解构，我们必须颠覆整个等级制（hierarchy）”（1978b: 41）。与其接受教科部广告的“双重欺骗性”，不如对其进行“解构式”阅读，以此来摧毁二元对立结构，揭露支撑着这一结构的乃是特定“暴力”的真相；而这种暴力，其实是关于性别与性取向的一系列可疑的假设。【133】<br></p>
<h3 id="话语与权力：米歇尔·福柯"><a href="#话语与权力：米歇尔·福柯" class="headerlink" title="话语与权力：米歇尔·福柯"></a>话语与权力：米歇尔·福柯</h3><p>米歇尔·福柯关注的首要问题是知识与权力之间的关系，及其对话语（discourse）与话语构型（discursive formation）的操纵。福柯提出的“话语”的概念与阿尔都塞的“问题域”非常相似——两者都表示为人们所组织且本身也具有组织性的知识体；这些知识中包含着相应的法则与规范，在日常生活中支配着人们的特定实践（人的思维方式和行为方式）。<br></p>
<p>话语通过三种途径发挥作用，分别是赋权、限制和建构。福柯指出，话语乃是“系统地形构了人类言谈对象的实践”（Foucault, 1989: 49）。<br></p>
<p>“权力生产了知识……两者关系密切，相互依存……若离开了对相关知识领域的建构，权力关系将不复存在……所有的知识都在生成的过程中预示并建构了权力关系”（1979: 27）。<br></p>
<p>话语的存在并非仅仅意味着权力的强加。诚如福柯所言：“有权力的地方就有抵抗”（2009: <br></p>
<h3 id="全景敞视机制"><a href="#全景敞视机制" class="headerlink" title="全景敞视机制"></a>全景敞视机制</h3><p>在福柯看来：</p>
<p>全景敞视监狱的主要作用在于使置身其内的人自己意识到监视的无所不在，从而主动规范自己的行为，确保权力机制的自动运行……哪怕实际的监视行为只是断断续续进行的，也不妨碍在人们的观念中始终存在着监视的效果。一个完美的权力机制无须时时刻刻采取实际行动……置身于权力语境之内的成员会自觉遵守权力的规范……当一个人清楚地知道自己的一举一动都会暴露在别人的视线之下时，权力的限制性职责就开始发挥作用了，因为这个人会通过自我约束的方式将权力关系深深镌刻于内心深处。在上述权力关系中，人扮演着双重角色——既是控制者，又是被控制的对象（Foucault, 1979: 201, 202-203）。【137】<br></p>
<h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>Storey, John (ed.), Cultural Theory and Popular Culture: A Reader , 4th edition, Harlow: Pearson Education, 2009.该书是本书的配套阅读材料，其中收录了本书所涉之大多数重要文献。本书及其配套读本得到了互动式网站<a href="http://www.pearsoned.co.uk/storey%E7%9A%84%E6%94%AF%E6%8C%81%E3%80%82%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86%E8%AE%B8%E5%A4%9A%E6%9C%89%E7%94%A8%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%94%B5%E5%AD%90%E8%B5%84%E6%BA%90%E3%80%82%E3%80%90139%E3%80%91">www.pearsoned.co.uk/storey的支持。该网站中包含了许多有用的链接与电子资源。【139】</a></p>
<p>During, Simon, Foucault and Literature: Towards a Genealogy of Writing , London: Routledge, 1992.尽管本书主要关注文学，但其对福柯的介绍非常详尽。</p>
<p>Eagleton, Terry, Literary Theory: An Introduction , Oxford: Basil Blackwell, 1983.本书的“后结构主义”一章非常精彩。</p>
<p>Easthope, Antony, British Post-Structuralism , London: Routledge, 1988.作者试图为整个英国后结构主义领域勾勒地图，其中关于电影理论、文化研究、解构和历史研究的章节很有价值。</p>
<p>Hawkes, Terence, Structuralism and Semiotics , London: Methuen, 1977.一本关于结构主义和符号学的导论性著作，很有价值。</p>
<p>McNay, Lois, Foucault: A Critical Introduction , Cambridge: Polity Press, 1994.本书对福柯的理论进行了精彩的介绍。</p>
<p>Norris, Christopher, Derrida , London: Fontana, 1987.本书对德里达进行了清晰且趣味盎然的介绍。</p>
<p>Sarup, Madan, An Introductory Guide to Post-Structuralism and Postmodernism , 2nd edn, Harlow: Prentice Hall, 1993.本书对后结构主义进行了精彩的介绍。</p>
<p>Sheridan, Alan, Michel Foucault: The Will to Truth , London: Tavistock, 1980.本书是迄今为止关于福柯的可读性最强的著作。</p>
<p>Silverman, Kaja, The Subject of Semiotics , Oxford: Oxford University Press, 1983.本书对结构主义、符号学、精神分析、女性主义和后结构主义的讨论既有趣又易懂，其中对于巴尔特的介绍尤其有价值。</p>
<p>Sturrock, John (ed.), Structuralism and Since: From Lévi-Strauss to Derrida , Oxford: Oxford University Press, 1979.该文集收录了不少关于列维-斯特劳斯、巴尔特、福柯和德里达的介绍性文章。</p>
<p>Twaites, Tony, Lloyd Davis and Mules Warwick, Tools for Cultural Studies: An Introduction , Melbourne: Macmillan, 1994.本书阐述了符号学在文化研究中的地位，富有启发性。</p>
<p>Weedon, Chris, Feminist Practice and Poststructuralist Theory , Oxford: Basil Blackwell, 1987.本书从女性主义视角出发，对后结构主义做出了有趣的评介，尤其是就福柯进行了有益的讨论。</p>
<h2 id="第七章-性别与性取向"><a href="#第七章-性别与性取向" class="headerlink" title="第七章 性别与性取向"></a>第七章 性别与性取向</h2><h3 id="女性主义"><a href="#女性主义" class="headerlink" title="女性主义"></a>女性主义</h3><p>女性主义至少包括四个截然不同的流派，分别是激进女性主义、马克思主义女性主义、自由主义女性主义，以及西尔维娅·沃尔比（Sylvia Walby）（1990）所言之“双重系统理论”（dual-systems theory）。每一流派都从特定的角度揭示女性所受之社会压迫，并根据不同的原因提出相应的解决方案。激进女性主义认为造成女性受压迫地位的首恶是父权制，在这一社会系统内，男性群体得以将自己的权力凌驾于女性群体之上。马克思主义女性主义则将矛头指向资本主义，认为男性统治女性只不过是资本统治劳动力的结果。自由主义女性主义与前两者的不同之处在于其未将问题归咎于任何制度——父权制或资本主义制度，而倾向于在具体形式中探讨男性对女性的偏见，如在法律制度或日常表达中有意无意地将女性排除于特定生活领域之外，等等。“双重系统理论”则体现了激进女性主义和马克思主义女性主义的融合，指出女性所受压迫乃是父权制和资本主义互相勾结的产物。当然，女性主义流派不止上述四种，罗丝玛丽·佟恩（Rosemary Tong）（1992）就曾罗列出下述七种：自由主义、马克思主义、激进主义、精神分析、社会主义、存在主义以及后现代主义。<br></p>
<p>拉娜·莱考（Lana Rakow）发表过类似的观点：“在分析大众文化时，女性主义者往往从各自不同的理论立场出发，关注社会层面的深度剖析并带有明确的政治意图”（Rakow, 2009: 195）。此外，莱考还指出：<br></p>
<p>尽管当代女性主义理论家对大众文化的观点不尽相同，但她们共同持有两个主要假设：第一，在与大众文化的关系问题上，女性和男性截然不同……第二，女性若要掌控自己的身份、改变旧有的社会意识形态和社会关系，就必须充分理解大众文化在女性文化和父权制文化领域内所发挥的不同作用……女性主义者声称大众文化在父权制社会内扮演了重要角色，只有对这一角色进行深入剖析才能确保自身在讨论的持续进行中站稳立场（186）。<br></p>
<h3 id="电影中的女性形象"><a href="#电影中的女性形象" class="headerlink" title="电影中的女性形象"></a>电影中的女性形象</h3><p>墨维认为取代大众电影的应当是一种先锋性质的电影，此类电影“带有激进的政治色彩和美学意蕴，并对主流电影的基本假设构成挑战”（Mulvey, 1975: 7-8）。而包括洛琳·加曼（Lorraine Gamman）和玛格丽特·马什门特（Margaret Marshment）在内的女性主义理论家对墨维观点的“普适性”（Gamman and Marshment, 1988: 5）提出了质疑，反问“凝视是否总是男性的”，以及这种凝视“是否仅仅是‘宰制性’的”（同上）。毕竟，观看的方式多种多样，其中自然也应包括女性的凝视。二人坚持认为：【142】<br></p>
<p>仅仅将大众文化视为资本主义和父权制社会的辅助系统是不够的。大众文化并非只是向愚蠢的群氓兜售“虚假意识”的工具，它还是对意义展开争夺的和对宰制性意识形态进行破坏的场所（1）。<br></p>
<p>鉴于此，她们主张采取一种干预性的文化政治理念：“我们绝不能以‘事不关己’的姿态拒斥大众文化”（2）。<br></p>
<p>斯戴西将她们对电影的反应区分为三种话语类型，分别是<em>逃避现实 （escapism）</em>、<em>身份认同 （identification）</em>和<em>消费主义 （consumption）</em>。<br></p>
<h3 id="解读言情小说"><a href="#解读言情小说" class="headerlink" title="解读言情小说"></a>解读言情小说</h3><p>在《仇恋》（Loving with a Vengeance ）一书中，塔尼娅·莫德莱斯基（Tania Modleski）指出，那些撰写“女性叙事”的女性往往倾向于采取下列三种立场中的一种：“轻蔑、主要针对叙事文学的消费者的敌视，以及最为常见的无礼的嘲弄”（Modleski, 1982: 14）。为与之对抗，她声称：“是时候对女性阅读进行女性主义解读了”（34）。所谓“大众化生产的女性幻景”（包括言情小说）“体现着女性生活中种种真实的问题与张力”（14），而对于“现代女性主义者”而言，这些通过叙事来解决问题、缓和冲突的方式“绝难取得成功”（25）。不过，言情小说的读者和女性主义读者的确存有共同之处，那就是她们都对女性生活的现状心存不满。<br></p>
<p>詹妮丝·莱德威（Janice Radway）在其研究的一开始就指出言情小说之所以广受欢迎，在一定程度上是由于“图书的生产、发行、广告及市场策略发生了重大改变”（Radway, 1987: 13）。她对前人的论述提出质疑，指出言情小说的商业成功一方面当然是由于女性的阅读需求日益增长，另一方面也源于出版商日臻娴熟的推销技巧，两者具有同等重要性。<br></p>
<p>莱德威在“史密斯顿” （Smithton）展开了自己的调查研究，在史密斯顿女性的心目中，理想的言情小说情节应当是这样的：一位独立且富幽默感的知识女性，在经历了种种怀疑、猜忌，乃至残忍、暴力之后，终于被一个男子的爱情征服；在恋爱过程中，该男子由轻率粗鄙而日渐成熟，直至成长为一个关心 女性、甘愿供养 女性的好男人——这也正是传统意义上女性对男性的期许。莱德威如是解释：“浪漫幻景……并非关于发现一位格外有趣的生活伴侣的幻想，而是一种期望被关怀、被热爱、被肯定的特殊仪式”（83）。这是一种“回报式”幻想：男人对女人施予关注与爱护，而女人亦应投桃报李。不过，言情小说带来的幻景远不止这些。通过阅读这些小说，女性读者会忆起往昔的幸福时光，重返被“母性”之爱包容的年代。<br></p>
<p>莱德威援引南茜·乔多罗（Nancy Chodorow）（1978），指出言情小说营造的幻景是一种形式独特的回归，让读者在想象上和情感上重返“自己仍是被某位供养者所关注的焦点”的年代（84）。不过，这种回归并非如考沃德所言是以父亲为中心，而是以母亲为中心的。<br></p>
<p>莱德威还沿用了乔多罗对“自我”的界定，认为女性自我是一种时刻处于和他者关系之中的自我，而男性自我是独立而自洽的自我。乔多罗曾指出，男性自我与女性自我的不同源于两者与母亲的关系不同，而莱德威在乔多罗所言之心理学因素与理想言情小说的叙事类型之间建立了关联：在从身份危机到身份重建的旅程中，“女主角最终成功建立起理想化的叙事……建立起我们都熟悉的女性自我，即与他人关系中的自我”（139）。此外，莱德威还赞同乔多罗的另一观点，认为女性只要在俄狄浦斯情结中浮现，便立即身陷某种“牢固的三角形心理结构”，这意味着女性“既需与异性打交道，又要持续不断地以母性身份与供养及保护自己的人维系紧密的情感联系”（140）。为了体验这种母性情感完满的回归，女性有三种选择：同性恋、与男人建立两性关系，以及通过其他方式获取满足。我们文化的恐同性（homophobia）特征制约着第一种选择，男性气质制约着第二种，而阅读言情小说隶属于第三种选择。莱德威指出：<br></p>
<p>言情小说营造的幻景一方面来自渴望爱与被爱的俄狄浦斯情结，另一方面源于持续不断的前俄狄浦斯情结，该情结是女性内客体构成（inner-object configuration）的一部分，具体体现为期望重获母亲之爱，以及与之相关的一系列暗示——色欲带来的快感、共生的圆满，以及身份的确证（146）。<br></p>
<p>理想的言情小说为上述三角形结构提供了完美的解决方案：“父亲式的保护、母亲式的关怀，以及激情洋溢的成人之爱”（149）。<br></p>
<h3 id="《观看〈豪门恩怨〉》"><a href="#《观看〈豪门恩怨〉》" class="headerlink" title="《观看〈豪门恩怨〉》"></a>《观看〈豪门恩怨〉》</h3><h3 id="解读女性杂志"><a href="#解读女性杂志" class="headerlink" title="解读女性杂志"></a>解读女性杂志</h3><p>约克·赫米斯（Joke Hermes）的《解读女性杂志》（Reading Women‘s Magazines ）一书以对前辈女性主义学者所做之女性杂志研究的综述开篇。“我始终有种强烈的感觉，即女性主义的抗争应当以赢得尊敬为最终目标。或许正因如此，前人所做的绝大多数女性杂志研究都令我感觉极不舒服。这些研究仅仅表达了对女性杂志读者的‘关注’而非‘尊敬’”（Hermes, 1995: 1）。</p>
<h3 id="后女性主义"><a href="#后女性主义" class="headerlink" title="后女性主义"></a>后女性主义</h3><p>后女性主义（post-feminism）是一个复杂的概念，它既可被用于描述女性主义的一个分支，也可以指女性主义内部的一种理论立场，还可以代表当代大众文化的一种趋势。</p>
<p>将女性主义纳入后女性主义大众文化是霸权的一种典型的运作方式。除此之外，我们也可将这一过程视为一种马尔库塞所强调的“单向度生产”机制（参见第四章对这两种观点的讨论）。</p>
<h3 id="男性研究与男性气质"><a href="#男性研究与男性气质" class="headerlink" title="男性研究与男性气质"></a>男性研究与男性气质</h3><p>肖恩·尼克森（Sean Nixon）持有与伊索普相似的视角，指出“新男性”气质仿若某种“表征的政体”（regime of representation）。他将自己的分析聚焦于“文化流通的四个关键场所：电视广告、报刊广告、男装商场与男性杂志”（4）。</p>
<p>尽管女性主义者时常鼓励男人检视自身的男性气质，但甚少有人对男性研究产生兴趣。诚如乔伊丝·卡南（Joyce Canaan）和克莉丝汀·格里芬（Christine Griffin）所指明的那样：</p>
<p>毫无疑问，通过获知男人对于父权制如何被建构和转化为两性关系的宰制性系统的理解，女性主义者可以极大地拓宽自己的视野。但是，我们也担心女性对男性和男性气质的体验会因男性研究的存在而遭到歪曲、藐视乃至否定。因此，随着越来越多的男人投身于可与女性主义“分庭抗礼”的研究之中，女性主义者必须更加坚定地将男性和男性气质研究进行下去（Canaan and Griffin, 1990: 207-208）。【167】</p>
<h3 id="酷儿理论"><a href="#酷儿理论" class="headerlink" title="酷儿理论"></a>酷儿理论</h3><p>若想对“自然而然的”性别和异性恋霸权的虚构意识形态展开讨论，最佳方式莫过于从酷儿理论的奠基之著——茱迪丝·巴特勒（Judith Butler）那部影响深远的《性别麻烦》（Gender Trouble ）——入手。</p>
<p>巴特勒以“扮装” （drag）喻指性别操演的模式，进而对其机制做出解释，其原因并非如某些批评家所揣测的那样是由于“‘扮装’是颠覆性别的范例”（xxii），而是因为“‘扮装’过程使指意的模式戏剧化，进而确立了‘性别’自身”（xxviii）。经由“扮装”过程，社会性别的异性恋规范所维护的表面统一性和虚构连贯性得以昭示天下。诚如巴特勒所言：“在模拟性别的过程中，‘扮装’于不知不觉间揭示出性别自身的模拟式结构，同时展露了性别归属的偶然性”（175）。扮装并非对“原始”或“自然”性别身份的复制，而是对“原初性神话（myth of originality）本身的模拟” （176）。如她所言：</p>
<p>假如性别划分……并不是表达性（expressive）而是操演性（performative）的，那么此种划分行为与其说是揭露了性别身份，不如说是建构了性别身份。“表达”和“操演”之间存在天壤之别。如果说与性别相关的属性和行为——人类身体展现或生产文化意义的种种方式——全系“操演出来”的话，那便意味着根本不存在什么先天的性别身份，对性别属性与行为的衡量更是无从谈起，无谓真假，无谓曲直，而所谓“真正的”性别身份只不过是一系列虚构出来的行为规范。关于性别的一切“事实”都是在“社会表演”（social performance）中被“创造”出来的，无论“原初”的生理性别还是本真且永恒的两性气质都只不过是悲剧一场，一面掩盖着性别操演机制的本来面目，一面压抑着“另类”性别操演对异性恋意识形态的男性气质霸权的反抗（180）。 </p>
<p>“酷儿式”解读既非替代性解读、有意为之的误读，亦非“过度解读”。此种解读中蕴含的“反常性”纵然错综复杂，却时时刻刻存在于大众文化的文本与受众之中；而“酷儿”的使命，即是对上述“反常性”展开充分的认识与接合（83-84）。</p>
<h3 id="拓展阅读-1"><a href="#拓展阅读-1" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>Storey, John (ed.), Cultural Theory and Popular Culture: A Reader , 4th edition, Harlow: Pearson Education, 2009.该书是本书的配套阅读材料，其中收录了本书所涉之大多数重要文献。本书及其配套读本得到了互动式网站<a href="http://www.pearsoned.co.uk/storey%E7%9A%84%E6%94%AF%E6%8C%81%E3%80%82%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86%E8%AE%B8%E5%A4%9A%E6%9C%89%E7%94%A8%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%94%B5%E5%AD%90%E8%B5%84%E6%BA%90%E3%80%82%E3%80%90173%E3%80%91">www.pearsoned.co.uk/storey的支持。该网站中包含了许多有用的链接与电子资源。【173】</a></p>
<p>Ang, Ien, Living Room Wars: Rethinking Media Audiences for a Postmodern World , London: Routledge, 1995.该领域内顶级学者洪美恩的论文集，十分精彩。</p>
<p>Barrett, Michèle, Women‘s Oppression Today: Problems in Marxist Feminist Analysis , London: Verson, 1980.本书的作者试图将马克思主义与女性主义的分析方法结合起来，为大众文化研究者提供了有用的参考。其第三章“意识形态与性别的文化产品”尤其有价值。</p>
<p>Brunt, Rosalind and Caroline Rowan (eds), Feminism, Culture and Politics , London: Lawrence &amp; Wishart, 1982.本书收录了一系列关于女性主义分析模式的论文。请重点阅读《女性主义与文化政治的定义》一文。</p>
<p>Burston, Paul and Colin Richardson (eds), A Queer Romance: Lesbians, Gay Men and Popular Culture , London: Routledge, 1995.本书是一部有趣的论文集。其收录的文章大多从酷儿理论的视角来看待大众文化问题。</p>
<p>Creekmur, Corey K.and Alexander Doty (eds), Out in Culture: Gay, Lesbian, and Queer Essays on Popular Culture , London: Cassell, 1995.本书是一部出色的论文集，站在“反恐同”和“反异性恋中心主义”的立场考察当代大众文化。</p>
<p>Easthope, Antony, What a Man‘s Gotta Do: The Masculine Myth in Popular Culture , London: Paladin, 1986.本书对男性气质在当代大众文化中的表征机制做出了一番有益且趣味盎然的论述。【174】</p>
<p>Franklin, Sarah, Celia Lury and Jackie Stacey (eds), Off Centre: Feminism and Cultural Studies , London: HarperCollins, 1991.本书收录了若干以女性主义理论从事文化研究的学者的论文。</p>
<p>Geraghty, Christine, Women and Soap Opera: A Study of Prime Time Soaps , Cambridge: Polity Press, 1991.本书对关于肥皂剧的女性主义分析做出了全面的介绍。</p>
<p>Jeffords, Susan, The Remasculinization of America: Gender and the Vietnam War , Bloomington and Indianapolis: Indiana University Press, 1989.本书对一系列大众文本中的男性气质表征进行考察，揭示了越南战争失利之后的美国文化如何走上困难重重的“重拾男子气”之路。</p>
<p>Macdonald, Myra, Representing Women: Myths of Femininity in Popular Media , London: Edward Arnold, 1995.本书论述了女性在大众传媒的言谈和视像中被建构的过程。</p>
<p>McRobbie, Angela, Feminism and Youth Culture , London: Macmillan, 1991.本书的作者是女性主义大众文化研究领域内的佼佼者。本书收录了她的若干重要论文。</p>
<p>Pribram, Deidre E.(ed.), Female Spectators: Looking at Film and Television , London: Verso, 1988.本书收录了一系列文章，从不同的视角对电影及电视大众文化进行考察。</p>
<p>Thornham, Sue, Passionate Detachments: An Introduction to Feminist Film Theory , London: Edward Arnold, 1997.关于女性主义对电影研究做出的贡献，本书进行了精彩的介绍。</p>
<h2 id="第八章-“种族”、种族主义与表征"><a href="#第八章-“种族”、种族主义与表征" class="headerlink" title="第八章 “种族”、种族主义与表征"></a>第八章 “种族”、种族主义与表征</h2><h3 id="“种族”与种族主义"><a href="#“种族”与种族主义" class="headerlink" title="“种族”与种族主义"></a>“种族”与种族主义</h3><p>斯图亚特·霍尔指出，在西方社会的历史上，“种族”概念的发展经历了三个关键时刻（Hall, 1997c），分别是奴隶制与奴隶贸易、殖民主义与帝国主义，以及伴随着20世纪50年代去殖民化的移民浪潮。</p>
<p>尽管种族主义以纯粹政治力所不及的能量塑造着人类的意识形态与行为方式，但我们仍需坚持不懈地将“种族”和种族主义现象置于社会与政治的框架之内加以评析（xx）。【177】</p>
<h3 id="种族主义意识形态的历史渊源"><a href="#种族主义意识形态的历史渊源" class="headerlink" title="种族主义意识形态的历史渊源"></a>种族主义意识形态的历史渊源</h3><p>源于<em>无知</em>与<em>恐惧</em>的*<em>“仇外情绪”（xenophobia）</em>由来已久，仿佛从不同族裔开始共存的那天起便始终存在。而“种族”和种族主义的历史，是极为特殊的。在英国，种族主义最早是为维护奴隶制与奴隶贸易的合法性而出现的。彼得·弗莱尔（Peter Fryer）指出：“当英国的奴隶贸易、英国的种植园奴隶制和英国的制造业三者开始联手追逐高额利润，那些古老的神话碎片与人种偏见便有了强悍的经济基础，逐渐转化为一套牢固的种族主义意识形态，也就是一系列关于种族的神话”（Fryer, 1984: 134）。换言之，种族主义起初是一种防御性意识形态，其传播意图在于维护奴隶制与奴隶贸易所带来的经济利益。</p>
<h3 id="东方主义"><a href="#东方主义" class="headerlink" title="东方主义"></a>东方主义</h3><p>爱德华·萨义德的《东方主义》（Orientalism ）是后殖民理论的奠基之著。在这部著作中，他深入考察了西方世界利用一种东方的话语来建构关于东方的“知识”的过程，探索相应而生的“权力—知识”体系如何在西方强权的利益中得到接合。在萨义德看来，“‘东方’完全是被欧洲人发明出来的”（Said, 1985: 1）。他用“东方主义”  这个表述来形容欧洲与东方的关系，尤其是“东方如何在影像、观念、性格和经验领域将欧洲（西方）界定为自己的对立面”（1-2）。此外，他还“竭力展现欧洲文化如何将自己乔扮成东方代理人，乃至东方的潜在自我，并从中获得力量与身份”（3）。</p>
<p>在讨论及分析东方主义时，可将其视为“处理”东方问题的某种组织机制（corporate institution），其具体方式包括：制造对东方的叙述、赋予某些关于东方的观点以权威性、描绘东方、教授东方的知识、对东方进行殖民、统治东方，等等。简言之，东方主义就是西方对东方加以宰制和重构，进而凌驾于东方之上的一种方式（同上）。</p>
<p>作为“虚构意识形态系统”（321）的东方主义其实与权力问题密切相关，是西方维系对东方霸权的诸多机制之一。在一定程度上，这种霸权是通过强调西方与东方的“绝对差异”而实现的：“西方……理性、发达且优秀，而东方……古怪、落后而贫瘠”（300）。</p>
<p>小说《黑暗之心》（Heart of Darkness ）和电影《现代启示录》（Apocalypse Now ）中的人物库尔茨（Kurtz）就属于这种类型。第二类故事则强调拥有“种族优越性”的白人对丛林及丛林栖息者的利用与征服。小说、电影和神话故事中常常出现的角色“人猿泰山”（Tarzan）是此类结构最典型的代表。在东方主义的视角下，上述两种叙事结构均包孕着帝国主义文化的欲望和焦虑，而不仅仅是对其他种族和异域土地的征服。</p>
<p>很多以越战为题材的好莱坞电影都可被视为东方主义叙事的经典案例。</p>
<p>福柯关于权力问题的一般观点也适用于解释好莱坞的话语权：</p>
<p>我们必须从现在开始停止用种种消极的语汇来描述权力效应；“排斥”“抑制”“掩饰”“隐瞒”等，这些表述应统统摒弃。事实上，权力是一种生产性的力量，它生产了现实，生产了客体领域，也生产了关于真理的种种仪式（Foucault, 1979: 194）。</p>
<p>此外，福柯还指出：“每个社会都有其独特的‘真理政体’和‘一般政治理念’；换言之，某些特定类型的话语为人们所广泛接受并发挥了真理的作用”（2002a: 131）。</p>
<ol>
<li>第一种叙事范式可以概括为“作为背叛的战争”（the war as betrayal）。</li>
<li>第二种叙事范式可被归纳为“黑白颠倒综合征”（the inverted firepower syndrome）。</li>
<li>第三种叙事范式是“战争的美国化”（the Americanization of the war）。这一表述的意味是：在好莱坞越战影片（当然还有其他美国文化产品）中，越南战争已经演变成一个纯粹的美国现象，与越南无关——我们可称之为“帝国式自恋”（imperial narcissism）。因此种情结作祟，美国成了世界的中心，越南和越南人民只不过作为美国悲剧的语境而存在，而越南人的粗蛮最终导致了美国式纯真的迷失。</li>
</ol>
<p>布什的演讲内容多数大同小异，折射出20世纪80年代美国主流话语对越战意义的解读：“越南战争是一个崇高的理想，却遭到了背叛，最后竟变成美国的悲剧。”例如，为了遏制越南综合征对美国政治的影响，罗纳德·里根（Ronald Reagan）在1980年的总统竞选中公开声称：“从今以后，我们应深刻地认识到越南战争是一个崇高的理想”（转引自John Carlos Rowe and Rick Berg, 1991: 10）。此外，他还坚称：“让我们告诉那些参加过战争的人：假若我们的政府害怕赢得战争，就绝不该将成批的有为青年推到战场上送死”（转引自Stephen Vlastos, 1991: 69）。1982年（最后一批美军撤离越南约10年之后），越战将士纪念碑在华盛顿揭幕，里根发现美国人“开始认识到越战的合理性了”（转引自Barbie Zelizer, 1995: 220）。1984年（最后一批美军撤离越南11年之后），越战无名英雄纪念碑正式奠基。在奠基仪式上，里根宣称：“一位美国英雄终于回到了祖国的怀抱……他接受了任务并完成了使命，其忠贞爱国的精神时刻感召着我们”（转引自Rowe and Berg, 1991: 10）。1985年（最后一批美军撤离越南12年之后），纽约举办了主题为“欢迎回家”的盛大游行，欢迎越战老兵。上述政治修辞行为和全民缅怀活动表明某种关于越战意义的新“共识”正在形成。这一过程从1980年里根在总统选举中大获全胜开始，至1991年布什在海湾战争中大获全胜而宣告完成。正因如此，布什才会在为战争做动员时号召美国人牢记越南战争——因为彼时的美国人已经将“作为勇气与背叛之战”的越南战争成功地内化为自己的“经验”，而好莱坞的越战影片于其中扮演了关键角色——它们通过排演、详述、阐释和重叙等方式为美国民众提供翔实的资料，最终建构了主流话语对越南战争的记忆与理解。【186】</p>
<p>不客气地说，美国在越南战场上投入的军事火力是人类社会有史以来强度最大的一次。在好莱坞的叙事中，我们决然看不到美军对越南广大区域展开的计划周密的袭击，看不到汽油弹轰炸和地毯式搜寻，更看不到对停火区的利用以及大规模炸弹空袭。在1972年的“圣诞炮轰”（Christmas Bombing）战役中，美国“向河内（Hanoi）与海防 （Haiphong）投掷的炸弹比德国在1940—1945年间向英国投掷的还要多”（Franklin, 1993: 79）。另据统计，在越战期间，美军向越南国土投掷炸弹的总数大约是整个第二次世界大战中投掷炸弹总数的3倍（Pilger, 1990）。</p>
<p>玛丽塔·斯特尔肯（Marita Sturken）观察到：“一些越战老兵声称完全不记得自己对战争的记忆究竟是从哪里来的。是亲身经历、纪实照片，还是好莱坞电影？”（Sturken, 1997: 20）例如，一位名叫威廉·亚当斯（William Adams）的越战老兵就曾发表过如下言论：</p>
<p>《野战排》上映之后，很多人跑来问我：“越南战争真的像电影里演的那样吗？”我始终不知该如何回答。一方面，或许因为无论多么栩栩如生、多么惟妙惟肖，电影终究只是电影，而真正的战争是不可再现的；而另一方面，在我的脑海中，关于战争的“真实”情况早已与人们对战争的谈论纠缠在一起，不再是纯粹的记忆。这真是一件怪事。在某些方面看来，这又令我十分痛苦。不过，我们的记忆机制也借此得到了检验。越南战争不再是一个确定的事件，而仿若一部流动的集体剧本，我们对自身的时而自相矛盾、时而变幻莫测的看法便于其中遭到随意的涂写、删减与篡改（转引自Sturken, 1997: 86）。</p>
<p>克拉克还痛心地指出：“越战记忆一度是对帝国主义野心的抗拒，而今却成了让帝国主义卷土重来的催化剂”（206）。</p>
<h3 id="白人性"><a href="#白人性" class="headerlink" title="白人性"></a>白人性</h3><p>简言之，“白色”只不过是表面上“自然”与“正常”而已。除非在广泛意义上将白色视为一种普通的种族特征，否则情况就不会有什么改变。</p>
<p>“白人性”的合法性依据并非仅仅来自社会阶级和性别（以及其他标识社会差异的标准）等维度。即使在“白人性”这个概念内部，也存在着观念的分野——在不同的历史时期，对于哪些人有资格被“划归”白人这个问题，往往有着截然不同的答案。</p>
<h3 id="反种族主义与文化研究"><a href="#反种族主义与文化研究" class="headerlink" title="反种族主义与文化研究"></a>反种族主义与文化研究</h3><p>两段引文分别来自斯图亚特·霍尔和保罗·吉尔罗伊。</p>
<p>文化研究的使命即在于将种种精神资源调动起来，帮助我们理解生活的构成与所处的社会，理解因差异的存在而显得极度惨无人道的世界。幸运的是，文化研究不仅是学者与知识分子的领地，而且是广大人民群众的武器……种族问题始终困扰着我们的世界，对此视而不见的知识分子绝不值得尊敬，对此漠然置之的学术机构也决然无法昂首挺胸踏入21世纪。对此，我深信不疑（Hall, 1996e: 343）。【189】</p>
<p>社会的差异性日益显著，个体的焦虑感与日俱增，我们究竟该以何种姿态面对人们对陌生事物的恐惧与敌视，又该借由什么方式迎接相应而生的种种挑战？我们需弄清楚衡量相似性与差异性的标准是否已经发生有益的转变，进而淡化了人与人之间的疏离感，强化了人们对亲缘性的认识与重视。此外，还应明白，对20世纪种族迫害史的亲历可以让我们深刻理解“他者”的遭遇与痛楚，进而在普遍人性的基础上缔建和平……总而言之，人与人之间的共同之处远远多于相异之处，我们有能力进行对话、互相尊重。如果我们不想再犯错误，就必须在普遍人性的规范下约束自己的行为（Gilroy, 2004: 3-4）。</p>
<h3 id="拓展阅读-2"><a href="#拓展阅读-2" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>Storey, John (ed.), Cultural Theory and Popular Culture: A Reader , 4th edition, Harlow: Pearson Education, 2009.该书是本书的配套阅读材料，其中收录了本书所涉之大多数重要文献。本书及其配套读本得到了互动式网站<a href="http://www.pearsoned.co.uk/storey%E7%9A%84%E6%94%AF%E6%8C%81%E3%80%82%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86%E8%AE%B8%E5%A4%9A%E6%9C%89%E7%94%A8%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%94%B5%E5%AD%90%E8%B5%84%E6%BA%90%E3%80%82%E3%80%90190%E3%80%91">www.pearsoned.co.uk/storey的支持。该网站中包含了许多有用的链接与电子资源。【190】</a></p>
<p>Baker, Houston A.Jr, Manthia Diawara and Ruth H.Lindeborg (eds), Black British Cultural Studies: A Reader , Chicago: University of Chicago Press, 1996.一部很有趣的论文集。</p>
<p>Dent, Gina (ed.), Black Popular Culture , Seattle: Bay Press, 1992.一部非常有用的论文集。</p>
<p>Dittmar, Linda and Gene Michaud (eds), From Hanoi to Hollywood: The Vietnam War in American Film , New Brunswick and London: Rutgers University Press, 1990.本书是关于好莱坞越战影片的最出色的论文集。</p>
<p>Dyer, Richard, White: Essays on Race and Culture, London: Routledge, 1997.关于白人性和文化的经典论著。</p>
<p>Fryer, Peter, Staying Power: The History of Black People in Britain , London: Pluto, 1984.很精彩。【191】</p>
<p>Gandhi, Leela, Postcolonial Theory: A Critical Introduction , Edinburgh: Edingurgh University Press, 1998.一本优秀的后殖民主义概论性著作。</p>
<p>Gilroy, Paul, There Ain‘t No Black in the Union Jack , London: Routledge, 1987/2002.本书是对“种族”问题进行文化研究的经典之作。</p>
<p>Gilroy, Paul, The Black Atlantic , London: Verso, 1993.本书对“文化专制主义”做出了深刻的批判。</p>
<p>Markus, Hazel Rose and Paula M.L.Moya, Doing Race: 21 Essays for the 21st Century, New York: Norton, 2010.一本关于“做种族”的精彩论文集。</p>
<p>Pitcher, Ben, Consuming Race, London: Routledge, 2014.本书对“种族”在日常生活中扮演的角色展开了有趣的讨论。</p>
<p>Williams, Patrick and Laura Chrisman (eds), Colonial Discourse and Post-Colonial Theory: A Reader , Harlow: Prentice Hall, 1993.本书收录了若干关于后殖民理论的论文，值得关注。</p>
<h2 id="第九章-后现代主义"><a href="#第九章-后现代主义" class="headerlink" title="第九章 后现代主义"></a>第九章 后现代主义</h2><h3 id="后现代状况"><a href="#后现代状况" class="headerlink" title="后现代状况"></a>后现代状况</h3><p>室内装饰与建筑设计风格、电影叙事与唱片生产的构成、电视广告与文艺纪录片的“互文性”、时尚杂志与时政期刊的版面设计、反目的论的认识论倾向、对“在场的形而上学”的攻击、感觉的衰减、战后“婴儿潮一代” （baby boomers）面对中年危机时的病态与幻灭感、反思的“困境”、一系列修辞转喻、表层的增殖、商品拜物教的新阶段、对视觉影像的执迷、代码与风格、文化政治过程、存在主义的碎裂与危机、主体的“去中心化”、“对宏大叙事的质疑”、多元权力话语对单一权力轴心的取替、“意义的内爆”、文化阶层的崩溃、核武器的自我毁灭性对人类世界的威胁、大学的衰落、新式微型技术的功能与效果、“传媒社会”“消费社会”“跨国资本主义社会”“非地域”（placelessness）感的滋生与被摒弃（“批判性的地域主义”）、旧有时空坐标的改换——当上述领域都被贴上“后现代”的标签……“后现代主义”显然已经成为一句时髦的口号（Hebdige, 2009: 429）。【193】</p>
<p>后现代理论在英美两国的滥觞出现于20世纪50年代至60年代初期，是通过<em>让-弗朗索瓦·利奥塔（Jean-Franois Lyotard）</em>、<em>让·鲍德里亚（Jean Baudrillard）</em>与<em>弗雷德里克·詹明信</em>等学者的作品实现理论化的。在大众文化研究领域，我将举出流行音乐与电视作为后现代文化的案例加以讨论。在本章末尾，将对后现代主义的三个主要方面进行评述，分别是：</p>
<ol>
<li>绝对价值标准的崩溃</li>
<li>文化全球化</li>
<li>文化融合。</li>
</ol>
<h3 id="20世纪60年代的后现代主义"><a href="#20世纪60年代的后现代主义" class="headerlink" title="20世纪60年代的后现代主义"></a>20世纪60年代的后现代主义</h3><p>后现代主义哀叹于现代主义早已丧失社会批判的波希米亚式力量，无法像从前一般令粗鄙的中产阶级“既恨且怕”；那些曾在中产社会边缘角落奋起发力的文艺作品——如巴勃罗·毕加索（Pablo Picasso）、詹姆斯·乔伊斯（James Joyce）、艾略特（T.S.Eliot）、弗吉尼亚·伍尔夫（Virginia Woolf）、贝托尔特·布莱希特、伊戈尔·斯特拉文斯基（Igor Stravinsky）等人的作品——俨然已被奉为“经典”，其原初的震撼力与批判力早已消丧殆尽。换言之，现代主义文化已经蜕变为中产阶级文化，其颠覆性力量则被形形色色的学院与博物馆消弭。因此，当下的先锋文化应当将矛头对准现代主义，诚如詹明信所言：</p>
<p>这显然是解释后现代主义得以“横空出世”的最令人信服的理由，因为在20世纪60年代的年轻人眼中，一度站在“反抗者”立场上的现代主义俨然已成为僵死的“经典”。一如马克思（1977）在另一语境下所做的比喻：宛若生活的头脑中挥之不去的梦魇（Jameson, 1984: 56）。</p>
<p>对于大众文化研究者而言，后现代主义摒弃了“无论从历史角度看还是从人性角度看都已过时的马修·阿诺德的文化观”（Sontag, 1966: 299），其最重要的理念莫过于强调“‘高雅’文化与‘低俗’文化之间的界限正日益变得毫无意义”（302）。因此，后现代主义乃是一种旨在对抗现代主义的文化精英主义的思想观念。大众文化经常从现代主义中汲取成分，现代主义却始终对与大众有关的一切事物持深刻的怀疑态度，虽其始终自称与“俗不可耐的中产阶级”不共戴天，但毫无疑问，唯有诉求于阶级社会的精英主义文化观，现代主义才能“顺理成章”地“攻占”各大学院与博物馆。</p>
<p>在20世纪50年代和60年代，盛行于英美的波普艺术（pop art）体现出对“壁垒”的明确拒斥。波普艺术家鄙夷阿诺德将文化视为“世人所思、所表的最好之物”的观点（参见第二章），转而拥护威廉斯的“文化是全部生活方式”的社会定义（参见第三章）。在60年代早期的大萧条中，英国大众艺术家无不对美国心驰神往（美国被视为大众文化的发源地）。这场运动的第一位理论家劳伦斯·艾洛维（Lawrence Alloway）曾如是说：</p>
<p>我们感兴趣的是大众化生产的都市文化，包括电影、广告、科幻小说和流行音乐。我们感觉到大多数知识分子非但未曾对商业文化标准产生抵触情绪，反而能够坦然接受现实、讨论细节，并成为商业文化的狂热消费者。这场运动的一个成果即是将波普文化与“逃避现实”“纯粹娱乐”以及“消遣放松”剥离开来，进而赋予其艺术的严肃性（转引自Frith and Horne, 1987: 104）。</p>
<p>安迪·沃霍（Andy Warhol）是波普艺术理论化过程中的另一位关键人物。他声称，艺术只有在被受众接受的时候方能成为艺术：“沃霍将一摞子布瑞罗（Brillo）包装盒摆在博物馆里，并不意味着这些盒子就成了艺术品。然而，假若你在博物馆中看到这些时常在超市中见到的物什，你在下次逛超市的时候就会感觉自己是在经历一场艺术的冒险，于是你的生活得到了升华——这才是使盒子变成艺术品的关键过程。只要自愿，每个人都是艺术家”（120）。</p>
<p>而美国的反传统文化——反越战运动、黑人民权运动、反现代主义精英主义运动、第二波女性主义运动、同性恋解放运动、文化实验主义运动、迷幻摇滚运动以及“迷幻视角主义”（acid perspectivism）（Hebdige, 2009）——则成了“先锋主义传统的结束章”（Huyssen, 1986: 195）。</p>
<h3 id="让-弗朗索瓦·利奥塔"><a href="#让-弗朗索瓦·利奥塔" class="headerlink" title="让-弗朗索瓦·利奥塔"></a>让-弗朗索瓦·利奥塔</h3><p>让-弗朗索瓦·利奥塔对后现代主义最重要的理论贡献是其初版于1979年的《后现代状况》（The Postmodern Condition ）一书。</p>
<p>利奥塔认为，所谓的“后现代状况”指的是西方社会出现的一种知识地位的危机，具体体现为“对宏大叙事（metanarratives）的怀疑”以及“宏大叙事合法性机制的衰落”（Lyotard, 1984: xxiv）。</p>
<p>史蒂文·康纳（Steven Connor）认为，《后现代状况》可被视为“对学术知识与学术机构在当下世界中的状况的隐秘寓言”（Connor, 1989: 41）。在某种意义上，利奥塔“‘诊断’的并非所谓后现代状况，而是徒劳无益的当代知识分子”（同上）。在他看来，当代知识分子身上充满了“消极英雄主义”的色彩。“整个20世纪60年代对学术界的粗暴攻击和猛烈批评”导致知识分子丧失了原本的权威性（转引自Connor, 1989: 41）。</p>
<p>当文化领域吵嚷着要“改天换地”时，分散在非洲、加勒比地区和亚洲的人们的声音、实践与身份却从后帝国主义英国的边缘地带冉冉上升，试图对确凿无疑的“常识”和世所共知的“真理”进行重新定位，进而为这个暮气沉沉、群龙无首、“旧去新不来”（Gramsci, 1971）的历史时期找到观察世界、理解世界的新方法（Mercer, 1994: 2）。</p>
<h3 id="让·鲍德里亚"><a href="#让·鲍德里亚" class="headerlink" title="让·鲍德里亚"></a>让·鲍德里亚</h3><p>在《符号的政治经济学批判》（For a Critique of the Political Economy of the Sign ）一书中，鲍德里亚将此转化过程描述为“从冶金术（metallurgic）社会向符号创造术（semiurgic）社会的过渡”（Baudrillard, 1981: 185）。不过，在鲍德里亚看来，后现代主义与其说是简单的符号文化，不如说是一种关于“拟像”（simulacrum）的文化。【198】</p>
<p>所谓“拟像”，指的是与原本（original）一模一样的复制品，而原本自身并不存在。在第四章中我们对本雅明的观点进行了介绍,他认为机械复制技术的出现摧毁了艺术作品的“灵韵”；而鲍德里亚走得更远，直接宣称原本与复制品之间的界限早已不复存在——他将这一过程称为“仿真”（simulation）。我们可以举CD唱片与电影为例来对上述观点做出解释。例如，假若某人买了一张史蒂夫·厄尔（Steve Earle）的专辑CD《革命在即》（Revolution Starts Now ），你很难说这张“复制品”与“原本”有什么区别。</p>
<p>鲍德里亚称，仿真乃是“在真实或原本缺席的情况下对真实模型的衍生，是一种超级真实（hyperreality）”（Baudrillard, 1983: 2）；而这种“超级真实主义”（hyperrealism）是后现代性的典型运作机制。在超级真实的领域内，仿真与“真实”之间的界限毁于“内爆”（implosion），“真实界”与“想象界”也在相互作用之中不断坍塌。其结果便是：真实与仿真带给人们的体验别无二致，就像过山车一样绵延不绝，毫无差异。而且，仿真有时甚至比真实本身显得更加真实——“比实实在在的东西还棒”（U2）。</p>
<p>约翰·费斯克（John Fiske）的观点似乎给我们带来了一些启示。他认为，“后现代传媒”不再提供“关于现实的次级表征（secondary representation），而是在介入现实的过程中对现实进行着生产”（Fiske, 1994: xv）。</p>
<p>关于超级真实主义，鲍德里亚自己则举出了迪士尼乐园的例子。他将迪士尼乐园称为“纠结的仿真规则的完美范例”（Baudrillard, 1983: 23），并声称迪士尼乐园的成功之处并不在于为美国人提供了逃避现实的幻想，而是以难于察觉的方式使游览者经历了一个浓缩的“真实”的美国。【201】</p>
<p>迪士尼乐园之所以存在，就是为了掩饰其自身正是“真实的”美国的事实；而所谓“真实的”美国，其实就是迪士尼乐园（正如监狱之存在就是为了掩饰其自身就是整个社会一样，而陈腐不堪且无所不在的社会，其实就是监狱本身）。迪士尼乐园以虚构的面貌呈现在我们面前，其实意在使我们相信乐园之外的世界是真实的。可实际上，包裹着迪士尼乐园的洛杉矶乃至整个美国都已不再真实，早已变作“超级真实”与仿真的产物。对于现实的虚假表征（意识形态）早已不是问题，问题在于“真实”本身已然不再“真实”（25）。</p>
<p>鲍德里亚的分析支持了利奥塔关于后现代主义的观点，如确定性的崩溃，以及关于“真理”的宏大叙事的消解，等等。上帝、自然、科学、工人阶级等，均已丧失其作为确凿无疑的真理中心的权威性，再也无法成为个体安身立命的佐证。在鲍德里亚看来，<em>这并非意味着“真实”的坍塌，而是一个“真实”隐退至“超级真实”之中的过程</em>。他声称：“当‘真实’变得面目全非，‘怀旧’便肩负起表达‘真实’的使命。于是，起源神话与现实符号大量增殖……这些关于现实与指涉的衍生产品令人既恐慌又忧虑”（12-13）。上述过程构成了鲍德里亚所言之“第二次历史变迁”。在保罗·利科（Paul Ricoeur）看来，现代主义所处的时代乃是一个“怀疑的解释学”的时代，强调透过表面对深层事实的意义进行探索。马克思与弗洛伊德显然是现代主义思维方式的典范（参见第四章与第五章）；而“超级真实”将注意力集中于政治表征与文化表征的问题——假若在表面之下并不存在任何确凿无疑的“真实”，那么表征的有效性又体现在何处？例如，按照后现代的逻辑，“兰博”并非代表着 美国关于越南问题的一种思维方式，而根本就是 一种思维方式；表征并非与“事实”泾渭分明，更未对“真实”加以掩藏或扭曲，表征就是事实本身 。当然，在很多情况下，我们会认为由鲍德里亚的理论引发的思想革命将斗争的矛头对准了一切潜在的意义（意义的存在是一切意识形态分析的先决条件），不过，假如我们重新审视鲍德里亚关于迪士尼乐园和水门事件的相关论述，难道不也能发现其所做的工作只不过是一种更加复杂的意识形态分析，即发掘表面之下的“真相”吗？【202】</p>
<p>鲍德里亚的理论乃是一种典型的现代主义叙事——历史是线性的，衰亡过程是单向的。然而，20世纪早期的高级现代主义尚且梦想着通过先锋文艺与文化精英来保存旧文化的价值，以图在未来实现振兴，鲍德里亚却只为我们描绘了一幅行将就木且希望渺茫的世界图景。在他看来，事实如此，没什么道理可讲，因为“道理”本身便意味着理性仍然存在（Docker, 1994: 105）。</p>
<h3 id="弗雷德里克·詹明信"><a href="#弗雷德里克·詹明信" class="headerlink" title="弗雷德里克·詹明信"></a>弗雷德里克·詹明信</h3><p>弗雷德里克·詹明信是一位美国马克思主义文化批评家，曾撰写过大量关于后现代主义的著述，影响深远。他与其他理论家的不同之处在于其强调在马克思主义或新马克思主义的理论框架之内诠释后现代主义。</p>
<p>在詹明信看来，后现代主义绝不仅仅是一种独特的文化风格，而且是一个“分期概念”（Jameson,1985: 113）,是晚期资本主义或跨国资本主义的“文化统治”。这种观念来自欧内斯特·曼德尔（Ernest Mandel）对资本主义发展的三个阶段的划分：</p>
<ol>
<li>“市场资本主义”</li>
<li>“垄断资本主义”</li>
<li>“晚期或跨国资本主义”（Mandel, 1978）</li>
</ol>
<p>上述三个阶段“构成了……资本侵入非商品化领域的最纯粹的形式”（Jameson, 1984: 78）。詹明信以文化发展的三种类型——“现实主义”“现代主义”和“后现代主义”——来对应曼德尔提出的线性模式。此外，他还借用了威廉斯对既定文化形态的三种类型（“宰制性文化”“新兴文化”与“剩余文化”）（Williams, 1980）的区分。在威廉斯看来，人类社会从一个历史时期过渡到另一个历史时期并不意味着旧文化的必然崩溃和新文化的必然崛起，而往往只是改变原有文化之间的相互关系。因此，在既定文化形态之内，各种各样的文化完全可以共存，不过其中只有一种可以成为宰制性文化。正是基于这一思路，詹明信方提出后现代主义是晚期资本主义或跨国资本主义的“文化统治”的观点（现代主义是“剩余文化”，至于什么是“新兴文化”，尚未可知）。【203】</p>
<p>后现代文化并非一种质朴的原创性文化，而是一种引用的文化，意即后现代主义的文化产品是从以前的文化产品中生成的。 [2] 因此，后现代文化呈现出“平面化、无深度”的特征，“是一种新型的、名副其实的表面文章”（60）。基于影像和外表的后现代文化拒斥“深度”，其对自身的阐释力来自其他影像和其他外表，是在无穷无尽的互文（intertextuality）机制中完成的。在后现代的“混仿”世界里“绝无可能产生风格的革新，我们所见之一切都是对旧风格的模仿；文化在想象的博物馆中找寻风格，穿透面具并发出声音”（1985: 115）。</p>
<p>詹明信举出的最典型案例即是其所谓“怀旧影片”（nostalgia film）。这一类型涵盖了20世纪八九十年代的许多影片，如《回到未来》（Back to the Future ）系列、《佩姬·苏要出嫁》（Peggy Sue Got Married ）、《斗鱼》（Rumble Fish ）、《天使心》（Angel Heart ）和《蓝丝绒》（Blue Velvet ）等。在詹明信看来，这些怀旧气息浓郁的影片都旨在重现20世纪50年代美国的文化风格与社会氛围。他声称：“至少对于美国人来说，50年代始终是欲望迷失的主要时期——那个年代并不仅仅象征着美国治下的 和平、稳定与繁荣，而且包含反传统文化的原初动力，如早期摇滚乐与青年团体，等等”（1984: 67）。此外，詹明信还强调不可将怀旧影片与历史影片混为一谈，他将《星球大战》（Star Wars ）也归为“怀旧影片”便证明了这一点。在我们看来，一部描绘未来世界的科幻影片居然被贴上“怀旧”的标签，实在不可思议，但詹明信如是解释：“《星球大战》蕴含着某种怀旧的……隐喻……它并未直接描绘关于过去的总体性图景，却通过形构特有的艺术对象的感觉与形态，为我们营造出古老的、‘过去’的氛围”（1985: 116）。</p>
<p>后现代文化之所以尽失历史性，与詹明信所归纳的第二种风格特征密切相关，即“精神分裂症”（schizophrenia）。这一表述来自拉康（参见第五章），意指语言的失序与能指之间时态关系的错乱。在“精神分裂症”的作用下，时间并非不间断的连续体，而是一个周而复始的在场，只有在过去或某种未来的可能性的侵入之下，方可显现自身。人类失去了时间连续体中的自我的意义，却也同时得到了“奖赏”，即强化了关于“现时”的感受。詹明信如是说明：</p>
<p>请注意，尽管时间的连续性被打破，但我们对“现时”的体验变得更加强大、更富生机、更可感可触；在精神分裂症的作用下，世界的紧张感大大强化，承载着神秘且急迫的职责与影像，并因幻觉的能量而容光焕发。不过，那些我们更为期许的经验，如洞察力的增强、对刺激的渴望、改变现状的幻想、冲破藩篱的欲求，等等，便皆尽丧失了，因为它们都已变得“不真实”（1985: 120）。</p>
<p>之所以为后现代文化冠以“精神分裂症”之名，皆因其早已丧失了历史感（而且其未来感也迥异于现代感）。这种文化患上了“历史健忘症”，困身于永久在场且时断时续的细流之中。由是，现代主义的<strong>“时间”（temporal）文化*便让位给后现代主义的</strong>“空间”（spatial）文化*了。</p>
<p>吉姆·柯林斯（Jim Collins）在近年来的电影发展史中发现了一股类似的风潮，他称之为“新式范型”（Collins, 2009: 470），即电影创作者在自己的作品中有意识地“引用”、提及乃至“照搬”其他电影中的元素。柯林斯的观点比詹明信的观点更具说服力，原因在于其对“能动性”的强调。他声称，此类电影建构了一个*<em>“混搭爱好者”的受众群体</em>，这些受众从电影的混搭风格中获取了无穷的快感。</p>
<p>与其说昆汀·塔伦蒂诺的影片是“混仿”，不如说是“改写”或“重顾”，它们完全基于观影者的切身经验，在“更富流动性与多样性的历史语境下”对既定的“感觉结构”加以“激活”与“重构”（同上）。【205】</p>
<p>日常生活的彻底“文化化”（culturalization）与“美学化”（aestheticization）标志着后现代主义与此前的一切社会文化运动都截然不同。作为一种文化，后现代主义并未预留任何“评论的空间”，它声称什么“收编”“推举”都是毫无意义的概念，因为“收编”与“推举”赖以生存的批判空间早已不复存在。这无异于将法兰克福学派的悲观主义推向了极致（参见第四章）。对此，格罗斯伯格发表了简明扼要的批判性评论：</p>
<p>在詹明信看来……我们需要采用新的“地图”来帮助理解晚期资本主义的空间组织。可另一方面，广大受众始终处于被动与噤声的状态，依然扮演着被宰制性意识形态所欺瞒的“文化白痴”的角色。不仅如此，他们还心甘情愿地接受着批评家的领导，因为批评家是唯一有能力对意识形态进行解读并为抵抗行为架桥铺路的人。至多，大众得以成功表现出自己无力对批评家的领导权做出回应的样子。然而，假若没有了批评家，大众甚至连自己发出的绝望的呐喊都无法听见。大众是毫无希望的，且将持续毫无希望下去。或许直到某天，某人为他们提供了必需的“理解”的地图以及抵抗的批判模式，情况才会改变（Grossberg, 1988: 174）。</p>
<p>我们进入肯定性文化领域，消除疲劳、更新换代，以图继续千篇一律的日常生活。由是，“肯定性文化”创造了一种新的现实，“在文化内部营造出一种表面的统一与表面的自由，而种种异见与反抗则在‘安抚政策’之下噤声。总之，文化既维护又掩盖了社会生活的新状况”（96）。资本主义战胜封建主义之后的种种承诺，如社会平等、社会正义与社会进步等，都从日常生活世界退缩至“肯定性文化”的领域内。与马克思、恩格斯对宗教的看法类似，马尔库塞也指出：文化通过缓解存在之痛的方式使原本不堪忍受的情况变得可以忍受了：【207】</p>
<p>肯定性文化的一个最重要的社会使命即是化解难以容忍的恶劣状况与对幸福快乐的需求之间的冲突，其目的便是使“难以容忍”的状况变得可以忍受。在这种状况下，唯一的解决方式就是制造幻觉，即将艺术的美感以幻觉的方式精确地呈现在人们面前……不过，即便是幻觉，也仍然发挥着实际的功效，即在维持现状的前提下……生产出人们的满足感（118-124）。</p>
<p>对于那些在维持现状的前提下生产着满足感的文化，马克思主义者是绝对不惜将其送入坟墓的。不过，诚如詹明信所言，现代主义文化的毁灭真的会阻滞社会的社会主义转型吗？事实上，情况或许恰恰相反。</p>
<p>欧内斯托·拉克劳与尚塔尔·墨菲在一定程度上接受了詹明信对后现代主义的分析。他们与詹明信的不同之处，在于其认识到了行动者的重要性：</p>
<p>如今，个人并不仅仅以出卖劳动力的方式屈从于资本的统治，而且融入了许多其他的社会关系，如文化、业余时间、疾病、教育、性，乃至死亡。尽管无论个人经验还是集体生活都无法跳脱资本主义生产关系的束缚，但“消费社会”既不会如丹尼尔·贝尔（Daniel Bell）所言，导致意识形态的终结，也不会像马尔库塞所担心的那样，创造出“单向度的人”。恰恰相反，已经有不计其数的新型斗争对新型的压迫和剥削进行了抵抗，而这些抵抗大多来自新型社会的心脏部位（Laclau and Mouffe, 2001: 161）。</p>
<p>此外，拉克劳和墨菲还指出：“新的文化形态与大众传播的扩张有密切关联。大众传播……导致新兴大众文化的出现，进而极大地撼动了传统的深厚根基。不过，关于大众传播的效果也很难一言以蔽之，因其既带来了无可置疑的大众化与一致化，又蕴含着足以颠覆社会不平等的力量元素”（163）。尽管这并不意味着社会“物质”的分配已经变得更加平等，但是，</p>
<p>作为传媒发展所带来的必然结果，文化民主化（cultural democratization）包孕着对基于旧社会形态的种种特权的质疑。传媒将受众质询为平等的消费者，赋予其行动的能力，激励成千上万的群体奋起反抗持续存在的、真实的不平等现象。毫无疑问，此种“民主消费文化”促进了新斗争形式的诞生，鼓励人们反抗各种形式的剥削和压迫，而肇始于美国的黑人民权运动就是一个绝佳的案例。青年文化现象的崛起亦很耐人寻味，年轻人将毋庸置疑地在抵抗运动中扮演中流砥柱的角色。为获取新的生存必需品，他们被日益建构为一个特殊的消费人群；他们渴望并追寻经济上的自主权，而这一切是当下的社会所无法给予的（164）。【208】</p>
<h3 id="后现代流行音乐"><a href="#后现代流行音乐" class="headerlink" title="后现代流行音乐"></a>后现代流行音乐</h3><p>韦斯特明确反对詹明信的观点，拒绝将后现代流行音乐“贬视”为某种简单的“混仿”。说唱音乐的互文性特征及对其他文本的引用并不是美学枯竭的结果，支离破碎的现代主义与文艺衰亡之间也并不存在针锋相对的冲突。恰恰相反，后现代流行音乐将七零八落的碎片“撷录”在一起，并于满怀敌意的文化氛围中发出了振聋发聩的呐喊：反抗歧视，坚决斗争。</p>
<h3 id="后现代电视"><a href="#后现代电视" class="headerlink" title="后现代电视"></a>后现代电视</h3><p>柯林斯对《双峰镇》进行案例分析，对后现代主义与电视之间的关系的各种理论假说进行了综合。以《双峰镇》为例是因为该剧“简直就是后现代主义电视的完美缩影”（341）。他指出，该电视剧之所以呈现出后现代主义的特征，是由一系列相关因素共同作用而导致的，如大卫·林奇 [1] （David Lynch）作为电影导演的声誉、剧集自身的风格特征，当然还有其对商业互文性的运用（如开发并销售衍生产品）。</p>
<p>在经济层面上，《双峰镇》开启了一个电视受众观念的新时代。受众不再被视为高度同质化的乌合之众，而是被剧集策略性地建构为一个碎片化的群体，依年龄、阶级、性别、性向、地域、族裔与“种族”的差异而呈现出不同的层次，每一个层次都对应着相应的广告商利益。大众的诉求如今纠缠于不同的受众群体之间，被分门别类地“出售”给相应的广告市场。由是观之，《双峰镇》的重要性在于其体现了广播电视网试图在与有线电视、电影和录影带产业的竞争中重居上风的努力——简言之，就是要博得“雅皮士” [2] （yuppies）一代的青睐。为证实上述观点，柯林斯对《双峰镇》的推广营销策略进行了专门的考察。他认为，该剧显然迎合了知识阶层的口味——林奇被标榜为“作者电影” [3] （auteur films）导演，《双峰镇》亦被贴上“先锋电视”的标签。不过，除此之外，还有很多人是以观看肥皂剧的心态观看该剧的，因此《双峰镇》便具有双重身份，两者互相结合，共同建构了一种后现代式的结构程式，即将该剧“同时锁定为准先锋电影与准肥皂剧”（345）。</p>
<h3 id="后现代主义与价值多元主义"><a href="#后现代主义与价值多元主义" class="headerlink" title="后现代主义与价值多元主义"></a>后现代主义与价值多元主义</h3><p>布尔迪厄努力在日常生活的经验世界中对“价值”进行（重新）定位，他试图表明：我们为某个休假目的地或某种着装风格“赋予价值”所产生的效果，丝毫不亚于我们为艾略特的诗作、奥提斯·雷丁（Otis Redding）的歌曲、辛蒂·舍曼 （Cindy Sherman）的摄影以及盖文·布莱亚斯（Gavin Bryars）的音乐赋予价值所产生的效果。价值评判从来就不是简单的个人品位问题，文化价值不但标榜社会差异的存在，而且维系并支持着社会差异。文化间的区隔源自后天习得的消费模式，并被人们内化为“自然而然”的倾向、质询及动员为某种“自然而然”的能力，而所有这一切只有一个最终目标：<em>捍卫社会统治的合法性</em>。统治阶级的文化品位被赋予制度化的形式，并在巧妙的意识形态操纵下将制度化的文化（统治阶级的文化）装裱成统治阶级文化优越性及社会优越性的佐证。总之，文化区隔对社会区隔、社会疏离以及社会等级进行着生产与再生产，成为维护统治阶级与被统治阶级之间社会差异的工具。由是，文化空间的生产与再生产便导致了社会空间的生产与再生产。</p>
<p>对于大众文化研究者而言，后现代主义所带来的最重要的影响莫过于人们开始认识到高雅文化与大众文化之间并不存在绝对的界限。尽管人们会认为某些文化比其他文化“更好”（至于对谁而言、好在哪里，则另当别论），但若想找一个简单明了的评判标准供我们参考、自动帮我们“去芜存真”，却是难上加难。</p>
<h3 id="全球性的后现代"><a href="#全球性的后现代" class="headerlink" title="全球性的后现代"></a>全球性的后现代</h3><p>将全球化视为单一美国文化（一种中产阶级的白人文化）的观念正在变淡，变得不那么单一。原因是多种多样的，例如美国拥有全世界第三多的西班牙裔人口。另据推算，及至2076年，即美国建国300周年时，印第安裔、非洲裔、亚洲裔以及拉丁裔将成为美国人口的主体。</p>
<p>霍尔曾宣称，所谓后现代主义“不过是全世界的美国梦”（Hall, 1996b: 132）。若真如此，那我们每个人的梦也是各不相同的，会梦到什么取决于我们选择美国的哪些部分进行消费。假如梦的原料来自美国流行音乐，则地理学与几何学、价值、影像、神话与风格等将因其属于蓝调音乐、乡村音乐、舞曲、民歌、重金属、爵士乐、说唱、摇滚、60年代摇滚或灵魂乐而截然不同。归根结底，每种音乐类型都会依阶级、性别、种族、族裔、性取向与代际的差异而生产出相应的政治接合。理解了这一点，才能认识到一切文化——包括无比强大的美国文化——都不是单一的。诚如萨义德所言：“文化与文化总是彼此牵连，谁都不能‘独善其身’。一切文化都是混血的、异质的、独特的、多元的”（Said, 1993: xxix）。</p>
<p>全球化是一个复杂的过程，产生了矛盾重重的后果，并导致文化与权力关系的变迁。我们可以借用葛兰西的霸权理论对全球化机制加以把握。从后马克思主义文化研究的霸权理论出发，文化既非“本真文化”（从“底层”自然生发出来），亦非“自上而下”强加给人民的欺骗性文化，而是两者之间的“均势妥协”（Gramsci, 1971: 161）。因此，文化既是“自下而上的”又是“自上而下的”，既是“商业的”又是“本真的”，既是“本土的”又是“全球的”。文化同时包含着“抵抗”与“收编”，兼顾“结构”与“行动”。全球化也如此。诚如霍尔所言：</p>
<p>所谓的全球化并非一个席卷万物、消弭一切差异的系统性过程，而是通过“特殊性”来发挥作用的——缅怀某些特殊的空间、特殊的族裔，想方设法唤醒自己的特殊身份，诸如此类。因此，我们应坚持用辩证的目光看待“本土”与“全球”的关系（Hall, 1991: 62）。</p>
<p>霸权是一个错综复杂且自相矛盾的过程，并非向人民灌输“虚假意识”那么简单。霸权可不是“在洛杉矶打好包装，海运至地球村港口，再于天真无邪的心灵之中缓缓展开”（Liebes and Katz, 1993: xi）的。理解全球化过程的更好方式是对全球驱动力与本土驱动力给予同等重视。我们须在承认权力存在的前提下，认清将“本土”人民视为其自身无力理解的某些过程中的沉默被动的受害者的政治策略。这种政治策略认为个体在宏大总体面前是虚弱无力的，至多只能承认受众的某些行为带有“行动者”的色彩；其存在的目的，则是维护既存的宰制性全球权力。</p>
<h3 id="融合文化"><a href="#融合文化" class="headerlink" title="融合文化"></a>融合文化</h3><h3 id="拓展阅读-3"><a href="#拓展阅读-3" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>Storey, John (ed.), Cultural Theory and Popular Culture: A Reader , 4th edition, Harlow: Pearson Education, 2009.该书是本书的配套阅读材料，其中收录了本书所涉之大多数重要文献。本书及其配套读本得到了互动式网站<a href="http://www.pearsoned.co.uk/storey%E7%9A%84%E6%94%AF%E6%8C%81%E3%80%82%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86%E8%AE%B8%E5%A4%9A%E6%9C%89%E7%94%A8%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%94%B5%E5%AD%90%E8%B5%84%E6%BA%90%E3%80%82">www.pearsoned.co.uk/storey的支持。该网站中包含了许多有用的链接与电子资源。</a></p>
<p>Appignansesi, Lisa (ed.), Postmodernism , London: ICA, 1986.本书是一本关于后现代主义哲学的论文集。推荐阅读麦克罗比的那篇《后现代主义与大众文化》。</p>
<p>Best, Steven, and Douglas Kellner, Postmodern Theory: Critical Interrogations , London: Macmillan, 1991.本书是关于后现代主义的优秀导论性著作。</p>
<p>Boyne, Roy and Ali Rattansi (eds), Postmodernism and Society , London: Macmillan, 1990.一部很有帮助的论文集，其导论部分对后现代主义的主要问题进行了精妙的介绍。</p>
<p>Brooker, Peter and Will Brooker (eds), Postmodern After-Images: A Reader in Film, Television and Video , London: Edward Arnold, 1997.本书是一部精彩的论文集，导论部分亦出色。</p>
<p>Champbell, Neil, Jude Davies, and George McKay, Issues in Americanization , Edinburgh: Edinburgh University Press, 2004.本书收录了一系列与美国化相关的优秀文章。导论部分相当精彩。</p>
<p>Collins, Jim, Uncommon Cultures: Popular Culture and Postmodernism , London: Routledge, 1989.本书非常有趣，将大众文化置于对后现代主义的讨论之中加以考察。</p>
<p>Connor, Steven, Postmodernist Culture: An Introduction to Theories of Contemporary , Oxford: Basil Blackwell, 1989.本书对后现代主义进行了全面的介绍，并围绕大众文化进行了有益的讨论。</p>
<p>Docker, John, Postmodernism and Popular Culture: A Cultural History , Cambridge: Cambridge University Press, 1994.本书旨在挑战持续了一个世纪的现代主义理论对20世纪大众文化的理解，兼具学术性、思辨性与可读性。</p>
<p>Featherstone, Mike, Consumer Culture and Postmodernism , London: Sage, 1991.本书从社会主义视角出发对消费文化与后现代主义进行讨论，推荐阅读。</p>
<p>Hebdige, Dick, Hiding in the Light , London: Comedia, 1988.本书收录了一系列关于后现代主义与大众文化问题的论文，推荐阅读。【224】</p>
<p>Jenkins, Henry, Convergence Culture: Where Old and New Media Collide , New York: New York University Press, 2006.本书是关于“融合文化”的重要文献。</p>
<p>Morris, Meaghan, The Pirate‘s Fiancée: Feminism, Reading, Postmodernism , London: Verso, 1988.本书收录的论文既有理论观照，又有案例分析，推荐阅读。</p>
<p>Ross, Andrew (ed), Universal Abandon: The Politic of Postmodernism , Minneapolis: University of Minnesota Press, 1988.本书是关于后现代主义的论文集，非常有帮助。其中涉及对大众文化的讨论。</p>
<p>Woods, Tim, Beginning Postmodernism , Manchester: Manchester University Press, 1999.本书或许是关于后现代主义的最佳导论性著作。</p>
<h2 id="第十章-大众文化的物质性"><a href="#第十章-大众文化的物质性" class="headerlink" title="第十章 大众文化的物质性"></a>第十章 大众文化的物质性</h2><h3 id="物质性"><a href="#物质性" class="headerlink" title="物质性"></a>物质性</h3><p>我们可以从不同的理论视角去思索大众文化的物质性。接下来，我会对下述三种理论视角进行扼要的评述：</p>
<ol>
<li>行动者网络理论（actor-network-theory）</li>
<li>文化研究</li>
<li>以及物质文化研究</li>
</ol>
<h3 id="作为行动者的物质性"><a href="#作为行动者的物质性" class="headerlink" title="作为行动者的物质性"></a>作为行动者的物质性</h3><p>行动者网络理论认为，大众文化并不只是人与人之间的行动与互动，还是人与物质之间、物质与物质之间的行动与互动。我们的很多行为都是在各种各样的物质体的介入下完成的。</p>
<h3 id="意义与物质性"><a href="#意义与物质性" class="headerlink" title="意义与物质性"></a>意义与物质性</h3><p>罗兰·巴尔特举例说明什么是大众文化的时候，他说所有这些例子都有一个共同特点，那就是它们都是符号（Barthes, 1995: 157）。“当我在街头漫步——或人生漫步——的时候，我遇到这些东西，我不假思索地对它们采取了同样的行动，那就是以某种特定的方式进行解读”（157）。换言之，巴尔特所面对的那些物质体，本身也是有待解读的符号；它们既有物质性，也承载着意义。文化研究与巴尔特在如下观点上不谋而合：“社会中存在的一切事物都有意义”（182），即这些事物被“人性赋予事物意义”这一事实所转化（179）。这样一来，环绕我们的物质世界并非自己生成意义，其意义是我们根据自己对它的思考、评价和使用给予的。</p>
<p>尽管物质体绝不仅仅是符号或对社会关系的符号再现，但对于我们来说，其存在总是令人不可思议地外在于将意义、物质性和社会实践混为一体的文化。</p>
<h3 id="没有意义的物质性"><a href="#没有意义的物质性" class="headerlink" title="没有意义的物质性"></a>没有意义的物质性</h3><p>丹尼尔·米勒（Daniel Miller）在其关于物质文化研究的小小宣言（Miller, 2009）中，以《皇帝的新装》 [1] 为例阐释了为何符号学（其实就是文化研究的代名词）根本无法实现对物质性的真正理解。</p>
<p>在米勒看来，符号学认为故事中的“华服”代表着“深深内在于我们的真实自我”（2009: 13）。他假定符号学将皇帝身上那件无中生有的衣服视为“成功或不成功地再现了真实存在的内核的表象”（同上）。米勒勇敢地挑战了关于内在自我的观念，指出这则寓言真正的意义如下所示：“衣服的缺位并非昭示了皇帝的内在自我，而是呈现出他的外在幻想”（同上）。因此，这其实是一个“关于自负和虚荣的道德故事”（同上）。我不知道哪些符号学家真的会去相信一件无中生有的衣服能够成为内在自我的代表，但从文化研究的视角出发，我确然相信我们完全有可能对安徒生的这篇作品做出不同的解读。</p>
<h3 id="全球化世界中的物质体"><a href="#全球化世界中的物质体" class="headerlink" title="全球化世界中的物质体"></a>全球化世界中的物质体</h3><p>文化让世界有意义。文化的重要性就体现为它能够帮助我们<em>组织和规范社会实践</em>。文化的这一含义并不否认物质性的存在，但我们要认识到<em>物质性本身是沉默的</em>，<em>无法自我彰显意义</em>，其意义只能通过人类的能动性获得，且始终与<em>权力关系</em>纠缠不清。尽管物质性会对事物指意的方式进行赋权和限制，但文化并非纯粹物质性的私产，而始终是意义、物质性和社会实践的复杂混合体。同一事物在不同的语境和社会实践中会拥有不同的意义。换言之，文化绝不仅仅等同于沉默的物质性；文化始终是社会的、物质的和符号的。</p>
<h3 id="拓展阅读-4"><a href="#拓展阅读-4" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>Storey, John (ed.), Cultural Theory and Popular Culture: A Reader, 4th edition, Harlow: Routledge, 2009.该书是本书的配套阅读材料，其中收录了本书所涉之大多数重要文献。</p>
<p>Barthes, Roland, The Semiotic Challenge, Berkeley: University of California Press, 1995.本书收录了一些关于符号学和物质性的重要论文。</p>
<p>Baudrillard, Jean, The System of Objects, London: Verso, 2005.尽管我们在本章中未提及此书，但实际上该书对于物质体的论述产生了很大的影响。</p>
<p>Berger, Authur Asa, What Objects Mean, Walnut Creek, CA: Lest Coast Press, 2014.本书对物质性理论进行了很好的概述。</p>
<p>【238】Bryant, Levi R., The Democracy of Objects, Michigan: Open Humanities Press, 2011.本书对物质体进行了有趣的哲学探讨。</p>
<p>Dant, Tim, Material Culture in the Social World, Milton Keynes: Open University Press, 1999.本书对物质性与文化的相关问题进行了精彩的论述。</p>
<p>Latour, Bruno, Reassembling the Social, Oxford: Oxford University Press, 2007.本书对行动者网络理论做出了精彩论述，其作者就是该理论的创始人。</p>
<p>Marx, Karl, Early Writings, Harmondsworth: Penguin, 1992.马克思关于生产与物质生活的理论是文化研究关于物质性的绝大多数论述的基础。参见《〈政治经济学批判〉序言》。</p>
<p>Miller, Daniel, Stuff, Cambridge: Polity Press, 2009.本书对物质文化研究做出了清晰的介绍。</p>
<h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><h3 id="大众政治"><a href="#大众政治" class="headerlink" title="大众政治"></a>大众政治</h3><p>在《文化民粹主义》（Cultural Populism ）一书中，吉姆·麦克盖根（Jim McGuigan）声称：当代文化研究领域内的大众文化研究正痛苦挣扎于范式危机之中，最显著的标志就是“文化民粹主义”思潮的盛行。在麦克盖根看来，所谓文化民粹主义乃是“某些大众文化研究者提出的理论假设，认定普通人的符号经验与实践无论在分析层面还是政治层面都远较大写的‘文化’重要”（McGuigan, 1992: 4）。《文化民粹主义》一书批判的目标并非此种意义上的文化民粹主义，而是*<em>“大众文化研究中的不加批判 的民粹主义”（同上），即一味追求阐释策略而罔顾文化消费的历史与经济条件的思路</em>。他批评文化研究正日趋将自己的理论关注简化成“阐释的问题”，却未曾将这些问题置于权力的物质关系的语境下加以审视。</p>
<p>当下条件下，普通人大多利用唾手可得的符号资源来从事意义生产活动，这是一个既清晰明了，又须在新修正主义（不加批判的文化民粹主义）之下不断完善的过程。因此，在这个基本观念之下，无论人们是否意识到自己所处之困境，针对这些人的解放事业都变得疑窦重重。经济剥削、种族主义、性别压抑……种种遭遇，不胜枚举。然而，在约翰·费斯克和保罗·威利斯等学者的眼中，那些被压迫者、被剥削者和被疏远者不但能够极好地化解自身的困境，还能在此基础上对世界进行充分的理解，并从这一过程中汲取源源不断的快感。显然，日常生活的微观政治行为如此丰富，以至于一度为大众文化批评家心向往之的美好未来的乌托邦竟骤然丧失了全部可信性（171）。</p>
<h3 id="文化场域（cultural-field）"><a href="#文化场域（cultural-field）" class="headerlink" title="文化场域（cultural field）"></a>文化场域（cultural field）</h3><p>约翰·费斯克通常被视为丧失批判性的文化民粹主义的代表人物，麦克盖根便声称：“费斯克的立场……表明英国文化研究批判性的衰落”（85）。在他看来，费斯克坚持不懈地以牺牲经济与技术决定力的方式为阐释 营造空间，竭尽全力将文化研究改造为一种纯粹的阐释学。例如，电视研究就被费斯克简化成了“某种主观理想主义”（72），即为大众的解读行为赋予无上地位，认为其自始至终都是“进步的”，而性别歧视与种族主义根本不是问题，全然漠视经济与政治的关系。简言之，面对费斯克对大众文化毫无保留且毫无批判性的拥护，我们应当进行严厉的指责，他就是霸权理论衰落以及麦克盖根所谓之“新修正主义”崛起的负面典型，是将文化研究简化为关于消费的多种阐释模式的首恶。新修正主义主要关注大众的快感、权力、抵抗以及辨别力，代表着文化研究“从更具批判性的立场上全面退却”（75）。用政治学的语汇来说，费斯克的思路至多只是对自由主义关于“消费者主权”的应声附和，甚至是大行其道的“自由市场”意识形态的同谋。</p>
<p>费斯克可不会接受人们用“新修正主义”来描述他对大众文化问题的立场。此外，面对麦克盖根借以攻击其理论的两个主要假设，费斯克也提出了坚决的反对。首先，他拒斥下述观点，即“资本主义文化工业生产出来的产品虽然具有多样性，但这种多样性只是人们的幻觉，因其最终均维护着同样的资本主义意识形态”（Fiske, 1987: 309）。其次，他着重强调：一切基于“‘人民’是‘文化白痴’”的论调都不足信，“大众并非消极被动或孤立无援，他们有能力明辨是非，无须经济、文化和政治巨头的怜悯”（同上）。作为还击，费斯克指出：大众文化借以流通的商品同时在两种经济中运行，分别是金融经济与文化经济。【242】</p>
<p>金融经济的运行与文化要素并非完全等同，但我们仍需在具体研究工作中对其予以充分重视……文化商品无法完全用金融的形式来描述，流通过程对于其大众性的形成发挥了至关重要的作用。这一过程不但与金融经济体系密切相关，更平行发生于文化经济领域（311）。</p>
<p>金融经济主要关注交换价值，而文化经济更重视使用价值，即商品如何带来“意义、快感与社会身份”（同上）。</p>
<p>费斯克声称，在西方社会，无权者对有权者的抵抗往往采用两种形式，分别为<strong>“符号抵抗”*与</strong>“社会抵抗”*，前者首要关注意义、快感与社会身份，后者则呼吁社会经济系统的变革；“两者虽相对独立，却保持着密切的关系”（316）。大众文化主要在符号领域内运行，但“也不尽然”，它深深卷入“同质化与差异，或共识与冲突的斗争”（同上）。在此意义上，大众文化其实是一个符号的战场，受众则持续不断地投身于“收编”与“抵抗”的“符号游击战”之中（同上）。其中，自上而下的欺骗性意义、快感与身份和符号抵抗运动中生成的意义、快感与身份之间存在着尖锐的冲突，而“同质性的霸权力量时刻面对着异质性的抵抗”（1989a: 8）。在费斯克的符号战场上，两种经济各自站在冲突双方的背后：金融经济支持同质性的收编力量，文化经济则是异质性抵抗力量的坚实后盾。由是，符号抵抗击破了资本主义的意识形态企图，宰制性意义面临着前所未有的挑战，而统治阶级在精神与道德领域的领导权也就摇摇欲坠了。费斯克以饱满的自信清晰地表达了自己的立场：【243】</p>
<p>我……将大众文化视为战场。它既承载着宰制性力量，又对大众应对、规避以及抵抗统治阶级权威的种种策略青睐有加。事实上，与其对收编过程穷追不舍而罔顾其他，不如转而考察大众的活力与创造力——正因大众富有无穷的活力与创造力，统治阶级才认为必须对其进行持续的“收编”；与其将注意力集中于无所不在且用心险恶的宰制性意识形态实践，不如试着理解日常生活中的抵抗与规避行为如何努力阻滞意识形态的运行并促使其“不得不”竭尽全力维护自身的价值。上述视角无比乐观地将大众文化视为名副其实的进步（尽管不是激进）力量，努力在人民的气魄与活力中探求社会变迁的可能，并竭力挖掘其背后的驱动力（20-21）。</p>
<p>此外，费斯克还将大众文化置于皮埃尔·布尔迪厄所言之“文化场域”之内（Bourdieu, 1984: 113-120）。文化场域是宰制性文化或官方文化与大众文化博弈的场所。文化间的斗争是经济或技术力量的抽象产物，并最终由经济与技术力量共同决定。在尼古拉斯·加恩汉姆（Nicholas Garnham）与雷蒙德·威廉斯看来，布尔迪厄认为：</p>
<p>阶级与群体间为确保自身的再生产而竭力追逐利益最大化的斗争存在于所有社会之中。社会形态乃是一系列依等级制构建起来的场域的集合，人类行动者便卷入其内的各类斗争，以谋求对知识、教育及经济等场域内社会资源的最大控制……场域乃是一种等级森严的结构。各个阶级为抢夺物质资源的生产与分配展开激烈的斗争，而每一个分支场域都依自身的结构逻辑——阶级斗争的逻辑——进行着再生产（Garnham and Williams, 1980: 215）。【244】</p>
<p>诚如布尔迪厄所言：“若要描述‘纯粹’（pure）凝视，则必须对与之相对的‘天真’（naive）凝视加以界定”（32）。而所谓“天真”凝视，毫无疑问，指的就是大众审美的凝视.</p>
<p>纯粹凝视与大众/天真凝视之间的关系无须牵涉艺术自身的品质，而更多反映着统治与被统治的关系。</p>
<p>在一部深入讨论布尔迪厄理论的著作中，保罗·威利斯指出：对“艺术”的美学鉴赏经历了一个“内在的超级制度化”过程（Willis, 1990: 2）。在这一过程中，艺术脱离了生活，社会功能被忽视，而有能力“鉴赏”艺术的少数人就与“粗鲁的群氓”划清了界限。在这一过程中，审美与教育之间的关系，即美学鉴赏所需相关知识的生产和再生产，遭到了否认（无论是正式的还是非正式的），美学品位被呈现为与生俱来之物，无法通过后天教育习得。当然，这并不意味着必须关闭“大多数人”接受教育的大门，只不过，普通人即使经过教育也无法学会“鉴赏”高雅文化的符码；在接受教育的过程中，他们应当“认识到自己的无知与迟钝，认识到他们和那些脱离了低级趣味的‘上等人’根本就是两路人。当然，他们也绝对没有任何‘天赋’，只有少数精英才有能力展示或创造‘艺术’”（3）。由是，那些在日常生活中制造着文化的人反而被贴上了“没文化”的标签。为了与文化“内在的超级制度化”策略相对抗，威利斯提出了所谓的“扎根美学”（grounded aesthetics）理念，即普通人在日常生活中对世界的文化意义进行创造的方式：“人们通过何种途径将自然世界与社会世界变得富有人性，并在一定程度上（哪怕只是符号层面上）对其加以控制”（22）。</p>
<p>法国文化理论家米歇尔·德·赛图（Michel de Certeau）也对“消费者”这个概念进行了深入考察，以图对消费行为，或他所言之“次级生产”做出解释（de Certeau, 2009: 547）。在他看来，消费“极其狡狯，难以把握；但消费又无处不在，以令人难于察觉的方式反复迂回，这是因为其并非通过产品，而是在宰制性经济规则的压迫下借由‘使用’的方式来彰显自身”（546）。在德·赛图看来，文化场域内存在着持久的、令人难以察觉的冲突，交战的双方则分别是文化权力的战略（strategy）（生产）和文化使用的战术（tactics）（消费，或“次级生产”）。文化批评家须警惕“隐藏于……使用过程中的……生产……与……次级生产的异同” [6] （547）。德·赛图将积极的消费行为比喻为“盗猎”（poaching）：“读者就是旅行者，在不属于自己的土地上迁徙，就如同盗猎的流浪汉一样窃取着别人书写的内容”（1984: 174）。</p>
<p>将阅读等同于盗猎的观念显然拒绝了视文本“信息”为自上而下强加之物的理论假设。德·赛图指出，人们之所以会产生理解的误差，皆因未能认清消费过程的本质。这种“误解先天认为‘同化’（assimilating）必然意味着与自身汲取之物‘变得相似’；可实际上，消费者总是能够‘使某物变得与自身相似’，进而将商品加以改造、据为己有”（166）。</p>
<p>文本盗猎行为始终与文本生产者的“圣典经济”（scriptural economy）（131-176）发生着持续的冲突。而来自制度的声音（如专业批评家、学者等）往往维护作者与文本自身的权威性，制约着“非权威”意义的生产与流通，亦属盗猎行为反对的目标。如此，德·赛图的“盗猎”概念就对强调被动接受作者与文本意图的传统解读模式构成了挑战，阅读行为不再仅仅是简单的“对”或“错”。据他考察，很多文本都因蕴含着隐匿的意义而帮助维系了教学法中的权力关系：</p>
<p>小说总是将消费者置于被统治地位，因为这些消费者在沉默不语的“财富”面前始终显得既不贞又无知……虚构的“宝藏”就潜藏在作品之中，包孕着无比丰富的意义，起决定性作用的当然不是读者的生产性，而是综合决定了读者与文本之间关系的社会制度。阅读行为仿佛是（教师与学生之间）力量关系的翻版，最终也就变成了社会权力的工具（171）。</p>
<p>相应地，也就产生了一种独特的教学实践，即“学生……被轻蔑地赶回或骗回到教师所‘接受’的意义上” [7] （172）。这就是我们通常所谓之“文本决定论” [8] ，即认定事物的价值先天包含在其自身之中。在此观念体系下，某些特定的文本与实践就会被预先纳入学术性凝视的合法性关注范围内，而其他文化形式则被贬低或排除。我倒认为研究什么对象并不重要，重要的是通过什么方法来研究这个对象。【248】</p>
<p>在文化研究领域内对迷文化进行的最有趣的论述莫过于<em>亨利·詹金斯</em>的<em>《文本盗猎者》（Textual Poachers ）</em>。通过在某一社区（其绝大多数成员是中产阶级白人妇女）展开民族志研究，他得以同时从“学者（掌握大众文化理论、据有批判及民族志文献的人）与沉迷者（掌握该社区特定知识与传统的人）”两个角度对“迷”现象做出诠释（Jenkins, 1992: 5）。</p>
<p>沉迷者的阅读行为兼含智力性与情感性。“读者与文本的近距离接触非但未使读者被文本占有，反而促进了读者对文本的完全占有。只有将传媒内容融入日常生活，只有与文本的意义和资料保持紧密的联系，‘迷’们才能对小说进行充分的消费并将其转化为积极的动力”（62）。詹金斯同样反对文本决定论（文本决定了人们阅读的方式，进而将读者置于某种意识形态话语之中），他坚称：“读者并非被强行拽入业已构成的虚幻世界，而是拥有充分的自主性以创造新的文本资料。因此，读者脑中预存的价值观与叙事系统所传递的价值观在重要性上是难分伯仲的”（63）。【249】</p>
<p>对于文本，“迷”们并非一读了事，而是进行着持续的、翻来覆去的阅读，这便颠覆了文本与读者之间天然的关系。阅读行为破坏了巴尔特所谓之“阐释代码”（hermeneutic code）机制（文本通过设置悬念的方式诱发读者的阅读兴趣）。通过反复阅读，读者的注意力从“即将发生什么”转移到“事情如何发生”，开始关心人物关系、叙事主题以及社会知识与话语的生产过程。</p>
<p>尽管阅读实践在大多数情况下是一种私人化的单独行为，但“迷”们仍是作为社区的一分子来对文本进行消费的。究其实质，迷文化就是意义生产与阅读实践的公开展示与流通，形形色色的“迷”在彼此的交流之中创造着意义，而这些意义的公开展示与流通对于迷文化的再生产而言至关重要。诚如詹金斯所言：“组织化的沉迷现象最显著的特征在于其生成了一种理论与批评的惯例。迷文化仿若一个半结构空间，对文本的诸种阐释与评估机制便于其中交相辉映、互相冲突、交流妥协，读者亦时刻思索着大众传媒的天性及其与自身的关系”（86）。</p>
<p>“迷”们并不仅仅是狂热的读者，而且是积极的文化生产者。詹金斯对电视迷通过小说创作来改写自己喜爱的电视节目的10种方法做出了如下归纳：</p>
<ol>
<li>情境重置 （recontextualization）：生产简评与长短篇小说以填补广播叙事（broadcast narrative）的空白，进而对特定行为做出额外的解释。</li>
<li>扩充时间线 （expanding the series timeline）：生产简评与长短篇小说来为虚构人物提供历史背景，而非纠缠于广播叙事对人物发展前景的探索。</li>
<li>焦点重置 （refocalization）：将注意力从主要人物转移到次要人物身上。例如，将原本处于文本边缘位置的女性黑人置于舞台的正中央。</li>
<li>道德重组 （moral realignment）：与“焦点重置”类似，即对广播叙事中的道德标准进行转换（如坏人变好人）。在有些情况下，原有道德标准仍得以维系，但叙事的视角转移到“坏人”身上。</li>
<li>类型转换 （genre shifting）：例如，将原本用于科幻剧集的叙事移位到言情剧集或西部剧集之中。</li>
<li>交叉 （cross-overs）：让某一部电视剧中的人物出现在另一部电视剧中。例如，《神秘博士》中的人物有可能以同样的身份出现在《星球大战》里。</li>
<li>人物移位 （character dislocation）：人物以新的名字、新的身份出现在新的叙事里。</li>
<li>个人化 （personalization）：改写者将自己写入自己喜爱的电视节目中。例如，我可以写一部短篇小说，在情节中安排自己被神秘博士邀请一同进行时光旅行，去探寻曼联球队到24世纪时变成了什么模样。不过，詹金斯也指出，迷文化中的许多人都不喜欢这种改写方式。【250】</li>
<li>情感激化 （emotional intensification）：生产所谓“悲喜交加”的故事，如安排自己最喜爱的人物经历情感危机。</li>
<li>情色化 （eroticization）：探索虚构人物生活中情色的一面，最著名的例子莫过于描绘同性恋关系的同人小说。</li>
</ol>
<p>迷文化以抗争的方式，在“将许多美国人转化为旁观者的压迫力”中创造出“一种可供更多人分享的文化”（284）。在詹金斯看来，这是迷文化强大力量的集中体现。力量并非由商品自身产生，而是源自“迷”们对商品的消费与利用，如其所言：</p>
<p>需要声明，文本自身并不具备什么力量，力量是在“迷”们将文本吸收融入自己独特的生活体验的过程中产生的。迷文化所青睐的并非“奇异”的文本，而是“奇异”的解读方式（尽管读者的诠释性实践使得两者之间的界限模糊不清）（同上）。</p>
<p>克拉克提出，假若亚文化消费仍要留在文化研究的领域之内，就必须“突破其出发点的樊篱”（92），绝不能动不动就为其他文化扣上“收编”的帽子。文化研究最好也将注意力集中在“所有青年的行为之上，为文化与社会关系的延续与断裂找寻定位，并探索这些行为对青年自身而言具有何种意义”（95）。</p>
<h3 id="经济场域（economic-field）"><a href="#经济场域（economic-field）" class="headerlink" title="经济场域（economic field）"></a>经济场域（economic field）</h3><p>来自媒介与传播领域的人（在学术界，这些人几乎全为男性，而且完全是文化研究的门外汉）撰写了大量文章和会议论文，声嘶力竭地呼吁文化研究必须立刻无条件、全身心地拥抱政治经济学方法以维系自身的政治信誉。 [1] 麦克盖根就是这一观点早期的重要代表。</p>
<p>大家都小心翼翼地回避着经济问题，此举严重损害了文化研究的解释力，并导致政治批判功能的丧失（McGuigan, 1992: 40-41）。</p>
<p>尼古拉斯·加恩汉姆表达过相似的观点：“文化研究若要实现自己的政治理想，必须重建通往政治经济学的桥梁”（Garnham, 2009: 619）。当下的文化研究普遍高估消费者的力量，反而忽视了生产在约束消费可能性方面扮演的“决定性”角色。</p>
<p>请看彼得·戈尔丁（Peter Golding）与格雷厄姆·莫多克（Graham Murdock）对政治经济学的基本理论与方法所做的归纳：</p>
<p>批判政治经济学视角最显著的特征在于……其对公共传播（包括大众文化）领域内符号与经济维度之间互动关系的关注。掌握了政治经济学，便可理解被金钱与权力控制的文化产品如何通过各种各样的方式左右公共领域内的话语与表征，进而控制受众对上述话语与表征的介入 （Golding and Murdock, 1991: 15）。</p>
<p>政治经济学声称自己是考察大众文化的唯一“正道”不但大错特错，而且极有可能导致过分简化与扭曲，甚至扼杀文化研究的无穷活力。【258】</p>
<h3 id="后马克思主义文化研究：重顾霸权理论"><a href="#后马克思主义文化研究：重顾霸权理论" class="headerlink" title="后马克思主义文化研究：重顾霸权理论"></a>后马克思主义文化研究：重顾霸权理论</h3><p>后马克思主义霸权理论坚持认为在生产过程与消费行为之间始终存在密切的对话。消费者所面对的文本或实践是由生产条件决定的物质存在，而文本与实践所面对的消费者同时是将一系列潜在意义为我所用 的生产者。仅关注文本或实践的物质性，以及生产的意义与关系显然是远远不够的。</p>
<h3 id="群氓文化意识形态"><a href="#群氓文化意识形态" class="headerlink" title="群氓文化意识形态"></a>群氓文化意识形态</h3><p>我们已然认识到，在此时此地以及可预见的将来，自己都将生活在一个由跨国资本主义主宰的世界里，诚如葛兰西所言，这是一种“精神的悲观主义，理想的乐观主义”（Gramsci, 1971: 175）。我们每个人——不仅仅是先锋知识分子——都应当将自己视为文化的积极参与者。我们要通过选择、拒绝、制造意义、分配价值、抵抗，以及被蒙蔽、被控制等种种方式投入到文化中。不过，这并不意味着我们摒弃了“表征的政治”。对此，我赞同洪美恩的观点，坚信尽管快感是政治的，但绝不可将快感与政治混为一谈。</p>
<h3 id="拓展阅读-5"><a href="#拓展阅读-5" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>Storey, John (ed.), Cultural Theory and Popular Culture: A Reader , 4th edition, Harlow: Pearson Education, 2009.该书是本书的配套阅读材料，其中收录了本书所涉之大多数重要文献。本书及其配套读本得到了互动式网站<a href="http://www.pearsoned.co.uk/storey%E7%9A%84%E6%94%AF%E6%8C%81%E3%80%82%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86%E8%AE%B8%E5%A4%9A%E6%9C%89%E7%94%A8%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%94%B5%E5%AD%90%E8%B5%84%E6%BA%90%E3%80%82">www.pearsoned.co.uk/storey的支持。该网站中包含了许多有用的链接与电子资源。</a></p>
<p>Bennett, Tony, Culture: A Reformer‘s Science , London: Sage, 1998.本书是一部论文集。作者系文化研究领域的领军人物之一，他对该领域的近史与相关实践进行了广泛的论述。</p>
<p>During, Simon, (ed.), The Culture Studies Reader , 2nd edn, London: Routledge, 1999.本书收录了许多文化研究领域大师的文章，十分有价值。</p>
<p>Gilroy, Paul, Lawrence Grossberg, and Angela McRobbie (eds), Without Guarantees: In Honour of Stuart Hall , London: Verso, 2000.本书收录了许多关于斯图亚特·霍尔的著作的论文。</p>
<p>Gray, Ann and Jim McGuigan (eds), Studying Culture: An Introductory Reader , London: Edward Arnold, 1993.本书是一部精彩的论文集，收录了许多文化研究大师的文章。</p>
<p>Grossberg, Lawrence, Bringing It all Back Home: Essays on Cultural Studies , Durham, North Carolina: Duke University Press, 1997.本书的作者是文化研究领域的佼佼者，书中收录了他的一些理论性文章。</p>
<p>Grossberg, Lawrence, Dancing in Spite of Myself: Essays on Popular Culture , Durham, North Carolina: Duke University Press, 1997.本书的作者是文化研究领域的佼佼者，书中收录了他关于大众文化的相关论文。</p>
<p>Grossberg, Lawrence, Cary Nelson and Paula Treichler (eds), Cultural Studies , London: Routledge, 1992.本书收录了40篇文章（大多配有相关讨论），是一部关于文化研究领域内相关争论的优秀的导论性著作。【263】</p>
<p>Morley, David and Kuan-Hsing Chen (eds), Stuart Hall: Critical Dialogues in Cultural Studies , London: Routledge, 1995.本书汇编了与斯图亚特·霍尔相关的文章与访谈录，总结过去，评述现在，展望未来，精彩纷呈。</p>
<p>Munns, Jessica and Gita Rajan, A Cultural Studies Reader: History, Theory, Practice , New York: Longman, 1995.本书体例科学，选文的编纂亦令人称道。</p>
<p>Storey, John (ed.), What is Cultural Studies: A Reader , London: Edward Arnold, 1996.本书收录了许多篇精彩的论文，从各个角度回答了“什么是文化研究”这一问题。</p>
<p>Storey, John, Inventing Popular Culture, Malden, MA: Blackwell, 2003.本书对大众文化的概念做出了历史性的考察。</p>
<p>Storey, John, Culture and Power in Cultural Studies: The Politics of Signification, Edinburgh: Edinburgh University Press, 2010.本书涉及的许多讨论都可以延展为具体的研究领域。</p>
<p>Storey, John, From Popular Culture to Everyday Life, London: Routledge, 2014.这本书将文化研究批判的焦点从大众文化转移到日常生活领域。</p>
<p>马克思曾指出：“一件衣服由于穿的行为才现实地成为衣服；一间房屋无人居住，事实上就不成其为现实的房屋；因此，产品不同于单纯的自然对象，它在消费中才证实自己是产品，才成为产品”（Marx, 1976a: 19）。这就是一本书和一个文本的区别——前者是被出版商生产出来的，而后者是被读者生产出来的。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>笔记</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>2022</tag>
      </tags>
  </entry>
  <entry>
    <title>《大众文化与文化理论》(1)</title>
    <url>/BassHero.github.io/2022/03/30/ISBN978-7-309-05840-6_01/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="第一章-何谓大众文化"><a href="#第一章-何谓大众文化" class="headerlink" title="第一章 何谓大众文化"></a>第一章 何谓大众文化</h2><h3 id="文化"><a href="#文化" class="headerlink" title="文化"></a>文化</h3><p>文化=意识形态<br><br>雷蒙德·威廉斯（Raymond Williams）指出，文化乃是“英语之中最复杂的两三个词语之一”（Williams, 1983: 87）。他为文化下了三个范围宽泛的定义。第一，“文化”一词的第一种用法可以指“智力、精神和美学发展的一般过程”（90）。例如，在谈论西欧文化发展史的时候，我们可以仅仅涉及智力、精神和美学方面的成就，如伟大的哲学家、艺术家和诗人。这也是一种易于理解的解释方式。“文化”一词的第二种用法是指“一群人、一个时期或一个群体的某种特别的生活方式”（同上）。若想以这种用法来解读西欧文化发展史，我们便不能仅仅考虑智力和美学成就，还要了解诸如识字率、休闲方式、体育运动、宗教节日等内容。最后，威廉斯指出，文化可被用来指涉“智力，尤其是美学所创造的作品和实践”（同上）。换言之，此处的“文化”指的是一系列的文本与实践，而这些文本与实践的主要功能是对意义（meaning）进行指涉和生产，并为这一过程提供场所。文化的第三个含义与结构主义者以及后结构主义者所声称的“指意实践”（signifying practices）大体相同（参见第六章）。如果用第三种定义来看待文化，那么诗歌、小说、芭蕾、歌剧和美术都将被纳入考察的范畴。至于我们所要探讨的“大众文化”，则需灵活运用文化的第二个和第三个定义。</p>
<span id="more"></span>
<h3 id="意识形态"><a href="#意识形态" class="headerlink" title="意识形态"></a>意识形态</h3><p>第一，意识形态可以指“为某一特定人群所接合（articulate）的观念系统”。例如，我们常说的“专业意识形态”即指代表特定专业人群实践的那些观念。再比如，我们可以说“工党的意识形态”，意指体现了该党精神与实践的那些政治、经济和社会观念的集合。<br>第二种定义则将意识形态视为某种掩饰、扭曲或欺瞒，用来描述某些文本和实践如何呈现对现实加以歪曲的图景。有些时候，人们认为这些被歪曲的现实图景制造出“虚假意识”（false consciousness），并在权力者利益和无权者利益之间发挥作用。<br>第三种定义（在某种程度上依托于第二种定义并与之关系密切）用“意识形态”这一表述来指代“意识形态构成”（Marx, 1976a: 5）。这一定义关注文本（电视剧、流行音乐、小说、剧情片等）如何持续不断地呈现关于外部世界的图景。其理论前提是：“社会”的概念建立于互相冲突而非彼此赞成的基础之上，是围绕着不平等、剥削和压迫被建构出来的。在这场冲突中，文本有意无意地偏袒着某一方。德国剧作家贝托尔特·布莱希特 [1] （Bertolt Brecht）如是总结：“无论好剧还是坏剧，都包含着一幅世界的图景……世上不存在对观众的立场与观点毫无影响的戏剧和演出。艺术从来都伴随着某种后果”（Brecht, 1978: 150-151）。<br>正如斯图亚特·霍尔（Stuart Hall）声称的那样，大众文化是“创造总体性的社会观念”的场所，是“指意的政治”彼此争夺、诱使人们按照某些特定的方式观察世界的竞技场（Hall, 2009a: 122-123）。<br><br>意识形态的第四个定义与法国文化理论家罗兰·巴尔特（Roland Barthes）的早期作品有密切关联（在第六章会详细讨论）。巴尔特指出，意识形态（巴尔特本人称之为“神话”）主要在内涵（connotation）层面上发挥作用，是文本或实践所承载或可能承载的、间接的、常常是无意识的含义。在英国社会中，那些白种的、男性的、异性恋的、中产阶级的人是不言自明的“正常人”“普通人”“自然人”，而其他人则是这一“原型”的次等“变种”。<br><br>第五个定义在20世纪70年代和80年代早期十分盛行，其作者是法国马克思主义哲学家路易·阿尔都塞（Louis Arthusser）。在第四章中,阿尔都塞的主要观点是：意识形态并不是简单的观念的集合，而是一种物质实践，这意味着意识形态存在于日常生活的实践之中，而不仅仅存在于关于日常生活的观念之中。他还认为，一些仪式和风俗会通过某种方式起作用，将我们捆绑在社会秩序之上；而这所谓的社会秩序的标志，是财富、地位与权力的显著不平等。<br></p>
<h3 id="大众文化"><a href="#大众文化" class="headerlink" title="大众文化"></a>大众文化</h3><p>首先我们要弄清楚什么是“大众”（popular）。威廉斯认为“大众”一词有四种现行的含义：“为很多人所喜爱”；“质量低劣的作品”；“被特意用来赢取人们喜爱的作品”；“人们为自己而创造的文化”（Williams, 1983: 237）。<br><br>第一种定义所谓大众文化，是指那些被很多人热爱与喜好的文化。难以量化popular。<br><br>第二种定义认为，大众文化就是除了“高雅文化”之外的其他文化，是一个剩余的范畴，是那些无法满足“高雅”标准的文本和实践的“栖身之所”。持有这种观点的人很多，他们尤其强调“经典文本”的品质是划分高低文化的决定性因素。巨大的销量和商业的成功显然使得作曲家、演奏家和歌唱家成了大众文化的一分子。<br><br>霍尔指出，大众的形式在“文化电梯”里的上上下下并不是讨论的关键，重要问题在于“哪些力量与权力关系维系着这种分野和区隔……社会制度和制度化的社会过程……让文化的高低之分得以存在和维系”（Hall, 2009b: 514）。<br><br>第三种定义将“大众文化”等同于“群氓文化”。<br><br>这种文化本身是程式化的、极具操纵性的（由于不同的文化分析家具有不同的政治倾向，因此这种操纵性在政治上也有或左或右的差别），持续麻痹着本已麻木不仁的人群。然而，约翰·费斯克（John Fiske）举出了反例，他的研究表明，“80％—90％的新文化产品都在商业上失败了，尽管生产者做了海量的广告……但很多电影的票房收入甚至无法弥补其推广成本”（Fiske, 1989a: 31）。西蒙·弗里斯（Simon Frith）也指出，大约80％的单曲和唱片都是亏本生意（Frith, 1983: 147）。类似的统计数据清晰地表明，那些认为消费仅仅是一种机械性、被动性行为的观点是不尽准确的（参见第七章和第十一章）。<br><br>第四个定义认为大众文化是来源于 “人民”的文化。这一观点反对任何视大众文化为自上而下强加于 “人民”的文化的论断。鉴于此，“大众文化”一词仅指属于“人民”的“本真的”文化，就等于民间文化，乃是一种民治、民享的文化。该定义“时常将大众文化等同于一种极富浪漫色彩的工人阶级的文化，是当代资本主义内部的符号性抵抗的主要源泉”（Bennett, 1980: 27）。<br><br>第五个定义来自意大利马克思主义者安东尼奥·葛兰西（Antonio Gramsci）的政治分析，尤其与其对“霸权”这一概念的发展密切相关。葛兰西用“霸权”这个词来指涉社会统治集团如何通过控制“智力与道德的领导权”（Gramsci, 2009: 75）来赢取被统治集团的赞同（consent）。<br><br>正如托尼·本内特（Tony Bennett）所言：【10】<br><br><br>统治阶级试图赢取领导权，而被统治者通过种种方式与之对抗。正是这种关系构成了大众文化研究的领域。故而，大众文化既包括自上而下的、旨在维护统治阶级意识形态的欺骗性“群氓文化”和自发的、自下而上的对抗性文化，也包括两者之间彼此妥协的“区域”。在这个区域里（包含各种各样不同类型的大众文化），宰制性的、屈从性的与反抗性的文化及意识形态价值彼此“混杂”，互相转换（Bennett, 2009: 96）。<br>大众文化的第六个定义是从近来对后现代主义争论的思考中生发出的，我们将在第九章中详述。在此，我仅枚举关于后现代主义与大众文化之间关系的若干基本观点。后现代主义的核心观点是：后现代文化已不再具有高低之分。不难猜出，一些人会因此而雀跃于精英主义文化观的末日的到来，而另一些人会因商业最终战胜了文化而深感绝望。关于商业和文化互相渗透的现象（后现代主义模糊了“本真文化”与“商业文化”之间的区别），可以从电视广告和流行音乐的关系中一窥究竟。<br><br><br></p>
<h3 id="作为“他者”的大众文化"><a href="#作为“他者”的大众文化" class="headerlink" title="作为“他者”的大众文化"></a>作为“他者”的大众文化</h3><p>“大众文化”这个词界定困难在很大程度上是由“缺席的他者”造成的。</p>
<h3 id="意义的语境化"><a href="#意义的语境化" class="headerlink" title="意义的语境化"></a>意义的语境化</h3><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>Storey, John (ed.), Cultural Theory and Popular Culture: A Reader , 4th edition, Harlow: Pearson Education, 2009.该书是本书的配套阅读材料，其中收录了本书所涉之大多数重要文献。本书及其配套读本得到了互动式网站<a href="http://www.pearsoned.co.uk/storey%E7%9A%84%E6%94%AF%E6%8C%81%E3%80%82%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86%E8%AE%B8%E5%A4%9A%E6%9C%89%E7%94%A8%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%94%B5%E5%AD%90%E8%B5%84%E6%BA%90%E3%80%82">www.pearsoned.co.uk/storey的支持。该网站中包含了许多有用的链接与电子资源。</a></p>
<p>Agger, Ben,Cultural Studies as Cultural Theory , London: Falmer Press, 1992.如标题所示，本书作者是用一种倾向于法兰克福学派的视角来探讨文化研究问题的。书中关于大众文化的某些评论很有用处，尤其推荐第二章“作为严肃商业的大众文化”。</p>
<p>Allen, Robert C.(ed.), Channels of Discourse, Reassembled , London: Routledge, 1992.尽管这主要是一部与电视研究相关的论文集，但其中收录的一些文章对大众文化研究者而言极富参考价值。</p>
<p>Bennett, Tony, Colin Mercer and Janet Woollacott (eds), Popular Culture and Social Relations, Milton Keynes: Open University Press, 1986.本书是一本值得关注的论文集，其中收录的文章既包括理论介绍，又包括具体分析。【17】</p>
<p>Brooker, Peter, A Concise Glossary of Cultural Theory , London: Edward Arnold, 1999.这是一部非常出色的文化理论关键词词典。</p>
<p>Day, Gary (ed.), Readings in Popular Culture , London: Macmillan, 1990.这是一本毁誉参半的论文集，收录了一些实用且有趣的文章，其中有些文章对大众文化研究的严肃性问题持犹疑态度。</p>
<p>Du Gay, Paul, Stuart Hall, Linda Janes, Hugh Mackay and Keith Negus, Doing Cultural Studies: The Story of the Sony Walkman , London: Sage, 1997.这是一部出类拔萃的著作，对文化研究的一些关键问题进行了评介。若想对“文化圈”的现象做出解释，此书值得一读。</p>
<p>Fiske, John, Reading the Popula r, London: Unwin Hyman, 1989.一部论文集，收录了作者对大众文化中不同现象的分析。</p>
<p>Fiske, John,Understanding Popular Culture , London: Unwin Hyman, 1989.本书是作者对其独具一格的大众文化研究路径的概述。</p>
<p>Goodall, Peter, High Culture, Popular Culture: The Long Debate, St.Leonards: Allen &amp; Unwin, 1995.本书回顾了高雅文化和大众文化之争的历程，并结合从18世纪至今的澳大利亚的实例和一些其他例子来支撑自己的观点。</p>
<p>Milner, Andrew, Contemporary Cultural Studies , 2nd edition, London: UCL Press, 1994.该著作对当代文化研究做了具有实用性的介绍。</p>
<p>Mukerji, Chandra and Michael Schudson (eds), Rethinking Popular Culture, Berkeley: University of California Press, 1991.这是一部论文集，附有一篇涉猎广泛且令人兴味盎然的导言。本书依据不同的研究路径——历史学、人类学、社会学与文化学——对大众文化研究的不同文献进行分类，有助于理解和阅读。</p>
<p>Naremore, James and Patrick Brantlinger, Modernity and Mass Culture , Bloomington and Indianapolis: Indiana University Press, 1991.这是一部既有趣又实用的关于文化理论与大众文化的论文集。</p>
<p>Storey, John, Inventing Popular Culture , Malden, MA: Blackwell, 2003.本书对大众文化的概念进行了历史性的梳理。</p>
<p>Strinati, Dominic, An Introduction to Theories of Popular Culture, London: Routledge, 1995.这是一部关于大众文化理论的清晰而全面的著作。</p>
<p>Tolson, Andrew,Mediations: Text and Discourse in Media Studies , London: Edward Arnold, 1996.这是一部关于大众传媒文化的优秀著作。</p>
<p>Turner, Graeme, British Cultural Studies , 3rd edition, London: Routledge, 2003.本书是目前为止对英国文化研究最翔实的介绍。</p>
<p>Walton, David, Introduction Cultural Studies: Learning through Practice , London: Sage, 2008.又一部优秀的文化研究概论性著作，实用、资料丰富且十分有趣。</p>
<h2 id="第二章-“文化与文明”传统"><a href="#第二章-“文化与文明”传统" class="headerlink" title="第二章 “文化与文明”传统"></a>第二章 “文化与文明”传统</h2><p>属于大多数人的大众文化始终与手握权力的少数人密切相关。有两个因素发挥了关键作用，即工业化和城市化。正是这两者的结合导致了大众文化的形成；而大众文化的诞生标志着旧式文化关系的终结。<br>英国历史上首次出现了专属于被统治阶级的独立文化，其发源地则是各大城市和工业中心。这一文化由两种来源构成：（1） 文化企业家以赢利为目的而生产出来的文化；（2） 思想激进的匠人、新兴城市无产阶级和倡导革新的中产阶级生产出来的、旨在鼓动政治变革的文化——E.P.汤普森（E.P.Thompson）在《英国工人阶级的构成》（The Making of the English Working Class ）一书中对这三类人有精到的描述（参见第三章）。这两种新文化来源从不同方面对文化的凝聚力和社会的稳定构成了威胁：前者通过将文化变成商品的方式瓦解了文化的凝聚力和权威性，后者则对所有形式的政治及文化权威形成了直接的挑战。</p>
<h3 id="马修·阿诺德"><a href="#马修·阿诺德" class="headerlink" title="马修·阿诺德"></a>马修·阿诺德</h3><p>阿诺德所著之《文化与无政府状态》（Culture and Anarchy ）一书（当然，讨论的范围并不局限于此），正是这部著作奠定了阿诺德作为卓越的文化批评家的历史地位。<br><br>在阿诺德看来，文化乃是：（1） 获知“最好之物”的能力；（2） “最好之物”本身；（3） 将“最好之物”运用于精神与灵魂；（4） 对“最好之物”的追求。<br><br>所谓的“无政府状态”在一定程度上成了大众文化的代名词，阿诺德正是用这个词来描述工人阶级的活文化先天具有的某种破坏性的特质的。<br><br>阿诺德这个文化理论的奠基人其实根本没有对“大众文化”这一概念展开讨论，他只是简单地将大众文化视为深刻的政治骚乱的同义词。《文化与无政府状态》一书的主题也不是文化，而是社会秩序与社会权威应如何赢取文化领导权，使被统治者温顺地臣服。<br>柯勒律治认为“文明”是一个国家整体的品质，而“教养”专属于少数人，即其所称的“知识阶层”。一个国家的文明进程需由有教养的知识阶层来引导：<br><br>全部秩序的最终目标和意图在于：保护好古老文明的店铺和财富，搭建现在和过去之间的桥梁；补充和完善现有的一切，借此建立现代和未来之间的联系；尤其要让社会中的每一个遵纪守法的人知晓，知识的数量和质量对于理解其所拥有的权利及其务必履行的义务而言，是不可或缺的（34）。<br></p>
<h3 id="利维斯主义"><a href="#利维斯主义" class="headerlink" title="利维斯主义"></a>利维斯主义</h3><p>利维斯主义的基本立场是：“文化始终是少数人的专利”（Leavis and Thompson, 1977: 3）。<br>埃德蒙·戈斯 [3] （Edmund Gosse）的话来阐明此种现状的严重性：<br></p>
<p>如我所见，民主思想的蔓延所带来的一个巨大威胁，即是文学鉴赏的传统和经典文本的权威已经被群氓的投票所成功篡改。目前，在世界各地，那些未曾接受教育或只接受过一丁点教育的乌合之众竟已成为文学读者的主体。<br><br>在利维斯主义者眼中，黄金时代的标志不是单纯的文化整体性，而是建立在权威制和等级制原则上的文化整体性。<br><br>利维斯主义所产生的“深刻的、难以预料的影响”主要体现在理查德·霍加特（Richard Hoggart）和雷蒙德·威廉斯的著作中。<br><br>格雷欣定律，即“劣币驱逐良币”（bad money drives out good）法则。<br></p>
<h3 id="美国的大众文化：一场战后大讨论"><a href="#美国的大众文化：一场战后大讨论" class="headerlink" title="美国的大众文化：一场战后大讨论"></a>美国的大众文化：一场战后大讨论</h3><p>安德鲁·罗斯认为，“大众”（mass）乃是“将美国与美国之外的世界正式区隔开来的关键概念”（Ross, 1989: 42）。他指出：“这种正式区隔背后的历史，在很大程度上就是现代民族文化形成的历史”（同上）。二战之后，在美国国内成功形成了一种文化与政治的共识，这种共识建立在自由主义、多元主义和对阶级概念的淡化的基础之上，而美国知识阶层所树立的文化权威是此共识的主要来源。后来，这一局面被接踵而至的黑人民权运动、反正统文化思潮 [2] 、反越战运动、妇女解放运动和同性恋人权运动所打破。罗斯称：“知识阶层将自己视为全民族的文化、道德和政治领袖，这在美国历史上也许是头一次”（43）。知识分子之所以一下子变得这么重要，在一定程度上归功于“那场持续了15年、直到50年代末才结束的关于‘大众文化’的激烈大讨论”（同上）。罗斯花费了很多精力，试图证明这场讨论与冷战时期的“遏制性”意识形态有关——之所以要讨论文化问题，原因在于美国试图建立一个从内（文化贫乏带来的危机）到外（共产主义苏联的威胁）都处于健康状态的国家（body politic）。他认为，知识分子在这场讨论中分属三大阵营：<br></p>
<p>1.审美自由主义（aesthetic-liberalism）阵营。这一阵营里的人哀叹：即使绝大多数民众有自由选择的权利，他们仍然更加青睐所谓二流和三流的文化文本与实践，而对高雅文化的文本和实践置之不理。<br></p>
<p>2.企业自由主义（corporate-liberalism）或进步主义—进化主义（progressive-evolutionism）阵营。这一阵营里的人认为，大众文化发挥着温和的社会化功能，它使人们逐渐适应由新兴资本主义消费社会带来的消费愉悦。<br></p>
<p>3.激进主义或社会主义阵营。激进主义者和社会主义者视大众文化为一种社会控制的形式或工具。<br></p>
<p>在20世纪50年代末之前，前两大阵营在争论中占尽优势，这体现了麦卡锡主义 [3] （McCarthyism）在关涉社会主义的问题上所制造的日益强大的压力。<br></p>
<p>若想理解这场讨论的实质，有一部文献是必须阅读的，那就是出版于1957年的论文集《大众文化：美国的流行艺术》（Mass Culture: The Popular Arts in America ）。<br></p>
<p>伯纳德·罗森伯格（Bernard Rosenberg）（他与大卫·曼宁·怀特［David Manning White］同为该书的主编）声称，富庶、安定的美国社会正在遭遇来自群氓文化的非人性的破坏。他最大的担忧在于：“最糟糕的是，群氓文化不仅威胁到我们的审美趣味，更会铺设一条通向冷酷无情的独裁主义的道路”（Rosenberg, 1957: 9）。他还认为，群氓文化既不是美国土生土长的文化，也不是民主制度的必然结果。其开创者不是资本主义，而是科技。因此，美国不应该为群氓文化的出现和蔓延负责。<br><br>怀特也发表了类似的观点，但出于不同的目的。他指出：“群氓文化的批评者对美国当代社会持有一种过度悲观的看法”（White, 1957: 13-14）。他通过将美国的（群氓）文化与过去的大众文化的某些方面做比较，来为当代文化辩护。他坚持认为，批评家是在通过美化过去的方式来对当下进行攻击，并谴责那些“视美国文化为洪水猛兽，却忘记了在莎翁剧作刚刚问世的那个时代日常文化的残暴现实的人”（同上）。<br></p>
<p>德怀特·麦克唐纳（Dwight Macdonald）是这场讨论中的关键人物。他在一篇题为《大众文化理论》（“A Theory of Mass Culture”）的著名文章中，对群氓文化展开了全方位的攻击。<br></p>
<p>欧内斯特·凡·登·海格（Ernest van den Haag）。他提出：大众文化是大众社会（mass society）和大众化生产（mass production）的必然结果。大众生产的商品尽管在一定程度上反映了所有人的品位，却决然无法让每一个人都完完全全得到满足。这便造成了侵犯，也就是“品位的蓄意贬值”理论未曾解释清楚的问题（Haag, 1957: 512）。<br><br>凡·登·海格还指出了另一个关键之处，那就是群氓文化对高雅文化的诱惑。群氓文化有两个地方非常吸引人：（1） 经济上的回报；（2） 巨大的潜在受众群。<br><br>凡·登·海格注意到美国消费文化的文本与实践的多元性；同时他发现高雅文化和民间文化正在被群氓文化所吞噬；其结果就是，人们开始如消费群氓文化一样消费它们。“没人阅读经典，这既不新鲜也不可怕；可怕的是如此多的人正在误读经典”（528）。最后，凡·登·海格不禁断言，群氓文化是一剂“削弱人们体验生活的能力的毒药”（529）。归根结底，群氓文化乃是枯竭的象征，它标志着生活的去个性化（de-individualization）。<br></p>
<p>爱德华·希尔斯（Edward Shils）可不像凡·登·海格那样疑虑重重。他认为，凡·登·海格所言之“工业文化使生活变得贫乏”简直是一派胡言：<br></p>
<p>尽管当下工人阶级和下层中产阶级所追求的快感毫无深刻的美学、道德与知识价值，但在那些从中世纪起一直到19世纪持续不断地给他们的欧洲祖先带来快感的邪恶之物 [9] 面前，这两个阶级没什么可羞耻的（Shils, 1978: 35）。<br></p>
<p>希尔斯认为：</p>
<p>那些指责大众文化为导致20世纪知识颓败的罪魁祸首的想法是完全错误的……事实上，在过去的那几个晦暗、残酷的世纪里，下层阶级所遭受的迫害远比今日的大众文化带来的多（36）。<br></p>
<p>希尔斯认为大众文化是无辜的，问题出在知识阶层对大众文化的反应上。<br></p>
<p>在《两头不讨好的中间派》（“The Middle against Both Ends”）一文中，莱斯利·菲德勒（Leslie Fiedler）提出了与其他人不尽相同的观点：<br></p>
<p>（大众文化）是一种美国特有的现象……并不是说……只有在美国才能发现大众文化，而是说无论哪个地方的大众文化都是从美国传过去的；而且，这些文化样式只有在美国才能得到充分的发展。对于世界上其他地方的人来说，我们的经验就是对古老贵族文化土崩瓦解的预演。这个过程是不可避免的，谁也逃不掉（Fiedler, 1957: 539）。<br></p>
<p>对菲德勒来说，大众文化就是流行文化，对这种文化应“不问出处”。他解释道：</p>
<p>当代的平民文化既野蛮又混乱。这种“准文化”乃是无数城市中那些惨遭驱逐且文化贫乏的居民的一种自发的表达。面对来自科学的威胁和无休止的战争恐慌，面对古老的忠贞与英雄主义早已毁灭殆尽的腐化堕落的世界，他们只能去创造一些无关痛痒的神话（540）。</p>
<p>菲德勒提出的问题是：美国大众文化究竟出了什么问题？对于国内外的一些批评家而言，美国就是罪魁祸首。但菲德勒认为，美国经验的不可避免性决定了这一说法是毫无意义的，除非这些人连工业化、大众教育和民主制度也一并批判。他指出，美国“身处一场奇怪的、拥有两条阵线的阶级战争之间”。社会的中央是“假斯文的中产精神”，其上是“冷嘲热讽的贵族意识”，其下则是“野蛮的群氓心态”（545）。对大众文化的攻击其实是胆怯的表现，更是一种旨在消弭文化差异的企图。“（中产阶级）对平民文化和高雅文化的恐惧在本质上是相同的，那就是对文化差异的恐惧，这体现了中产阶级旨在让所有文化都变成羞怯、伤感、无知、空幻、装模作样的中产阶级文化的企图”（547）。“假斯文的中产精神”想要的文化平等其实就等于中产阶级文化一家独大。这可不是利维斯主义者所鼓吹的“文化驯服”，而是要将文化差异坚决地推上绝路。故而，菲德勒称，美国的大众文化是有层次、多元化的，而非同质化、等级制的，这一切都让他欢欣鼓舞。</p>
<h3 id="其他人的文化"><a href="#其他人的文化" class="headerlink" title="其他人的文化"></a>其他人的文化</h3><p>“文化与文明”传统）在很大程度上是“有文化的人”对“没文化的人”的文化发表的看法……这些“有文化的人”在研究大众文化的时候采取了疏远和审慎的态度，他们只是大众文化的局外人，对大众文化既无好感，也绝不会参与其中。对于这些人来说，大众文化永远只是“其他人”的文化（同上）。</p>
<h3 id="拓展阅读-1"><a href="#拓展阅读-1" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>Storey, John (ed.), Cultural Theory and Popular Culture: A Reader , 4th edition, Harlow: Pearson Education, 2009.该书是本书的配套阅读材料，其中收录了本书所涉之大多数重要文献。本书及其配套读本得到了互动式网站<a href="http://www.pearsoned.co.uk/storey%E7%9A%84%E6%94%AF%E6%8C%81%E3%80%82%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86%E8%AE%B8%E5%A4%9A%E6%9C%89%E7%94%A8%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%94%B5%E5%AD%90%E8%B5%84%E6%BA%90%E3%80%82">www.pearsoned.co.uk/storey的支持。该网站中包含了许多有用的链接与电子资源。</a></p>
<p>Baldick, Chris, The Social Mission of English 1848—1932 , Oxford: Clarendon Press, 1983.本书中有一些章节对阿诺德和利维斯主义进行了有趣而令人信服的介绍。【37】</p>
<p>Bilan, R.P., The Literary Criticism of F.R.Leavis, Cambridge: Cambridge University Press, 1979.尽管作者仅把利维斯当作一位文学批评家来研究，但书中仍涉及了利维斯关于高雅文化和大众文化的观点。</p>
<p>Bramson, Leon, The Political Context of Sociology , Princeton, NJ: Princeton University Press, 1961.书中有一章对美国的大众文化大讨论进行了介绍，极富启发性。</p>
<p>Gans, Herbert J., Popular Culture and High Culture: An Analysis and Evaluation of Taste , New York: Basic Books, 1974.该书尽管初版年份较晚，但仍是对美国大众文化大讨论的一种参与。书中对文化多元主义的支持十分具有说服力。</p>
<p>Johnson, Lesley, The Cultural Critics , London: Routledge &amp; Kegan Paul, 1979.书中一些章节对阿诺德和F.R.利维斯的介绍对研究者很有帮助。</p>
<p>Mulhern, Francis,The Moment of Scrutiny, London: New Left Books, 1979.这是一部关于利维斯主义的经典著作。</p>
<p>Ross, Andrew, No Respect: Intellectuals and Popular Culture , London: Routledge, 1989.这是一本读起来很有趣的书，其中有一章是关于美国大众文化大讨论的，提供了很多有用的信息。</p>
<p>Thrilling, Lionel, Matthew Arnold , London: Unwin University Press, 1949.本书是目前为止关于阿诺德的最好的介绍性读物。</p>
<p>Waites, Bernard, Tony Bennett and Graham Martin (eds), Popular Culture: Past and Present, London: Croom Helm, 1982.这本论文集通过许多不同的案例来展开对大众文化的讨论。第一章、第四章和第六章对大众文化以及催生了“文化与文明”传统的焦虑感的历史语境进行了考察。</p>
<p>Williams, Raymond, Culture and Society , Harmondsworth: Penguin, 1963.本书是对“文化与文明”传统展开批评的奠基之作，其中有些章节是关于阿诺德和F.R.利维斯的。</p>
<h2 id="第三章-文化主义"><a href="#第三章-文化主义" class="headerlink" title="第三章 文化主义"></a>第三章 文化主义</h2><h3 id="理查德·霍加特：《识字的用途》"><a href="#理查德·霍加特：《识字的用途》" class="headerlink" title="理查德·霍加特：《识字的用途》"></a>理查德·霍加特：《识字的用途》</h3><p>《识字的用途》一书包括两个部分。第一部分题为“古老秩序”，描绘了作者的童年时期，即20世纪30年代的工人阶级文化。第二部分题为“新的转变”，讲述传统工人阶级文化如何在20世纪50年代遭遇大众娱乐的威胁。这种行文方式其实已经揭示了作者看待问题的角度和期望得出的结论——一边是20世纪30年代的“活文化”传统，另一边则是50年代的文化衰落。<br>霍加特（在20世纪50年代）坚称：</p>
<p>我们正在进入群氓文化时代；而在某种程度上，代价就是一种“属于人民的”都市文化的毁灭。崭新的群氓文化远比被它赶走的那种“天然的文化”有害（24）。<br>《识字的用途》一书的前半部分对上述观点的阐述是很不充分的，其论证过程缺乏学术性，几乎就是一部充满怀乡之情的自传。很多人对此嗤之以鼻。而我认为，该书的致命之处在于霍加特未能以看待20世纪30年代大众文化的宽容态度来看待50年代的所谓群氓文化。</p>
<h3 id="雷蒙德·威廉斯：“文化分析”"><a href="#雷蒙德·威廉斯：“文化分析”" class="headerlink" title="雷蒙德·威廉斯：“文化分析”"></a>雷蒙德·威廉斯：“文化分析”</h3><p>威廉斯概括了“文化的三种定义类别”（Williams, 2009: 32）。第一种定义认为文化“是‘理想’的，意指人类的某种尽善尽美的状态或过程，以某种绝对真理或普世价值的状态存在”（同上）。<br>文化的第二种定义强调其“记录”的功能，意指某种文化的现存的文本与实践。<br>第三种定义“强调文化的‘社会性’：文化是对某种特定的生活方式的描述”（同上）。</p>
<p>某一社会的传统文化必然是与该社会的现行利益与价值观机制密切相关的，它并不是个确切的实体，而是始终处于持续不断的选择和阐释之中（2009: 38-39）。</p>
<h3 id="E-P-汤普森：《英国工人阶级的构成》"><a href="#E-P-汤普森：《英国工人阶级的构成》" class="headerlink" title="E.P.汤普森：《英国工人阶级的构成》"></a>E.P.汤普森：《英国工人阶级的构成》</h3><p>《英国工人阶级的构成》是“自下而上的历史”的典范之作。<br>在汤普森看来，英国工人阶级和其他阶级一样，是一种“历史 现象”。工人阶级既不是一种“结构”，也不是一个“范畴”，而是“原始物质经验和人类意识领域中所有异质的、貌似互不相干的大量事物的总和”，“生发于人与人的相互关系中”。<br>此外，工人阶级也不是一个特定的“事物”，而始终是“联合”与“差异”之间的某种历史关系，即，将一个阶级的全体成员联合起来，去反抗其他阶级。诚如汤普森所言：“阶级的形成是（继承或共享的）共同经验的结果。当拥有共同经验的人为捍卫其集体身份与利益而与那些拥有不同（常常是相反）利益的人展开斗争时，阶级就诞生了”（8-9）。某一阶级的共同经验“在很大程度上是由生产关系决定的；而每个人都隶属于某种生产关系，要么从降生便在其中，要么后天不知不觉地加入其中”（9）。但是，阶级意识和从经验到文化的转变过程则是由“亲历历史的人所主导的；而这，就是阶级的唯一定义”（10）。对汤普森而言，阶级“既是一种社会形式，也是一种文化形式；其形成则是一个漫长的历史过程”（11）。</p>
<h3 id="斯图亚特·霍尔与派迪·维诺：《大众艺术》"><a href="#斯图亚特·霍尔与派迪·维诺：《大众艺术》" class="headerlink" title="斯图亚特·霍尔与派迪·维诺：《大众艺术》"></a>斯图亚特·霍尔与派迪·维诺：《大众艺术》</h3><p>《大众艺术》的一个意图，在于通过培养大众对于大众文化和其他文化的分辨力来替代因早期理论家对大众文化的攻击所形成的“误导性的原则”。与其对大众文化的“影响力”忧心忡忡，不如“去培养更具鉴赏品位的受众”（35）。</p>
<h3 id="当代文化研究中心-霍加特"><a href="#当代文化研究中心-霍加特" class="headerlink" title="当代文化研究中心:霍加特"></a>当代文化研究中心:霍加特</h3><p>文化主义者研究文化文本与文化实践，旨在还原或重建特定群体或阶级或整个社会的“感知结构”，包括他们的经验、价值观，等等。其目的，就在于更好地理解那些亲历了文化的人们的生活。</p>
<h3 id="拓展阅读-2"><a href="#拓展阅读-2" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>Storey, John (ed.), Cultural Theory and Popular Culture: A Reader , 4th edition, Harlow: Pearson Education, 2009.该书是本书的配套阅读材料，其中收录了本书所涉之大多数重要文献。本书及其配套读本得到了互动式网站<a href="http://www.pearsoned.co.uk/storey%E7%9A%84%E6%94%AF%E6%8C%81%E3%80%82%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86%E8%AE%B8%E5%A4%9A%E6%9C%89%E7%94%A8%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%94%B5%E5%AD%90%E8%B5%84%E6%BA%90%E3%80%82">www.pearsoned.co.uk/storey的支持。该网站中包含了许多有用的链接与电子资源。</a></p>
<p>Chambers, Iain, Popular Culture: The Metropolitan Experience , London: Routledge, 1986.这是一本有趣且内容丰富的概览性著作。作者的视角基本上是文化主义的，他所考察的对象是自19世纪80年代开始的城市大众文化的兴起过程。</p>
<p>Clarke, John, Chas Critcher and Richard Johnson (eds), Working Class Culture: Studies in History and Theory , London: Hutchinson, 1979.本书收录了一些从文化主义角度撰写的文章。请重点阅读理查德·约翰逊的《关于工人阶级文化理论要素的三点问题》。</p>
<p>Eagleton, Terry (ed.), Raymond Williams: Critical Perspective , Cambridge: Polity Press, 1989.本书收录了一些对威廉斯的著作进行批判性解读的文章。</p>
<p>Hall, Stuart and Tony Jefferson (eds), Resistance through Rituals , London: Hutchinson, 1976.本书是当代文化研究中心进行青年亚文化研究的代表性成果。本书的第一章就是一篇文化主义理论的经典论述。【60】</p>
<p>Hall, Stuart, Dorothy Hobson, Andrew Lowe and Paul Willis (eds), Culture, Media, Language , London: Hutchinson, 1980.本书是一部论文汇编，在时间上几乎涵盖了当代文化研究中心成立前十年里发表的所有成果。请阅读由霍尔撰写的第一章，题为“文化研究与当代文化研究中心：问题域与问题”。本文详述了当代文化研究中心的理论发展历程。</p>
<p>Jones, Paul, Raymond Williams‘ Sociology of Culture: A Critical Reconstruction , Basingstoke: Palgrave, 2004.这是一部很有趣的著作。只不过作者过于强调威廉斯对社会学的贡献，未能正确认识其在文化研究中的地位。</p>
<p>Kaye, Harvey J.and Keith McClelland (eds), E.P.Thompson: Critical Perspectives , Oxford: Polity Press, 1990.本书收集了多篇论文，评述汤普森为历史研究做出的贡献，为《英国工人阶级的构成》一书提供了一些有益的注脚。</p>
<p>O‘Connor, Alan (ed.), Raymond Williams: Writing, Culture, Politics , Oxford: Basil Blackwell, 1989.本书对威廉斯的著作进行了批判性的检视。此外，本书列出的参考文献十分有价值。</p>
<h2 id="第四章-马克思主义"><a href="#第四章-马克思主义" class="headerlink" title="第四章 马克思主义"></a>第四章 马克思主义</h2><h3 id="经典马克思主义"><a href="#经典马克思主义" class="headerlink" title="经典马克思主义"></a>经典马克思主义</h3><p>马克思本人有句名言：“哲学家们只是用不同的方式解释 世界，问题在于改变世界”（Marx, 1976b: 65）。<br>马克思主义强调世间万物归根结底都是政治的。</p>
<h3 id="威廉·莫里斯与英国马克思主义"><a href="#威廉·莫里斯与英国马克思主义" class="headerlink" title="威廉·莫里斯与英国马克思主义"></a>威廉·莫里斯与英国马克思主义</h3><p>换言之，在消除了异化的共产主义社会，全人类都可以如艺术家一样劳动：一切工作都是创造性的，因而最终都会在实际上生产出大众文化。</p>
<h3 id="法兰克福学派"><a href="#法兰克福学派" class="headerlink" title="法兰克福学派"></a>法兰克福学派</h3><p>学派的若干位知名学者，包括西奥多·阿多诺、瓦尔特·本雅明（Walter Benjamin）、马克斯·霍克海默（Max Horkheimer）、利奥·洛文塔尔（Leo Lowenthal）和赫伯特·马尔库塞（Herbert Marcuse）等，都对大众文化进行过专门的研究。<br>法兰克福学派学者眼中却只有人们对权力阶级的“遵从”：在这种情况下，“被蒙蔽的大多数”（133）被困在一个“循环往复的操纵性的怪圈里，而整个系统的一致性也就日益增强”（121）。</p>
<p>利奥·洛文塔尔认为，文化工业生产出来的文化具有“标准化、模式化、保守、虚幻等特征，是极具操纵性的消费品”（Lowenthal, 1961: 11）。</p>
<p>赫伯特·马尔库塞在《单向度的人》（One Dimensional Man ）一书中所论述的那样：</p>
<p>娱乐和信息工业（文化工业）生产出来的东西是令人难以抗拒的，因其蕴含着某种预设的观念和习俗，通过激发精神上或情感上的反应将“心甘情愿的”消费者和文化的生产者绑定在一起；进而，文化的受众也就被纳入了整个资本主义体系。这些文化产品向人们灌输着某种虚假意识，操纵着人们的思想，让大众无法看清其欺骗性……这已经成了一种生活方式。这是一种很“好”的生活方式，至少比以前好。在这种生活方式之下，绝不会发生任何质变。因此，就出现了一种单向度的思维与行为模式，那些试图超越既有话语和行为范畴的观念、愿望和理想，要么被摒弃，要么被纳入现存的体系（Marcuse, 1968a: 26-27）。</p>
<p>换言之，资本主义通过满足大众的某些需求而消解了人们心底的更为基本的愿望。在此，文化工业阻碍了政治理想的生发。</p>
<p>“同化作用是一种极不成熟的历史现象；它所建立的文化平等实际上维护了统治阶级的利益”（Marcuse 1968a: 64）。简言之，文化的民主化进程反而扼杀了充分的民主，成为现行社会秩序的卫道士。</p>
<p>《论流行音乐》（“On Popular Music”）做一番深入分析。在文章中，阿多诺指出流行音乐具有三个主要特征。第一，流行音乐是“标准化”的音乐。“标准化”使得“那些即使是最独特的东西也变得乏善可陈”（Adorno, 2009: 64）。一旦某种音乐或歌词风格受到欢迎，这种风格就会遭到商业的滥用，造成的结果就是“标准的结晶化”（同上）。歌</p>
<p>流行音乐的第二个特征是：它使得听音乐变成了一个消极被动的过程。前文曾经提到过，资本主义制度下的劳动是极为枯燥的，因此每个人都在想方设法逃避现实。但是，由于这种劳动使人非常疲惫，所以没有人真正有本事“逃出去”；也就是说，没有人有精力去追求什么“本真”文化。于是，流行音乐就成了人们心灵的庇护所。对流行音乐的消费是不得已而为之的，而且是日复一日没有止境的。这种消费确保世界始终保持着现状 。“</p>
<p>流行音乐的第三个特征，是它发挥了“社会黏合剂”的作用（72），其“社会心理功能”在消费者心中成功制造出了一种对既有权力结构需求的“心理适应性”（同上）。这种“适应性”主要体现为“两种主要的群体行为的社会心理类型，即‘节奏性’顺从型和‘情感型’”（同上）。前者使人们在一定的节奏中忽略自己所遭受的剥削和压迫，后者则让大众心甘情愿地忍受现实生存环境所带来的情感痛苦。</p>
<p>我们必须清楚，《论流行音乐》一文发表于1941年，而现在的情况与70年前不可同日而语:比如说，“个人化理论”是否可以解释1956年摇滚乐的诞生、1962年甲壳虫乐队（The Beatles）的横空出世，以及1965年反传统音乐文化的勃兴？又是否可以解释20世纪70年代的朋克摇滚 [3] （punk rock）和“摇滚对抗种族主义” [4] （Rock Against Racism）运动、80年代的迷幻豪斯 [5] （acid house）和独立流行乐 [6] （indie pop），以及90年代的锐舞派对 [7] （rave）和嘻哈音乐 [8] （hip hop）？</p>
<h3 id="阿尔都塞主义"><a href="#阿尔都塞主义" class="headerlink" title="阿尔都塞主义"></a>阿尔都塞主义</h3><p>从一开始，阿尔都塞就反对那些关于经济基础和上层建筑的机械式的误读，他把注意力集中在社会结构上。他指出，社会结构包括三种实践，分别是经济实践、政治实践和意识形态实践（1969）。</p>
<p>阿尔都塞症候式解读方法</p>
<p>皮埃尔·马施立所著之《文学生产理论》（A Theory of Literary Production ）无疑是采用阿尔都塞症候式解读方法对文化文本进行分析的典范。尽管如标题所示，马施立的主要分析对象是文学作品，但他对文本分析方法的发展引发了大众文化研究者的浓厚兴趣。<br>在他看来，文本并不是掩藏着一种意义的谜题，而是多重含义建构的结果。要想对文本进行“解释”，就必须认清这一点。这同时意味着文本并不是一个和谐的、从某个核心意图出发盘旋式前进的整体。恰恰相反，文学文本是“离心的”（decentred），是残缺不全的。<br>当然，这并不是说我们需要为文本添加一些东西而使之更加完整。马施立所谓的“离心”（不以某个权威的意图为中心）指的是文本之中往往包含了若干互相冲突的话语：明确的、隐含的、呈现的、缺席的。因此，批评实践的使命并不在于评析文本的内在一致性、和谐整体性和审美调和性，而在于阐释文本内部因意义冲突而产生的种种差异。</p>
<p>这种冲突并不是文本的缺陷；它揭示了在文学作品中存在着“他者”，而文本正是通过这种方式与自身的边缘和自身之外的世界维持着关联。对文学作品进行解读就是要揭示其非独立性，并时刻牢记在文本的物质实在之中包含着某种确定的缺席 的痕迹；这种缺席同样是文本自身不可或缺的特性之一。比如说，这本书所表达的观点并不仅仅体现在这本书自身之中，还隐含地包括了其他反对本书观点的著作的在场；文本是围绕着不可言传的缺席之物建立起来的，某些为文本所压抑的词句时刻威胁着文本，试图“卷土重来”。因此，这本书并不是某一种意义的延伸，而是包含了若干种意义的矛盾体；而正是通过这种剑拔弩张且连绵不断的矛盾、冲突，本书将自己与现实牢牢地绑在了一起（Macherey, 1978: 79-80）。【78】【79】</p>
<p>获取知识的行为并不似聆听业已存在的话语，也不似简单翻译一部纯粹的小说。这种行为更像是对某种新话语的发掘，或是打破某种缄默的状态。知识并不是对某一种潜在的、被遗忘或隐藏的意义的发现或重建，而是一种新生事物，是从头到尾对现实进行的补充（6）。</p>
<p>在对法国科幻小说家儒勒·凡尔纳 [2] （Jules Verne）的作品进行分析的时候，马施立察觉到那些小说中蕴含着19世纪晚期法兰西帝国主义的矛盾。他指出，凡尔纳的小说对帝国主义扩张和全球殖民的意识形态进行了精彩的 展示，每一个探险故事都体现了主人公对大自然（如某个神秘岛屿、月球、海底、地心，等等）的征服。</p>
<p>在阿尔都塞所下的第二个定义中，意识形态仍然是个体与真实的生存环境之间想象性关系的表征，但意识形态并不仅仅是一系列观念的集合，还是一种活的物质实践，是仪式、风俗、行为模式、思维方式的实践形态，是由意识形态国家机器（Ideological State Apparatuses, ISAs）生产出来的。而所谓意识形态国家机器，包括教育、宗教、家庭、政治、传媒、文化工业等范畴。在这一定义下，“一切意识形态都有将独特个体‘建构’成对象的功能（意识形态的概念正是被这一功能界定的）”（Althusser, 2009: 309）。意识形态的对象是通过“召唤”（hailing）和“质询”（interpellation）被生产出来的。阿尔都塞举了一个例子来做类比。</p>
<p>茱迪丝·威廉森（Judith Williamson）的那部影响深远的广告研究著作《解码广告》（Decoding Advertisements ）就是在阿尔都塞为意识形态所下的第二个定义的基础上展开的。她指出，所有广告都带有意识形态的意味，因为它们都展现了我们与真实生存环境之间的想象性关系。广告强调的并不是基于人们在生产过程中扮演不同角色而产生的阶级差异，而是人们在对特定产品进行消费的过程中产生的差异。于是，社会身份就成了我们消费什么的问题，而不是我们生产了什么的问题。如其他意识形态一样，广告也具有质询的功能：消费者受到质询之后，不但要生产意义，还要一而再再而三地购买和消费。</p>
<p>不过，阿尔都塞为意识形态所下的第二个定义及其在文化理论中的应用似乎显得过于理想化了。在阿尔都塞看来，由资本主义生产方式所决定的必需的意识形态习性对人类的再生产过程总是非常顺利的，绝对不会失败，更不会产生什么冲突、斗争和抵抗。不过单就大众文化领域而言，难道广告总是能够成功地将我们“质询”为消费的对象吗？更重要的是，纵使“质询”真的起作用，难道过去的“质询”就不会与当下的“质询”产生冲突吗？</p>
<h3 id="霸权"><a href="#霸权" class="headerlink" title="霸权"></a>霸权</h3><p>葛兰西对文化研究做出的最大贡献就是提出了“霸权”这个概念，他用这个概念来解释（在资本主义制度的剥削和压迫之下）为何西方资本主义民主国家之内无法产生社会主义革命。在葛兰西看来，所谓“霸权”指的是某种进行中的状况 ，它描述了统治阶级（连同其他相关阶级或阶级成分）通过操纵“精神及道德领导权”的方式对社会加以引导 而非统治 的过程（Gramsci, 2009: 75）。在霸权之中包含了一种特殊的共识，即某个社会群体想方设法将自己的特定利益展示为整个社会的整体利益。于是，尽管社会之中始终存在着剥削和压迫，但各个阶级之间达成了高度的共识，彼此和谐相处；被统治阶级似乎服膺于“共同的”价值、观念、目标，以及文化和政治内涵，并以此种方式被既有的权力结构“收编”（incorporate）。</p>
<p>霸权理论拓展了大众文化研究者的视野，很多用过去的分析方法无法阐释的问题如今迎刃而解。从此，大众文化不再是一成不变的自上而下强加的文化（法兰克福学派），不再是社会衰落与腐朽的象征（“文化与文明”传统），不再是自下而上自然生发出来的文化（文化主义的某些观点），也不再是主观强加于被动对象的表意机器（结构主义的某些观点）。在霸权理论的观照下，大众文化乃是一种“上”与“下”、“商业”与“本真”之间彼此“协商”产生的混合物，是平衡着“抵抗”与“收编”两股力量的不稳定的“场”。</p>
<h3 id="后马克思主义与文化研究"><a href="#后马克思主义与文化研究" class="headerlink" title="后马克思主义与文化研究"></a>后马克思主义与文化研究</h3><p>安吉拉·麦克罗比（Angela McRobbie）所指出的那样，马克思主义对文化研究的影响已经不及此前那样显著了：</p>
<p>马克思主义一度是英国文化研究最主要的理论体系，如今却面临着来自后现代主义批评家的质疑。他们认为马克思主义带有目的论色彩，质疑其宏大叙事、实在论、经济主义、欧洲中心主义，及其在整个启蒙运动中的地位（McRobbie, 1992: 719）。</p>
<p>不过她也声称：“弗雷德里克·詹明信和大卫·哈维（David Harvey）等批评家对‘回归后现代之前的马克思主义’的呼吁也是站不住脚的，因为这意味着将经济关系和经济决定论凌驾于文化与政治关系之上……”（同上）然而，正如霍尔指出的那样，在某种意义上，文化研究始终属于后马克思主义的范畴（Hall, 1992: 279）。</p>
<p>后马克思主义”这个概念至少有两种含义。欧内斯托·拉克劳（Ernesto Laclau）和尚塔尔·墨菲（Chantal Mouffe）合著之《霸权与社会主义战略：通向激进民主政治之路》（Hegemony and Socialist Strategy: Towards a Radical Democratic Politics ）对后马克思主义产生了深远的影响。在书中，作者指出：“如果说本书的主题是‘后 马克思主义’的，那它同时也必然是‘后马克思主义 ’的”（Laclau and Mouffe, 2001: 4）。前者意味着超越马克思主义，去寻找一套更好的理论体系；而后者主张对马克思主义进行修正，用女性主义、后现代主义、后结构主义和拉康精神分析学说等前沿理论成果来丰富马克思主义的内涵。</p>
<p>“话语”（discourse）这个概念在后马克思主义的发展过程中扮演了中心角色。诚如拉克劳所言：“这一论断的基本假设是，很有可能人们的一切感知、思维和行动都依赖于某一特定的意义领域的结构化形成，而这一领域先于一切即刻事实（factual immediacy）存在”（Laclau, 1993: 431）。</p>
<p>“接合”是后马克思主义文化研究的关键词。拉克劳与墨菲指出：“接合的实践存在于……对意义的局部固定（partial fixing）之中”（Laclau and Mouffe, 2001: 113）。霍尔（1996b）对这一概念进行了扩展，用以解释文化是如何为意识形态斗争提供场所的。像拉克劳与墨菲一样，霍尔也认为文本和实践并非先天就具有意义，意义的产生始终是接合活动的结果：“意义是一种社会产物，是一种实践；世界之所以有意义，完全是人为的结果 ”（Hall, 2009a: 121）。他还援引俄国理论家弗洛西诺夫（Valentin Voloinov）的观点，称文本和实践是“多重音的”（multi-accentual），即文本和实践可以被不同的人、在不同的社会情境之下、出于不同的政治目的、以不同的话语、操不同的“口音”来“言说”（Voloinov, 1973）。</p>
<h2 id="第五章-精神分析"><a href="#第五章-精神分析" class="headerlink" title="第五章 精神分析"></a>第五章 精神分析</h2><h3 id="弗洛伊德精神分析学说"><a href="#弗洛伊德精神分析学说" class="headerlink" title="弗洛伊德精神分析学说"></a>弗洛伊德精神分析学说</h3><p>西格蒙德·弗洛伊德（Sigmund Freud）认为文明的创造力必然导致人类本能的压抑。他还声称：“每一个新进入人类社会的个体都不得不为了整个社区的利益而一再牺牲对本能的满足”（Freud, 1973a: 47）。最重要的本能驱动力就是性，而文明的存在使得人类的性本能在无意识（unconscious）的过程中得到“升华”：</p>
<p>也就是说，那些原本出于性欲的目的而存在的本能发生了转变，变得更加“高尚”，失尽了性的因素。然而，这一机制是极不稳定的，因为性驱动力是很难被完全驯服的。当一个人下定决心通过自我压抑的方式融入社会文明，他的性本能却极有可能成为阻碍。对于社会来说，文明最大的敌人莫过于性本能的充分释放和回归（47-48）。 [1]</p>
<p>他第一次将人的心灵分成两个部分：“意识”和“无意识”。前者联结着个体与外部世界，后者则容纳了人类的种种本能的驱动和被压抑的欲望。在此基础上，弗洛伊德还提出了“前意识”（preconscious）的概念——当我们在特定时刻无法记得某件事情，但经过冥思苦想之后又可以回忆起来，那么这件事情就存在于我们的前意识当中。存在于无意识里的东西时刻处于审查与反抗的张力之中，只能通过扭曲的方式被表达出来，而我们是无法将无意识的内容原封不动地转移到意识里面的。 [2] 最终，弗洛伊德通过三个术语对人类的精神世界做出了划分：自我（ego）、超我（super-ego）和本我（id）。这三个词的德语原文分别是Ich（我）、über-Ich（超我）和es（它）。</p>
<p>本我是人类存在（being）中的最原始的部分，是“我们只遵循自然法则的非人格化的天性”（1984: 362），是“我们人性之中最黑暗、最艰于触摸的部分……无比混乱，仿佛是充满沸腾的刺激的巨大汽锅……尽管始终在激发蠢蠢欲动的本能之力，但不服从任何既定规则和集体意愿……它的一切目的就是遵循快乐原则（pleasure principle），想尽办法满足本能的需求”（1973b: 106）。</p>
<p>自我是本我的一个部分，是被外部世界直接影响并加以改造后的本我……更重要的是，自我借助外部世界的力量压抑本我，遏制其发展，并试图使现实原则（reality principle）凌驾于在本我内部滋生蔓延的快乐原则之上……自我在外部表现为我们常说的理性和常识，与激情四溢的本我形成鲜明的对比（363-364）。</p>
<p>超我是在俄狄浦斯情结（the Oedipus complex）（在后文中会详细讨论）消解的过程中出现的。起初，超我的出现是孩童对父母的权威——尤其是父亲的权威——加以内化（internalization）和内投（introjection）的结果。</p>
<p>弗洛伊德认为梦始终是一种“妥协结构”（compromise-structure）（48）。<br>梦主要活动在两个层面上，分别是潜在的梦幻意念（无意识）与外显的内容（做梦者醒来之后可以记得住的那一部分内容）。<br>梦的运作”（dream-work）（Freud, 2009: 246），其中包括四个步骤，分别是凝缩（condensation）、移情（displacement）、象征（symbolization）与次级修正（secondary revision）。<br>将弗洛伊德的精神分析学说应用于文本分析，至少可以有两种方式。第一种方式以作者为中心，将文本等同于作者的梦境。<br>第二种文本分析方式以读者为中心，可以被视为由“作者中心论”衍生出来的分析方法。</p>
<h3 id="拉康精神分析学说"><a href="#拉康精神分析学说" class="headerlink" title="拉康精神分析学说"></a>拉康精神分析学说</h3><p>拉康认为，我们从出生那天起，就处于 “匮乏”（lack）的状况之中，而我们终其一生都在不断地想方设法克服这一状况。</p>
<p>拉康指出，我们在成长过程中总共经历了三个重要阶段。最初是“镜像阶段”（mirror stage），之后是“去—来游戏”（“for-da”game），最后才是“俄狄浦斯情结”。</p>
<p>“俄狄浦斯情结”告诉我们：</p>
<p>儿童现在必须直面现实：已经永不可能与……禁忌的母体……产生任何直接的关联了……渡过俄狄浦斯危机之后，我们便永远不能企及这一珍贵的客体了，尽管我们会穷尽一生的光阴不断地寻找它。我们不得不“委身于”种种替代性的客体……想尽办法弥合自身存在之中的巨大罅隙，却只能一次又一次地徒劳而返。我们从一个替代物漂向另一个替代物，从一个隐喻漂向另一个隐喻，却永远无法重获纯粹的（哪怕是想象性的）自我认同与自我满足……在拉康的理论体系中，正是“母体”这一元客体的失落驱动着我们生命的叙事，促使我们在欲望的无尽的换喻活动中毕生追寻着失落天堂的替代物（Eagleton, 1983: 167, 168, 185）。【109】</p>
<p>比如说，在言情类艺术作品的话语中，“爱”是一切问题的终极解决途径；这一过程就可被视为人类无休止地追寻母体之替代物的例子。言情类艺术作品其实是一种话语的实践（参见第六章对福柯的讨论以及第四章对后马克思主义的讨论），这种话语将“爱情”视为完善人类自身存在的终极要素。</p>
<h3 id="电影精神分析"><a href="#电影精神分析" class="headerlink" title="电影精神分析"></a>电影精神分析</h3><p>劳拉·墨维（Laura Mulvey）的论文《视觉快感与叙事电影》（“Visual Pleasure and Narrative Cinema”）或许是从女性主义精神分析视角对大众电影进行研究的经典之作。</p>
<p>在电影中，女性的形象通常具有双重属性：第一，男性欲望的对象；第二，阉割恐惧的能指。</p>
<p>大众电影生产了两种互相矛盾的视觉快感。首先是窥视的快感，其次是自恋的快感。两者之间的矛盾体现为：“在电影中，前者暗示了充满性欲的观影主体与银幕上出现的种种客体的分离；而后者通过让观众着迷的方式，使其将银幕上的那些与自己具有相似性的客体认同为另一个理想化的自我”（10）。</p>
<p>墨维得出结论：必须摧毁大众电影带来的快感，将女性从种种剥削和压迫中解放出来，不再扮演“（主动）男性凝视之（被动）原料”的角色（17）。</p>
<h3 id="斯拉沃热·齐泽克与拉康式幻想"><a href="#斯拉沃热·齐泽克与拉康式幻想" class="headerlink" title="斯拉沃热·齐泽克与拉康式幻想"></a>斯拉沃热·齐泽克与拉康式幻想</h3><p>齐泽克指出：“‘现实’乃是被幻想建构出来的，这种建构掩盖了欲望的实在界”（iek, 1989: 45）。<br>他指出，幻想的功能并非满足欲望，而是展示欲望。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>笔记</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>2022</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11newfunction</title>
    <url>/BassHero.github.io/2021/12/19/cpp11newfunction/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ol>
<li><p> 缩窄<br>char c1 {66}；</p>
</li>
<li><p>std::initializer_list用于函数参数<br>#include <initializer_list></p>
</li>
</ol>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><ol>
<li>auto用于简写声明</li>
<li>int n;<br>double x;<br>decltype(x*n) q;</li>
<li>模板别名using=<br>using itType = std::vector<a href="std::string">std::string</a>::iterator;<br>也可以用于模板具体化，但decltype不能<br>template<typename T> using arr12 = std::&lt;T,12&gt;</li>
<li>nullptr</li>
</ol>
<h4 id="智能指针unique-ptr-shared-ptr，weak-ptr"><a href="#智能指针unique-ptr-shared-ptr，weak-ptr" class="headerlink" title="智能指针unique_ptr,shared_ptr，weak_ptr"></a>智能指针unique_ptr,shared_ptr，weak_ptr</h4><h4 id="作用域内枚举"><a href="#作用域内枚举" class="headerlink" title="作用域内枚举"></a>作用域内枚举</h4><p>enum class New1{never,sometimes,often,always};<br>enum struct New2{never,lever,server};</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>ping</title>
    <url>/BassHero.github.io/2021/12/17/ping/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="built_in">import</span> pings</span><br><span class="line"></span><br><span class="line"><span class="attr">p</span> = pings.Ping(<span class="attr">quiet=False)</span></span><br><span class="line"><span class="attr">res</span> = p.ping(<span class="string">&quot;google.com&quot;</span>)  <span class="comment"># googleを監視</span></span><br></pre></td></tr></table></figure>
<h3 id="用python实现发送原生ping包"><a href="#用python实现发送原生ping包" class="headerlink" title="用python实现发送原生ping包"></a>用python实现发送原生ping包</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A pure python ping implementation using raw socket.</span></span><br><span class="line"><span class="string">    Note that ICMP messages can only be sent from processes running as root.</span></span><br><span class="line"><span class="string">    Derived from ping.c distributed in Linux&#x27;s netkit. That code is</span></span><br><span class="line"><span class="string">    copyright (c) 1989 by The Regents of the University of California.</span></span><br><span class="line"><span class="string">    That code is in turn derived from code written by Mike Muuss of the</span></span><br><span class="line"><span class="string">    US Army Ballistic Research Laboratory in December, 1983 and</span></span><br><span class="line"><span class="string">    placed in the public domain. They have my thanks.</span></span><br><span class="line"><span class="string">    Bugs are naturally mine. I&#x27;d be glad to hear about them. There are</span></span><br><span class="line"><span class="string">    certainly word - size dependenceies here.</span></span><br><span class="line"><span class="string">    Copyright (c) Matthew Dixon Cowles, &lt;http://www.visi.com/~mdc/&gt;.</span></span><br><span class="line"><span class="string">    Distributable under the terms of the GNU General Public License</span></span><br><span class="line"><span class="string">    version 2. Provided with no warranties of any sort.</span></span><br><span class="line"><span class="string">    Original Version from Matthew Dixon Cowles:</span></span><br><span class="line"><span class="string">      -&gt; ftp://ftp.visi.com/users/mdc/ping.py</span></span><br><span class="line"><span class="string">    Rewrite by Jens Diemer:</span></span><br><span class="line"><span class="string">      -&gt; http://www.python-forum.de/post-69122.html#69122</span></span><br><span class="line"><span class="string">    Revision history</span></span><br><span class="line"><span class="string">    ~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">    March 11, 2010</span></span><br><span class="line"><span class="string">    changes by Samuel Stauffer:</span></span><br><span class="line"><span class="string">    - replaced time.clock with default_timer which is set to</span></span><br><span class="line"><span class="string">      time.clock on windows and time.time on other systems.</span></span><br><span class="line"><span class="string">    May 30, 2007</span></span><br><span class="line"><span class="string">    little rewrite by Jens Diemer:</span></span><br><span class="line"><span class="string">     -  change socket asterisk import to a normal import</span></span><br><span class="line"><span class="string">     -  replace time.time() with time.clock()</span></span><br><span class="line"><span class="string">     -  delete &quot;return None&quot; (or change to &quot;return&quot; only)</span></span><br><span class="line"><span class="string">     -  in checksum() rename &quot;str&quot; to &quot;source_string&quot;</span></span><br><span class="line"><span class="string">    November 22, 1997</span></span><br><span class="line"><span class="string">    Initial hack. Doesn&#x27;t do much, but rather than try to guess</span></span><br><span class="line"><span class="string">    what features I (or others) will want in the future, I&#x27;ve only</span></span><br><span class="line"><span class="string">    put in what I need now.</span></span><br><span class="line"><span class="string">    December 16, 1997</span></span><br><span class="line"><span class="string">    For some reason, the checksum bytes are in the wrong order when</span></span><br><span class="line"><span class="string">    this is run under Solaris 2.X for SPARC but it works right under</span></span><br><span class="line"><span class="string">    Linux x86. Since I don&#x27;t know just what&#x27;s wrong, I&#x27;ll swap the</span></span><br><span class="line"><span class="string">    bytes always and then do an htons().</span></span><br><span class="line"><span class="string">    December 4, 2000</span></span><br><span class="line"><span class="string">    Changed the struct.pack() calls to pack the checksum and ID as</span></span><br><span class="line"><span class="string">    unsigned. My thanks to Jerome Poincheval for the fix.</span></span><br><span class="line"><span class="string">    Januari 27, 2015</span></span><br><span class="line"><span class="string">    Changed receive response to not accept ICMP request messages.</span></span><br><span class="line"><span class="string">    It was possible to receive the very request that was sent.</span></span><br><span class="line"><span class="string">    Last commit info:</span></span><br><span class="line"><span class="string">    ~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">    $LastChangedDate: $</span></span><br><span class="line"><span class="string">    $Rev: $</span></span><br><span class="line"><span class="string">    $Author: $</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> os, sys, socket, struct, select, time</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> sys.platform == <span class="string">&quot;win32&quot;</span>:</span><br><span class="line">    <span class="comment"># On Windows, the best timer is time.clock()</span></span><br><span class="line">    default_timer = time.clock</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># On most other platforms the best timer is time.time()</span></span><br><span class="line">    default_timer = time.time</span><br><span class="line"> </span><br><span class="line"><span class="comment">#From /usr/include/linux/icmp.h; your milage may vary.</span></span><br><span class="line">ICMP_ECHO_REQUEST = <span class="number">8</span> <span class="comment"># Seems to be the same on Solaris.</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checksum</span>(<span class="params">source_string</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    I&#x27;m not too confident that this is right but testing seems</span></span><br><span class="line"><span class="string">    to suggest that it gives the same answers as in_cksum in ping.c</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    countTo = (<span class="built_in">len</span>(source_string)/<span class="number">2</span>)*<span class="number">2</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count&lt;countTo:</span><br><span class="line">        thisVal = <span class="built_in">ord</span>(source_string[count + <span class="number">1</span>])*<span class="number">256</span> + <span class="built_in">ord</span>(source_string[count])</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + thisVal</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> &amp; <span class="number">0xffffffff</span> <span class="comment"># Necessary?</span></span><br><span class="line">        count = count + <span class="number">2</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> countTo&lt;<span class="built_in">len</span>(source_string):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + <span class="built_in">ord</span>(source_string[<span class="built_in">len</span>(source_string) - <span class="number">1</span>])</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> &amp; <span class="number">0xffffffff</span> <span class="comment"># Necessary?</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">sum</span> = (<span class="built_in">sum</span> &gt;&gt; <span class="number">16</span>)  +  (<span class="built_in">sum</span> &amp; <span class="number">0xffff</span>)</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> + (<span class="built_in">sum</span> &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    answer = ~<span class="built_in">sum</span></span><br><span class="line">    answer = answer &amp; <span class="number">0xffff</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#Swap bytes. Bugger me if I know why.</span></span><br><span class="line">    answer = answer &gt;&gt; <span class="number">8</span> | (answer &lt;&lt; <span class="number">8</span> &amp; <span class="number">0xff00</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive_one_ping</span>(<span class="params">my_socket, ID, timeout</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    receive the ping from the socket.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    timeLeft = timeout</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        startedSelect = default_timer()</span><br><span class="line">        whatReady = select.select([my_socket], [], [], timeLeft)</span><br><span class="line">        howLongInSelect = (default_timer() - startedSelect)</span><br><span class="line">        <span class="keyword">if</span> whatReady[<span class="number">0</span>] == []: <span class="comment"># Timeout</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line">        timeReceived = default_timer()</span><br><span class="line">        recPacket, addr = my_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        icmpHeader = recPacket[<span class="number">20</span>:<span class="number">28</span>]</span><br><span class="line">        <span class="built_in">type</span>, code, checksum, packetID, sequence = struct.unpack(</span><br><span class="line">            <span class="string">&quot;bbHHh&quot;</span>, icmpHeader</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">#Filters out the echo request itself. </span></span><br><span class="line">        <span class="comment">#This can be tested by pinging 127.0.0.1 </span></span><br><span class="line">        <span class="comment">#You&#x27;ll see your own request</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span> != <span class="number">8</span> <span class="keyword">and</span> packetID == ID:</span><br><span class="line">            bytesInDouble = struct.calcsize(<span class="string">&quot;d&quot;</span>)</span><br><span class="line">            timeSent = struct.unpack(<span class="string">&quot;d&quot;</span>, recPacket[<span class="number">28</span>:<span class="number">28</span> + bytesInDouble])[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> timeReceived - timeSent</span><br><span class="line"> </span><br><span class="line">        timeLeft = timeLeft - howLongInSelect</span><br><span class="line">        <span class="keyword">if</span> timeLeft &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_one_ping</span>(<span class="params">my_socket, dest_addr, ID</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Send one ping to the given &gt;dest_addr&lt;.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dest_addr  =  socket.gethostbyname(dest_addr)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#Header is type (8), code (8), checksum (16), id (16), sequence (16)</span></span><br><span class="line">    my_checksum = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#Make a dummy heder with a 0 checksum.</span></span><br><span class="line">    header = struct.pack(<span class="string">&quot;bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, my_checksum, ID, <span class="number">1</span>)</span><br><span class="line">    bytesInDouble = struct.calcsize(<span class="string">&quot;d&quot;</span>)</span><br><span class="line">    data = (<span class="number">192</span> - bytesInDouble) * <span class="string">&quot;Q&quot;</span></span><br><span class="line">    data = struct.pack(<span class="string">&quot;d&quot;</span>, default_timer()) + data</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#Calculate the checksum on the data and the dummy header.</span></span><br><span class="line">    my_checksum = checksum(header + data)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#Now that we have the right checksum, we put that in. It&#x27;s just easier</span></span><br><span class="line">    <span class="comment">#to make up a new header than to stuff it into the dummy.</span></span><br><span class="line">    header = struct.pack(</span><br><span class="line">        <span class="string">&quot;bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, socket.htons(my_checksum), ID, <span class="number">1</span></span><br><span class="line">    )</span><br><span class="line">    packet = header + data</span><br><span class="line">    my_socket.sendto(packet, (dest_addr, <span class="number">1</span>)) <span class="comment"># Don&#x27;t know about the 1</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_one</span>(<span class="params">dest_addr, timeout</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Returns either the delay (in seconds) or none on timeout.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    icmp = socket.getprotobyname(<span class="string">&quot;icmp&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        my_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp)</span><br><span class="line">    <span class="keyword">except</span> socket.error, (errno, msg):</span><br><span class="line">        <span class="keyword">if</span> errno == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># Operation not permitted</span></span><br><span class="line">            msg = msg + (</span><br><span class="line">                <span class="string">&quot; - Note that ICMP messages can only be sent from processes&quot;</span></span><br><span class="line">                <span class="string">&quot; running as root.&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">raise</span> socket.error(msg)</span><br><span class="line">        <span class="keyword">raise</span> <span class="comment"># raise the original error</span></span><br><span class="line"> </span><br><span class="line">    my_ID = os.getpid() &amp; <span class="number">0xFFFF</span></span><br><span class="line"> </span><br><span class="line">    send_one_ping(my_socket, dest_addr, my_ID)</span><br><span class="line">    delay = receive_one_ping(my_socket, my_ID, timeout)</span><br><span class="line"> </span><br><span class="line">    my_socket.close()</span><br><span class="line">    <span class="keyword">return</span> delay</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verbose_ping</span>(<span class="params">dest_addr, timeout = <span class="number">2</span>, count = <span class="number">4</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Send &gt;count&lt; ping to &gt;dest_addr&lt; with the given &gt;timeout&lt; and display</span></span><br><span class="line"><span class="string">    the result.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(count):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;ping %s...&quot;</span> % dest_addr,</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            delay  =  do_one(dest_addr, timeout)</span><br><span class="line">        <span class="keyword">except</span> socket.gaierror, e:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;failed. (socket error: &#x27;%s&#x27;)&quot;</span> % e[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> delay  ==  <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;failed. (timeout within %ssec.)&quot;</span> % timeout</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            delay  =  delay * <span class="number">1000</span></span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;get ping in %0.4fms&quot;</span> % delay</span><br><span class="line">    <span class="built_in">print</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    verbose_ping(<span class="string">&quot;heise.de&quot;</span>)</span><br><span class="line">    verbose_ping(<span class="string">&quot;google.com&quot;</span>)</span><br><span class="line">    verbose_ping(<span class="string">&quot;192.168.90.126&quot;</span>)</span><br><span class="line">    verbose_ping(<span class="string">&quot;192.168.1.1&quot;</span>)</span><br></pre></td></tr></table></figure>


<h3 id="ICMP协议编程实践：实现ping命令-Python语言"><a href="#ICMP协议编程实践：实现ping命令-Python语言" class="headerlink" title="ICMP协议编程实践：实现ping命令(Python语言)"></a>ICMP协议编程实践：实现ping命令(Python语言)</h3><p>转载自<a herf="https://network.fasionchan.com/zh_CN/latest/practices/ping-by-icmp-py.html">ICMP协议编程实践：实现ping命令(Python语言)</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- encoding=utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">FileName:   ping.py</span></span><br><span class="line"><span class="string">Author:     Fasion Chan</span></span><br><span class="line"><span class="string">@contact:   fasionchan@gmail.com</span></span><br><span class="line"><span class="string">@version:   $Id$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Description:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Changelog:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_checksum</span>(<span class="params">icmp</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(icmp) % <span class="number">2</span>:</span><br><span class="line">        icmp += <span class="string">b&#x27;\00&#x27;</span></span><br><span class="line"></span><br><span class="line">    checksum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(icmp)//<span class="number">2</span>):</span><br><span class="line">        word, = struct.unpack(<span class="string">&#x27;!H&#x27;</span>, icmp[<span class="number">2</span>*i:<span class="number">2</span>*i+<span class="number">2</span>])</span><br><span class="line">        checksum += word</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        carry = checksum &gt;&gt; <span class="number">16</span></span><br><span class="line">        <span class="keyword">if</span> carry:</span><br><span class="line">            checksum = (checksum &amp; <span class="number">0xffff</span>) + carry</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    checksum = ~checksum &amp; <span class="number">0xffff</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&#x27;!H&#x27;</span>, checksum)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_checksum</span>(<span class="params">icmp</span>):</span></span><br><span class="line">    highs = icmp[<span class="number">0</span>::<span class="number">2</span>]</span><br><span class="line">    lows = icmp[<span class="number">1</span>::<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    checksum = ((<span class="built_in">sum</span>(highs) &lt;&lt; <span class="number">8</span>) + <span class="built_in">sum</span>(lows))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        carry = checksum &gt;&gt; <span class="number">16</span></span><br><span class="line">        <span class="keyword">if</span> carry:</span><br><span class="line">            checksum = (checksum &amp; <span class="number">0xffff</span>) + carry</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    checksum = ~checksum &amp; <span class="number">0xffff</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&#x27;!H&#x27;</span>, checksum)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pack_icmp_echo_request</span>(<span class="params">ident, seq, payload</span>):</span></span><br><span class="line">    pseudo = struct.pack(</span><br><span class="line">        <span class="string">&#x27;!BBHHH&#x27;</span>,</span><br><span class="line">        <span class="number">8</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        ident,</span><br><span class="line">        seq,</span><br><span class="line">    ) + payload</span><br><span class="line">    checksum = calculate_checksum(pseudo)</span><br><span class="line">    <span class="keyword">return</span> pseudo[:<span class="number">2</span>] + checksum + pseudo[<span class="number">4</span>:]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unpack_icmp_echo_reply</span>(<span class="params">icmp</span>):</span></span><br><span class="line">    _<span class="built_in">type</span>, code, _, ident, seq, = struct.unpack(</span><br><span class="line">        <span class="string">&#x27;!BBHHH&#x27;</span>,</span><br><span class="line">        icmp[:<span class="number">8</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> _<span class="built_in">type</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> code != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    payload = icmp[<span class="number">8</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ident, seq, payload</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_routine</span>(<span class="params">sock, addr, ident, magic, stop</span>):</span></span><br><span class="line">    <span class="comment"># first sequence no</span></span><br><span class="line">    seq = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> stop:</span><br><span class="line">        <span class="comment">#currrent time</span></span><br><span class="line">        sending_ts = time.time()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#packet current time to payload</span></span><br><span class="line">        <span class="comment">#in order to calculate round trip time from reply</span></span><br><span class="line">        payload = struct.pack(<span class="string">&#x27;!d&#x27;</span>, sending_ts) + magic</span><br><span class="line"></span><br><span class="line">        <span class="comment">#pack icmp packet</span></span><br><span class="line">        icmp = pack_icmp_echo_request(ident, seq, payload)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#send it</span></span><br><span class="line">        sock.sendto(icmp, <span class="number">0</span>, (addr, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        seq += <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_routine</span>(<span class="params">sock, ident, magic</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment">#wait for another icmp packet</span></span><br><span class="line">        ip, (src_addr, _) = sock.recvfrom(<span class="number">1500</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#unpack it</span></span><br><span class="line">        result = unpack_icmp_echo_reply(ip[<span class="number">20</span>:])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#print info</span></span><br><span class="line">        _ident, seq, payload = result</span><br><span class="line">        <span class="keyword">if</span> _ident != ident:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        sending_ts, = struct.unpack(<span class="string">&#x27;!d&#x27;</span>, payload[:<span class="number">8</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s seq=%d %5.2fms&#x27;</span> % (</span><br><span class="line">            src_addr,</span><br><span class="line">            seq,</span><br><span class="line">            (time.time()-sending_ts) * <span class="number">1000</span>,</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping</span>(<span class="params">addr</span>):</span></span><br><span class="line">    <span class="comment">#create socket for sending and receiving icmp packet</span></span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#id field</span></span><br><span class="line">    ident = os.getpid()</span><br><span class="line">    <span class="comment">#magic string to pad</span></span><br><span class="line">    magic = <span class="string">b&#x27;1234567890&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#sender thread stop flag</span></span><br><span class="line">    <span class="comment">#append anything to stop</span></span><br><span class="line">    sender_stop = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">#start sender thread</span></span><br><span class="line">    <span class="comment">#call send_routine function to send icmp forever</span></span><br><span class="line">    args = (sock, addr, ident, magic, sender_stop,)</span><br><span class="line">    sender = threading.Thread(target=send_routine, args=args)</span><br><span class="line">    sender.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#receive icmp reply forever</span></span><br><span class="line">        recv_routine(sock, ident, magic)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#tell sender thread to stop</span></span><br><span class="line">    sender_stop.append(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#clean sender thread</span></span><br><span class="line">    sender.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ping(sys.argv[<span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>c++10 file operator</title>
    <url>/BassHero.github.io/2021/12/16/cpp10stream/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h3 id="流和缓冲区"><a href="#流和缓冲区" class="headerlink" title="流和缓冲区"></a>流和缓冲区</h3><p>C++把输入和输出看作字节流，程序从字节流抽取字节<br>| 数据类型     | 描述                                                                       |<br>|———-|————————————————————————–|<br>| ofstream | 该数据类型表示输出文件流，用于创建文件并向文件写入信息。                                             |<br>| ifstream | 该数据类型表示输入文件流，用于从文件读取信息。                                                  |<br>| fstream  | 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 |</p>
<p>iostream自动创建8个流对象</p>
<ol>
<li>cin标准输入流</li>
<li>cout标准输出流</li>
<li>cerr标准错误流，显示错误消息，直接发送，不会被缓冲</li>
<li>clog标准错误流，被缓冲</li>
<li>对象代表流</li>
</ol>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>输出到文件</p>
<h4 id="重载-lt-lt"><a href="#重载-lt-lt" class="headerlink" title="重载&lt;&lt;"></a>重载&lt;&lt;</h4><p>C:左位移<br>C++：插入运算符<br>cout&lt;&lt;“putlock”返回的是cout对象，因此可以通过插入来连接输出<br>&lt;&lt;用来显示字符，put，write用来显示字符串<br>cout.put(‘W’);<br>cout.put(‘W’).put(‘W’);</p>
<h4 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h4><ol>
<li><p>修改显示计数系统</p>
<details><summary>manip.cpp (可点开查看)</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// manip.cpp -- using format manipulators </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter an integer: &quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;n n*n\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; n &lt;&lt; <span class="string">&quot;	&quot;</span> &lt;&lt; n * n &lt;&lt; <span class="string">&quot; (decimal)\n&quot;</span>;</span><br><span class="line">	<span class="comment">// set to hex mode </span></span><br><span class="line">	cout &lt;&lt; hex;</span><br><span class="line">	cout &lt;&lt; n &lt;&lt; <span class="string">&quot;	&quot;</span>;</span><br><span class="line">	cout &lt;&lt; n * n &lt;&lt; <span class="string">&quot; (hexadecimal)\n&quot;</span>;</span><br><span class="line">	<span class="comment">// set to octal mode</span></span><br><span class="line">	cout &lt;&lt; oct &lt;&lt; n &lt;&lt; <span class="string">&quot;	&quot;</span> &lt;&lt; n * n &lt;&lt; <span class="string">&quot; (octal)\n&quot;</span>;</span><br><span class="line">	<span class="comment">// alternative way to call a manipulator dec &lt; cout);</span></span><br><span class="line">	cout &lt;&lt; n &lt;&lt; <span class="string">&quot;	&quot;</span> &lt;&lt; n * n &lt;&lt; <span class="string">&quot; (decimal)\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<br></li>
<li><p>调整字段宽度</p>
<details><summary>width.cpp(可点开查看)</summary>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// width.cpp -- using the width method </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::cout;</span><br><span class="line">	<span class="keyword">int</span> w = cout.<span class="built_in">width</span>(<span class="number">30</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;default field width = &quot;</span> &lt;&lt; w &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">	cout.<span class="built_in">width</span>(<span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;N&quot;</span> &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">	cout.<span class="built_in">width</span>(<span class="number">8</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;N * N&quot;</span> &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i *= <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout.<span class="built_in">width</span>(<span class="number">5</span>);</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">		cout.<span class="built_in">width</span>(<span class="number">8</span>);</span><br><span class="line">		cout &lt;&lt; i * i &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details><br></li>
<li><p>填充字符</p>
<details><summary>fill.cpp(可点开查看)</summary>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fill.cpp -- changing fill character for fields </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::cout;</span><br><span class="line">	cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * staff[<span class="number">2</span>] = &#123; <span class="string">&quot;Waldo Whipsnade&quot;</span>, <span class="string">&quot;Wilmarie Wooper&quot;</span> &#125;;</span><br><span class="line">	<span class="keyword">long</span> bonus[<span class="number">2</span>] = &#123; <span class="number">900</span>, <span class="number">1350</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; staff[i] &lt;&lt; <span class="string">&quot;: $&quot;</span>;</span><br><span class="line">		cout.<span class="built_in">width</span>(<span class="number">7</span>);</span><br><span class="line">		cout &lt;&lt; bonus[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details><br></li>
<li><p>设置浮点数</p>
<details><summary>precise.cpp(可点开查看)</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//precise.cpp -- setting the precision</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::cout;</span><br><span class="line">	<span class="keyword">float</span> pricel = <span class="number">20.40</span>;</span><br><span class="line">	<span class="keyword">float</span> price2 = <span class="number">1.9</span> + <span class="number">8.0</span> / <span class="number">9.0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;V&#x27;Furry Friends\&quot; is S&quot;</span> &lt;&lt; pricel &lt;&lt; <span class="string">&quot;!\n &quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\&quot;Fiery Fiends\&quot; is $&quot;</span> &lt;&lt; price2 &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\&quot;Furry Friends\&quot; is $&quot;</span> &lt;&lt; pricel &lt;&lt; <span class="string">&quot;!\n &quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\&quot;Fiery Fiends\&quot; is $&quot;</span> &lt;&lt; price2 &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details><br></li>
<li><p>setf</p>
<details><summary>setf.cpp(可点开查看)</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//setf.cpp -- using setf() to control formatting</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	<span class="keyword">int</span> temperature = <span class="number">63</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Today&#x27;s water temperature:&quot;</span>;</span><br><span class="line">		cout.<span class="built_in">setf</span>(ios_base::showpos);	<span class="comment">// show plus sign</span></span><br><span class="line">	cout &lt;&lt; temperature &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;For our programming friends, that&#x27;s\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; std::hex &lt;&lt; temperature &lt;&lt; endl; <span class="comment">// use hex</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios_base::uppercase);	<span class="comment">// use uppercase in hex</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios_base::showbase);	<span class="comment">// use OX prefix for hex</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;or\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; temperature &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;How &quot;</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">&quot;! oops -- How &quot;</span>;</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios_base::boolalpha);</span><br><span class="line">	cout &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details><br>
<details><summary>setf2.cpp(可点开查看)</summary>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setf2.cpp -- using setf() with 2 arguments to control formatting </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	<span class="comment">// use left justification, show the plus sign, show trailing</span></span><br><span class="line">	<span class="comment">// zeros, with a precision of 3 </span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios_base::left, ios_base::adjustfield);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios_base::showpos); </span><br><span class="line">cout.<span class="built_in">setf</span>(ios_base::showpoint); </span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">// use e-notation and save old format setting</span></span><br><span class="line">ios_base::fmtflags old = cout.<span class="built_in">setf</span>(ios_base::scientific, ios_base::floatfield);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Left Justification:\n&quot;</span>;</span><br><span class="line"><span class="keyword">long</span> n;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= <span class="number">41</span>; n += <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">	cout.<span class="built_in">width</span>(<span class="number">4</span>);</span><br><span class="line">	cout &lt;&lt; n &lt;&lt; <span class="string">&quot;|&quot;</span>;</span><br><span class="line">	cout.<span class="built_in">width</span>(<span class="number">12</span>);</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sqrt</span>(<span class="built_in"><span class="keyword">double</span></span>(n)) &lt;&lt; <span class="string">&quot;|\n&quot;</span>;</span><br><span class="line">	<span class="comment">// change to internal justification</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios_base::internal, ios_base::adjustfield);</span><br><span class="line">	<span class="comment">// restore default floating-point display style </span></span><br><span class="line">	cout.<span class="built_in">setf</span>(old, ios_base::floatfield);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Internal Justification:\n&quot;</span>; <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= <span class="number">41</span>; n += <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout.<span class="built_in">width</span>(<span class="number">4</span>); cout &lt;&lt; n &lt;&lt; cout.<span class="built_in">width</span>(<span class="number">12</span>);</span><br><span class="line">		cout &lt;&lt; <span class="built_in">sqrt</span>(<span class="built_in"><span class="keyword">double</span></span>(n)) &lt;&lt; <span class="string">&quot;|\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// use right justification, fixed notation</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios_base::right, ios_base::adjustfield);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios_base::fixed, ios_base::floatfield);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Right Justification:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= <span class="number">41</span>; n += <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout.<span class="built_in">width</span>(<span class="number">4</span>);</span><br><span class="line">		cout &lt;&lt; n &lt;&lt; <span class="string">&quot; |&quot;</span>;</span><br><span class="line">		cout.<span class="built_in">width</span>(<span class="number">12</span>);</span><br><span class="line">		cout &lt;&lt; <span class="built_in">sqrt</span>(<span class="built_in"><span class="keyword">double</span></span>(n)) &lt;&lt; <span class="string">&quot;|\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details><br></li>
<li><p>标准控制符</p>
<a href="/WestRoute.github.io/images/charactercontrol.png" class="gallery-item"><img src="/WestRoute.github.io/images/charactercontrol.png"></a></li>
<li><p>头文件iomanip<br>setrecision()设置精度<br>setfill()设置填充字符<br>setw()设置字段宽度</p>
</li>
</ol>
<h3 id="使用cin进行输入"><a href="#使用cin进行输入" class="headerlink" title="使用cin进行输入"></a>使用cin进行输入</h3><h4 id="流状态-iostate"><a href="#流状态-iostate" class="headerlink" title="流状态(iostate)"></a>流状态(iostate)</h4><p>eofbit() 如果达到文件尾，设置为1<br>badfit() 如果流被破坏，则设置为1<br>failbit()<br>goodbit() 表示0<br>good()<br>eof() 如果eofbit被设置，则返回true<br>bad() 如果badbit被设置，则返回true<br>fail() 如果badbit 或 fail比他 被设置，则返回true<br>exception() 返回一个掩码，指出那些标记异常被引发<br>exception(isostate ex)<br>设置状态<br>clear(iostate s)<br>setstate(iostate s)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cinexcp.cpp -- having cin throw an exception </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	<span class="comment">// have failbit cause an exception to be thrown</span></span><br><span class="line">	cin.<span class="built_in">exceptions</span>(ios_base::failbit);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter numbers: &quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> input;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (cin &gt;&gt; input)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += input;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in"><span class="keyword">catch</span></span> (ios_base::failure &amp; bf)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; bf.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;0! the horror!\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Last value entered = &quot;</span> &lt;&lt; input &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他istream方法"><a href="#其他istream方法" class="headerlink" title="其他istream方法"></a>其他istream方法</h4><p>get(char&amp;)get(void)提供不跳过空格的但字符输入功能<br>get(char&amp;,int,char)和getline(char&amp;,int,char)在默认情况下读取整行而不是一个单词<br>char line[50];<br>cin.get(line,50);将在第49位或空格停止输入。<br>get()将分界字符留在输入队列中，getline()不保留</p>
<details><summary>setf2.cpp(可点开查看)</summary>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get_fun.cpp -- using get() and getline()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Limit = <span class="number">255</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::cout;</span><br><span class="line">	<span class="keyword">using</span> std::cin;</span><br><span class="line">	<span class="keyword">using</span> std::endl;</span><br><span class="line">	<span class="keyword">char</span> input[Limit];</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter a string for getlineO processing:\n&quot;</span>;</span><br><span class="line">	cin.<span class="built_in">getline</span>(input, Limit, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Here is your input:\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; input &lt;&lt; <span class="string">&quot;\nDone with phase 1\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	cin.<span class="built_in">get</span>(ch);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The next input character is &quot;</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">if</span> (ch != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		cin.<span class="built_in">ignore</span>(Limit, <span class="string">&#x27;\n&#x27;</span>);	<span class="comment">// discard rest of line</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter a string for get() processing:\n&quot;</span>;</span><br><span class="line">	cin.<span class="built_in">get</span>(input, Limit, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Here is your input:\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; input &lt;&lt; <span class="string">&quot;\nDone with phase 2\n&quot;</span>;</span><br><span class="line">	cin.<span class="built_in">get</span>(ch);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The next input character is &quot;</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details><br>
read()读取指定字节，并将它们储存到指定位置上
peek()返回输入中的下一个字节，但不抽取输入流
gcount()
putback()

<h3 id="文件输入和输出"><a href="#文件输入和输出" class="headerlink" title="文件输入和输出"></a>文件输入和输出</h3><p>输出:</p>
<ol>
<li>创建一个ofstream对象来管理输出流</li>
<li>将该对象与特定的文件关联起来</li>
<li>使用count的方式使用该对象，唯一的区别是输出将进入文件，而不是屏幕<br>输入也一样</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fileio.cpp -- saving to a file</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> <span class="comment">// not needed for many systems </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	string filename;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter name for new file: &quot;</span>;</span><br><span class="line">	cin &gt;&gt; filename;</span><br><span class="line">	<span class="comment">// create output stream object for new file and call it fout </span></span><br><span class="line">	<span class="function">ofstream <span class="title">fout</span><span class="params">(filename.c_str())</span></span>;</span><br><span class="line">	fout &lt;&lt; <span class="string">&quot;For your eyes only!\n&quot;</span>;	<span class="comment">// write to file</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter your secret number: &quot;</span>;<span class="comment">// write to screen</span></span><br><span class="line">	<span class="keyword">float</span> secret; cin &gt;&gt; secret;</span><br><span class="line">	fout &lt;&lt; <span class="string">&quot;Your secret number is &quot;</span> &lt;&lt; secret &lt;&lt; endl;</span><br><span class="line">	fout.<span class="built_in">close</span>();	<span class="comment">// close file</span></span><br><span class="line">	<span class="comment">// create input stream object for new file and call it fin </span></span><br><span class="line">	<span class="function">ifstream <span class="title">fin</span><span class="params">(filename.c_str())</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Here are the contents of &quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;:\n&quot;</span>; <span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">while</span> (fin.<span class="built_in">get</span>(ch))	<span class="comment">// read character from file and</span></span><br><span class="line">		cout &lt;&lt; ch;	<span class="comment">// write it to screen</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Done\n&quot;</span>;</span><br><span class="line">	fin.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>试图打开一个不存在的文件进行输入时，将设置failbit位<br>fin.open(argv[file]);<br>if(fin.fail()){<br>    ….<br>}<br>也可以这样做<br>fin.open(argv[file]);<br>if(!fin){<br>    ….<br>}<br>也可以<br>if(!fin.is_open()){<br>    ….<br>}<br>打开多个文件<br>fin.open(“one.txt”);<br>fin.close();<br>fin.clear();<br>fin.open(“two.txt”);<br><br><br>argc是命令行参数个数，是数组</p>
<table>
<thead>
<tr>
<th>模式标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ios::app</td>
<td>追加模式。所有写入都追加到文件末尾。</td>
</tr>
<tr>
<td>ios::ate</td>
<td>文件打开后定位到文件末尾。</td>
</tr>
<tr>
<td>ios::in</td>
<td>打开文件用于读取。</td>
</tr>
<tr>
<td>ios::out</td>
<td>打开文件用于写入。</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td>
</tr>
</tbody></table>
<p>二进制输入<br>二进制文件更精准更简洁，但可移植性较差<br>read()和write()支持二进制<br>ofstream fout(“planets.dat”,ios_base::out|ios_base::app|ios_base::binary);<br>fout.write((char*) &amp;pl,sizeof pl);</p>
<h4 id="随机存取"><a href="#随机存取" class="headerlink" title="随机存取"></a>随机存取</h4><p>文件读取整个文件后，并设置eofbit元素，禁止对文件进一步读写。使用clear()方法重置流状态，并打开eofbit后，程序便可以再次访问该文件，else处理其他原因引起的停止读取的情况。<br>seekg()和seekp()函数提供对文件的随机存取<br>tellg()和tellp()方法报告当前的文件位置</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// random.cpp -- random access to a binary file</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> <span class="comment">// not required by most systems </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span>	<span class="comment">// for exit()</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LIM = <span class="number">20</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">planet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[LIM];<span class="comment">// name of planet </span></span><br><span class="line">	<span class="keyword">double</span> population;<span class="comment">// its population</span></span><br><span class="line">	<span class="keyword">double</span> g;<span class="comment">// its acceleration of gravity</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * file = <span class="string">&quot;planets.dat&quot;</span>;	<span class="comment">// ASSUMED TO EXIST (binary.cpp example)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">eatline</span><span class="params">()</span> </span>&#123; <span class="keyword">while</span> (std::cin.<span class="built_in">get</span>() != <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	planet pl;</span><br><span class="line">	cout &lt;&lt; fixed;</span><br><span class="line">	<span class="comment">// show initial contents</span></span><br><span class="line">	fstream finout;	<span class="comment">// read and write streams</span></span><br><span class="line">	finout.<span class="built_in">open</span>(file, ios_base::in | ios_base::out | ios_base::binary);</span><br><span class="line">	<span class="comment">//<span class="doctag">NOTE:</span> Some Unix systems require omitting - ios::binary </span></span><br><span class="line">	<span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (finout.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		finout.<span class="built_in">seekg</span>(<span class="number">0</span>);<span class="comment">// go to beginning</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Here are tRe current contents of the  &quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot; file: \n&quot;</span>;</span><br><span class="line">		<span class="keyword">while</span> (finout.<span class="built_in">read</span>((<span class="keyword">char</span> *)&amp;pl, <span class="keyword">sizeof</span> pl))</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; ct++ &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">setw</span>(LIM) &lt;&lt; pl.name &lt;&lt; <span class="string">&quot;: &quot;</span></span><br><span class="line">				&lt;&lt; <span class="built_in">setprecision</span>(<span class="number">0</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">-12</span>) &lt;&lt; pl.population</span><br><span class="line">				&lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; pl.g &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (finout.<span class="built_in">eof</span>())</span><br><span class="line">			finout.<span class="built_in">clear</span>(); <span class="comment">// clear eof flag</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cerr &lt;&lt; <span class="string">&quot;Error in reading &quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cerr &lt;&lt; file &lt;&lt; <span class="string">&quot; could not be opened -- bye.\n&quot;</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// &quot;&quot;&quot;change a record&quot;&quot;&quot;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter the record number you wish to change: &quot;</span>;</span><br><span class="line">	<span class="keyword">long</span> rec;</span><br><span class="line">	cin &gt;&gt; rec;</span><br><span class="line">	<span class="built_in">eatline</span>();	<span class="comment">// get rid of newline</span></span><br><span class="line">	<span class="keyword">if</span> (rec &lt; <span class="number">0</span> || rec &gt;= ct)</span><br><span class="line">	&#123;</span><br><span class="line">		cerr &lt;&lt; <span class="string">&quot;Invalid record number -- bye\n&quot;</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	streampos place = rec * <span class="keyword">sizeof</span> pl; <span class="comment">// convert to streampos type</span></span><br><span class="line">	finout.<span class="built_in">seekg</span>(place);	<span class="comment">// random access</span></span><br><span class="line">	<span class="keyword">if</span> (finout.<span class="built_in">fail</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cerr &lt;&lt; <span class="string">&quot;Error on attempted seek\n&quot;</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	finout.<span class="built_in">read</span>((<span class="keyword">char</span> *)&amp;pl, <span class="keyword">sizeof</span> pl);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Your selection:\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; rec &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">setw</span>(LIM) &lt;&lt; pl.name &lt;&lt; <span class="string">&quot;: &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">setprecision</span>(<span class="number">0</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; pl.population</span><br><span class="line">		&lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; pl.g &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// clear eof flag</span></span><br><span class="line">	<span class="keyword">if</span> (finout.<span class="built_in">eof</span>())</span><br><span class="line">		finout.<span class="built_in">clear</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter planet name: &quot;</span>;</span><br><span class="line">	cin.<span class="built_in">get</span>(pl.name, LIM);</span><br><span class="line">	<span class="built_in">eatline</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter planetary population: &quot;</span>;</span><br><span class="line">	cin &gt;&gt; pl.population;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter planet&#x27;s acceleration of gravity: &quot;</span>;</span><br><span class="line">	cin &gt;&gt; pl.g;</span><br><span class="line">	finout.<span class="built_in">seekp</span>(place);	<span class="comment">// go back</span></span><br><span class="line">	finout.<span class="built_in">write</span>((<span class="keyword">char</span> *)&amp;pl, <span class="keyword">sizeof</span> pl) &lt;&lt; flush;</span><br><span class="line">	<span class="keyword">if</span> (finout.<span class="built_in">fail</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cerr &lt;&lt; <span class="string">&quot;Error on attempted write\n&quot;</span>;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// show revised file ct = 0;</span></span><br><span class="line">	finout.<span class="built_in">seekg</span>(<span class="number">0</span>);	<span class="comment">// go to beginning of file</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Here are the new contents of the &quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot;file:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span> (finout.<span class="built_in">read</span>((<span class="keyword">char</span> *)&amp;pl, <span class="keyword">sizeof</span> pl))</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; ct++ &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">setw</span>(LIM) &lt;&lt; pl.name &lt;&lt; <span class="string">&quot;: &quot;</span></span><br><span class="line">			&lt;&lt; <span class="built_in">setprecision</span>(<span class="number">0</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; pl.population</span><br><span class="line">			&lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; pl.g &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	finout.<span class="built_in">close</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Done.\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内核格式化"><a href="#内核格式化" class="headerlink" title="内核格式化"></a>内核格式化</h3><p>iostream族支持程序与终端之间的I/O<br>fstream族使用相同的接口提供程序和文件之间的I/O<br>sstream族使用相同的接口提供程序和string对象之间的I/O</p>
<p>读取string对象中的格式化信息或将格式化信息写入string对象中被称为内核格式化(incore formatting)<br><br></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// strin.cpp -- formatted reading from a char array </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	string lit = <span class="string">&quot;t was a dark and stormy day, and the full moon glowed brilliantly. &quot;</span>;</span><br><span class="line">	<span class="function">istringstream <span class="title">instr</span><span class="params">(lit)</span></span>; <span class="comment">// use buf for input </span></span><br><span class="line">	string <span class="keyword">word</span>;</span><br><span class="line">	<span class="keyword">while</span> (instr &gt;&gt; <span class="keyword">word</span>)<span class="comment">// read a word a time</span></span><br><span class="line">		cout &lt;&lt; <span class="keyword">word</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>ICMP ping</title>
    <url>/BassHero.github.io/2021/12/09/ISBN978-7-111-45378-9-06/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>参考来自：<a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer">Computer Network A Top-Down Approach Practice Answer-github</a></p>
<span id="more"></span>
<h2 id="chapter4"><a href="#chapter4" class="headerlink" title="chapter4"></a>chapter4</h2><h3 id="ICMP-ping"><a href="#ICMP-ping" class="headerlink" title="ICMP ping"></a>ICMP ping</h3><p>Ping是一个网络应用程序，用于测试某个主机在IP网络中是否可访问。它也用于测试计算机的网卡或测试网络延迟。它通过向目标主机发送ICMP“回显”包并监听ICMP“回显”应答来工作。“回显”有时称为”pong”。ping程序测量往返时间，记录数据包丢失，并输出接收到的回显包的统计摘要（往返时间的最小值、最大值和平均值，以及在某些版本中的平均值的标准差）。<br>您的任务是用python开发自己的Ping程序。您的程序将使用ICMP，但为了保持简单，将不完全遵循RFC 1739中的正式规范。请注意，您只需要编写程序的客户端，因为服务器端所需的功能几乎内置于所有操作系统中。<br>您的Ping程序能将ping请求发送到指定的主机，间隔大约一秒钟。每个消息包含一个带有时间戳的数据包。每个数据包发送完后，程序最多等待一秒，用于接收响应。如果一秒后服务器没有响应，那么客户端应假设ping数据包或pong数据包在网络中丢失（或者服务器已关闭）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">ICMP_ECHO_REQUEST = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checksum</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    csum = <span class="number">0</span></span><br><span class="line">    countTo = (<span class="built_in">len</span>(<span class="built_in">str</span>) / <span class="number">2</span>) * <span class="number">2</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt; countTo:</span><br><span class="line">        thisVal = <span class="built_in">ord</span>(<span class="built_in">str</span>[count+<span class="number">1</span>]) * <span class="number">256</span> + <span class="built_in">ord</span>(<span class="built_in">str</span>[count])</span><br><span class="line">        csum = csum + thisVal</span><br><span class="line">        csum = csum &amp; <span class="number">0xffffffffL</span></span><br><span class="line">        count = count + <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> countTo &lt; <span class="built_in">len</span>(<span class="built_in">str</span>):</span><br><span class="line">        csum = csum + <span class="built_in">ord</span>(<span class="built_in">str</span>[<span class="built_in">len</span>(<span class="built_in">str</span>) - <span class="number">1</span>])</span><br><span class="line">        csum = csum &amp; <span class="number">0xffffffffL</span></span><br><span class="line"></span><br><span class="line">    csum = (csum &gt;&gt; <span class="number">16</span>) + (csum &amp; <span class="number">0xffff</span>)</span><br><span class="line">    csum = csum + (csum &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    answer = ~csum</span><br><span class="line">    answer = answer &amp; <span class="number">0xffff</span></span><br><span class="line">    answer = answer &gt;&gt; <span class="number">8</span> | (answer &lt;&lt; <span class="number">8</span> &amp; <span class="number">0xff00</span>)</span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receiveOnePing</span>(<span class="params">mySocket, ID, timeout, destAddr</span>):</span></span><br><span class="line">    timeLeft = timeout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        startedSelect = time.time()</span><br><span class="line">        whatReady = select.select([mySocket], [], [], timeLeft)</span><br><span class="line">        howLongInSelect = (time.time() - startedSelect)</span><br><span class="line">        <span class="keyword">if</span> whatReady[<span class="number">0</span>] == []: <span class="comment"># Timeout</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Request timed out.&quot;</span></span><br><span class="line"></span><br><span class="line">        timeReceived = time.time()</span><br><span class="line">        recPacket, addr = mySocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#Fill in start</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#Fetch the ICMP header from the IP packet</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#Fill in end</span></span><br><span class="line">        </span><br><span class="line">        timeLeft = timeLeft - howLongInSelect</span><br><span class="line">        <span class="keyword">if</span> timeLeft &lt;= <span class="number">0</span>:</span><br><span class="line">        	<span class="keyword">return</span> <span class="string">&quot;Request timed out.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendOnePing</span>(<span class="params">mySocket, destAddr, ID</span>):</span></span><br><span class="line">    <span class="comment"># Header is type (8), code (8), checksum (16), id (16), sequence (16)</span></span><br><span class="line">    </span><br><span class="line">    myChecksum = <span class="number">0</span></span><br><span class="line">    <span class="comment"># Make a dummy header with a 0 checksum.</span></span><br><span class="line">    <span class="comment"># struct -- Interpret strings as packed binary data</span></span><br><span class="line">    header = struct.pack(<span class="string">&quot;bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, <span class="number">1</span>)</span><br><span class="line">    data = struct.pack(<span class="string">&quot;d&quot;</span>, time.time())</span><br><span class="line">    <span class="comment"># Calculate the checksum on the data and the dummy header.</span></span><br><span class="line">    myChecksum = checksum(header + data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get the right checksum, and put in the header</span></span><br><span class="line">    <span class="keyword">if</span> sys.platform == <span class="string">&#x27;darwin&#x27;</span>:</span><br><span class="line">        myChecksum = socket.htons(myChecksum) &amp; <span class="number">0xffff</span></span><br><span class="line">        <span class="comment">#Convert 16-bit integers from host to network byte order.</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        myChecksum = socket.htons(myChecksum)</span><br><span class="line">    </span><br><span class="line">    header = struct.pack(<span class="string">&quot;bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, <span class="number">1</span>)</span><br><span class="line">    packet = header + data</span><br><span class="line">    </span><br><span class="line">    mySocket.sendto(packet, (destAddr, <span class="number">1</span>)) <span class="comment"># AF_INET address must be tuple, not str</span></span><br><span class="line">    <span class="comment">#Both LISTS and TUPLES consist of a number of objects</span></span><br><span class="line">    <span class="comment">#which can be referenced by their position number within the object</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doOnePing</span>(<span class="params">destAddr, timeout</span>):</span></span><br><span class="line">    icmp = socket.getprotobyname(<span class="string">&quot;icmp&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#SOCK_RAW is a powerful socket type. For more details see: http://sock-raw.org/papers/sock_raw</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#Fill in start</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#Create Socket here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#Fill in end</span></span><br><span class="line"></span><br><span class="line">    myID = os.getpid() &amp; <span class="number">0xFFFF</span> <span class="comment">#Return the current process i</span></span><br><span class="line">    sendOnePing(mySocket, destAddr, myID)</span><br><span class="line">    delay = receiveOnePing(mySocket, myID, timeout, destAddr)</span><br><span class="line"></span><br><span class="line">    mySocket.close()</span><br><span class="line">    <span class="keyword">return</span> delay</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping</span>(<span class="params">host, timeout=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="comment">#timeout=1 means: If one second goes by without a reply from the server,</span></span><br><span class="line">    <span class="comment">#the client assumes that either the client’s ping or the server’s pong is lost</span></span><br><span class="line">    dest = socket.gethostbyname(host)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Pinging &quot;</span> + dest + <span class="string">&quot; using Python:&quot;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment">#Send ping requests to a server separated by approximately one second</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span> :</span><br><span class="line">        delay = doOnePing(dest, timeout)</span><br><span class="line">        <span class="built_in">print</span> delay</span><br><span class="line">        time.sleep(<span class="number">1</span>)<span class="comment"># one second</span></span><br><span class="line">    <span class="keyword">return</span> delay</span><br><span class="line"></span><br><span class="line">ping(<span class="string">&quot;www.poly.edu&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>1.在“receiveOnePing”方法中，你需要获得ICMP_ECHO_REPLY结构并取出您需要的信息，如校验和、序列号、生存时间（TTL）等。在尝试完成“receiveOnePing”方法之前先研究“sendOnePing”方法。<br>2.您不必关心校验和，因为它已经在代码中给出了。<br>3.这个作业要求使用原始的sockets。在某些操作系统中，您可能需要管理员/root权限才能运行你的Ping程序。<br>4.有关ICMP的更多信息，请参见此编程练习的结尾部分。<br>5.首先，通过发送数据包到本地主机来测试你的客户端，主机地址：127.0.0.1。然后，你应该看看你的Ping程序如何通过在不同大洲的pinging服务器在网络中工作。<br><br></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">ICMP_ECHO_REQUEST = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checksum</span>(<span class="params">strCheck</span>):</span></span><br><span class="line">    csum = <span class="number">0</span></span><br><span class="line">    countTo = (<span class="built_in">len</span>(strCheck) / <span class="number">2</span>) * <span class="number">2</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt; countTo:</span><br><span class="line">        thisVal = strCheck[count + <span class="number">1</span>] * <span class="number">256</span> + strCheck[count]</span><br><span class="line">        csum = csum + thisVal</span><br><span class="line">        csum = csum &amp; <span class="number">0xffffffff</span></span><br><span class="line">        count = count + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> countTo &lt; <span class="built_in">len</span>(strCheck):</span><br><span class="line">        csum = csum + strCheck[<span class="built_in">len</span>(strCheck) - <span class="number">1</span>]</span><br><span class="line">        csum = csum &amp; <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line">    csum = (csum &gt;&gt; <span class="number">16</span>) + (csum &amp; <span class="number">0xffff</span>)</span><br><span class="line">    csum = csum + (csum &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    answer = ~csum</span><br><span class="line">    answer = answer &amp; <span class="number">0xffff</span></span><br><span class="line">    answer = answer &gt;&gt; <span class="number">8</span> | (answer &lt;&lt; <span class="number">8</span> &amp; <span class="number">0xff00</span>)</span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receiveOnePing</span>(<span class="params">mySocket, ID, timeout, destAddr</span>):</span></span><br><span class="line">    timeLeft = timeout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        startedSelect = time.time()</span><br><span class="line">        whatReady = select.select([mySocket], [], [], timeLeft)</span><br><span class="line">        howLongInSelect = (time.time() - startedSelect)</span><br><span class="line">        <span class="keyword">if</span> whatReady[<span class="number">0</span>] == []:  <span class="comment"># Timeout</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Request timed out.&quot;</span></span><br><span class="line"></span><br><span class="line">        timeReceived = time.time()</span><br><span class="line">        recPacket, addr = mySocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        header = recPacket[<span class="number">20</span>:<span class="number">28</span>]</span><br><span class="line">        header_type, header_code, header_checksum, header_packet_ID, header_sequence = struct.unpack(<span class="string">&quot;bbHHh&quot;</span>, header)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(header_type != <span class="number">0</span> <span class="keyword">or</span> header_code != <span class="number">0</span> <span class="keyword">or</span> header_packet_ID != ID <span class="keyword">or</span> header_sequence != <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Receive error.&quot;</span></span><br><span class="line"></span><br><span class="line">        timeLeft = timeLeft - howLongInSelect</span><br><span class="line">        <span class="keyword">if</span> timeLeft &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Request timed out.&quot;</span></span><br><span class="line">        <span class="keyword">return</span> timeLeft</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendOnePing</span>(<span class="params">mySocket, destAddr, ID</span>):</span></span><br><span class="line">    <span class="comment"># Header is type (8), code (8), checksum (16), id (16), sequence (16)</span></span><br><span class="line"></span><br><span class="line">    myChecksum = <span class="number">0</span></span><br><span class="line">    <span class="comment"># Make a dummy header with a 0 checksum.</span></span><br><span class="line">    <span class="comment"># 创建一个带有0校验和的伪头。</span></span><br><span class="line">    <span class="comment"># struct -- Interpret strings as packed binary data</span></span><br><span class="line">    <span class="comment"># struct-将字符串解释为打包的二进制数据</span></span><br><span class="line">    header = struct.pack(<span class="string">&quot;bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, <span class="number">1</span>)</span><br><span class="line">    data = struct.pack(<span class="string">&quot;d&quot;</span>, time.time())</span><br><span class="line">    <span class="comment"># Calculate the checksum on the data and the dummy header.</span></span><br><span class="line">    <span class="comment"># 计算数据和虚拟头的校验和。</span></span><br><span class="line">    myChecksum = checksum(header + data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get the right checksum, and put in the header</span></span><br><span class="line">    <span class="keyword">if</span> sys.platform == <span class="string">&#x27;darwin&#x27;</span>:</span><br><span class="line">        myChecksum = socket.htons(myChecksum) &amp; <span class="number">0xffff</span></span><br><span class="line">        <span class="comment"># Convert 16-bit integers from host to network byte order.</span></span><br><span class="line">        <span class="comment"># 将主机的16位整数转换为网络字节顺序。</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        myChecksum = socket.htons(myChecksum)</span><br><span class="line"></span><br><span class="line">    header = struct.pack(<span class="string">&quot;bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, <span class="number">1</span>)</span><br><span class="line">    packet = header + data</span><br><span class="line"></span><br><span class="line">    mySocket.sendto(packet, (destAddr, <span class="number">1</span>))  <span class="comment"># AF_INET address must be tuple, not str</span></span><br><span class="line">    <span class="comment"># Both LISTS and TUPLES consist of a number of objects</span></span><br><span class="line">    <span class="comment"># which can be referenced by their position number within the object</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doOnePing</span>(<span class="params">destAddr, timeout</span>):</span></span><br><span class="line">    icmp = socket.getprotobyname(<span class="string">&quot;icmp&quot;</span>)</span><br><span class="line"></span><br><span class="line">    mySocket = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp)</span><br><span class="line"></span><br><span class="line">    myID = os.getpid() &amp; <span class="number">0xFFFF</span>  <span class="comment"># Return the current process i</span></span><br><span class="line">    sendOnePing(mySocket, destAddr, myID)</span><br><span class="line">    delay = receiveOnePing(mySocket, myID, timeout, destAddr)</span><br><span class="line"></span><br><span class="line">    mySocket.close()</span><br><span class="line">    <span class="keyword">return</span> delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping</span>(<span class="params">host, timeout=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="comment"># timeout=1 means: If one second goes by without a reply from the server,</span></span><br><span class="line">    <span class="comment"># the client assumes that either the client’s ping or the server’s pong is lost</span></span><br><span class="line">    <span class="comment"># timeout = 1 表示：如果一秒钟没有收到服务器的答复，则客户端会认为客户端的ping或服务器的pong丢失了</span></span><br><span class="line">    dest = socket.gethostbyname(host)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Pinging &quot;</span> + dest + <span class="string">&quot; using Python:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="comment"># Send ping requests to a server separated by approximately one second</span></span><br><span class="line">    <span class="comment"># 将ping请求发送到间隔约一秒钟的服务器</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        delay = doOnePing(dest, timeout)</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span> - delay)</span><br><span class="line">        time.sleep(<span class="number">1</span>)  <span class="comment"># one second</span></span><br><span class="line"></span><br><span class="line">ping(<span class="string">&quot;baidu.com&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>可选练习</strong><br>1.目前，程序计算每个包的往返时间，并逐个打印出来。修改此命令以符合标准ping程序的工作方式。你需要在所有ping完成后，报告最小，最大和平均RTT，以及数据包丢失率（百分比）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">ICMP_ECHO_REQUEST = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checksum</span>(<span class="params">strCheck</span>):</span></span><br><span class="line">    csum = <span class="number">0</span></span><br><span class="line">    countTo = (<span class="built_in">len</span>(strCheck) / <span class="number">2</span>) * <span class="number">2</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt; countTo:</span><br><span class="line">        thisVal = strCheck[count + <span class="number">1</span>] * <span class="number">256</span> + strCheck[count]</span><br><span class="line">        csum = csum + thisVal</span><br><span class="line">        csum = csum &amp; <span class="number">0xffffffff</span></span><br><span class="line">        count = count + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> countTo &lt; <span class="built_in">len</span>(strCheck):</span><br><span class="line">        csum = csum + strCheck[<span class="built_in">len</span>(strCheck) - <span class="number">1</span>]</span><br><span class="line">        csum = csum &amp; <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line">    csum = (csum &gt;&gt; <span class="number">16</span>) + (csum &amp; <span class="number">0xffff</span>)</span><br><span class="line">    csum = csum + (csum &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    answer = ~csum</span><br><span class="line">    answer = answer &amp; <span class="number">0xffff</span></span><br><span class="line">    answer = answer &gt;&gt; <span class="number">8</span> | (answer &lt;&lt; <span class="number">8</span> &amp; <span class="number">0xff00</span>)</span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receiveOnePing</span>(<span class="params">mySocket, ID, timeout, destAddr</span>):</span></span><br><span class="line">    timeLeft = timeout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        startedSelect = time.time()</span><br><span class="line">        whatReady = select.select([mySocket], [], [], timeLeft)</span><br><span class="line">        howLongInSelect = (time.time() - startedSelect)</span><br><span class="line">        <span class="keyword">if</span> whatReady[<span class="number">0</span>] == []:  <span class="comment"># Timeout</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Request timed out.&quot;</span></span><br><span class="line"></span><br><span class="line">        timeReceived = time.time()</span><br><span class="line">        recPacket, addr = mySocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        header = recPacket[<span class="number">20</span>:<span class="number">28</span>]</span><br><span class="line">        header_type, header_code, header_checksum, header_packet_ID, header_sequence = struct.unpack(<span class="string">&quot;bbHHh&quot;</span>, header)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(header_type != <span class="number">0</span> <span class="keyword">or</span> header_code != <span class="number">0</span> <span class="keyword">or</span> header_packet_ID != ID <span class="keyword">or</span> header_sequence != <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Receive error.&quot;</span></span><br><span class="line"></span><br><span class="line">        timeLeft = timeLeft - howLongInSelect</span><br><span class="line">        <span class="keyword">if</span> timeLeft &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Request timed out.&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> - timeLeft</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendOnePing</span>(<span class="params">mySocket, destAddr, ID</span>):</span></span><br><span class="line">    <span class="comment"># Header is type (8), code (8), checksum (16), id (16), sequence (16)</span></span><br><span class="line"></span><br><span class="line">    myChecksum = <span class="number">0</span></span><br><span class="line">    <span class="comment"># Make a dummy header with a 0 checksum.</span></span><br><span class="line">    <span class="comment"># 创建一个带有0校验和的伪头。</span></span><br><span class="line">    <span class="comment"># struct -- Interpret strings as packed binary data</span></span><br><span class="line">    <span class="comment"># struct-将字符串解释为打包的二进制数据</span></span><br><span class="line">    header = struct.pack(<span class="string">&quot;bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, <span class="number">1</span>)</span><br><span class="line">    data = struct.pack(<span class="string">&quot;d&quot;</span>, time.time())</span><br><span class="line">    <span class="comment"># Calculate the checksum on the data and the dummy header.</span></span><br><span class="line">    <span class="comment"># 计算数据和虚拟头的校验和。</span></span><br><span class="line">    myChecksum = checksum(header + data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get the right checksum, and put in the header</span></span><br><span class="line">    <span class="keyword">if</span> sys.platform == <span class="string">&#x27;darwin&#x27;</span>:</span><br><span class="line">        myChecksum = socket.htons(myChecksum) &amp; <span class="number">0xffff</span></span><br><span class="line">        <span class="comment"># Convert 16-bit integers from host to network byte order.</span></span><br><span class="line">        <span class="comment"># 将主机的16位整数转换为网络字节顺序。</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        myChecksum = socket.htons(myChecksum)</span><br><span class="line"></span><br><span class="line">    header = struct.pack(<span class="string">&quot;bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, <span class="number">1</span>)</span><br><span class="line">    packet = header + data</span><br><span class="line"></span><br><span class="line">    mySocket.sendto(packet, (destAddr, <span class="number">1</span>))  <span class="comment"># AF_INET address must be tuple, not str</span></span><br><span class="line">    <span class="comment"># Both LISTS and TUPLES consist of a number of objects</span></span><br><span class="line">    <span class="comment"># which can be referenced by their position number within the object</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doOnePing</span>(<span class="params">destAddr, timeout</span>):</span></span><br><span class="line">    icmp = socket.getprotobyname(<span class="string">&quot;icmp&quot;</span>)</span><br><span class="line"></span><br><span class="line">    mySocket = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp)</span><br><span class="line"></span><br><span class="line">    myID = os.getpid() &amp; <span class="number">0xFFFF</span>  <span class="comment"># Return the current process i</span></span><br><span class="line">    sendOnePing(mySocket, destAddr, myID)</span><br><span class="line">    delay = receiveOnePing(mySocket, myID, timeout, destAddr)</span><br><span class="line"></span><br><span class="line">    mySocket.close()</span><br><span class="line">    <span class="keyword">return</span> delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping</span>(<span class="params">host, timeout=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="comment"># timeout=1 means: If one second goes by without a reply from the server,</span></span><br><span class="line">    <span class="comment"># the client assumes that either the client’s ping or the server’s pong is lost</span></span><br><span class="line">    <span class="comment"># timeout = 1 表示：如果一秒钟没有收到服务器的答复，则客户端会认为客户端的ping或服务器的pong丢失了</span></span><br><span class="line">    dest = socket.gethostbyname(host)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在 Ping&quot;</span>, host, <span class="string">&quot;[&quot;</span>, dest, <span class="string">&quot;] :&quot;</span>)</span><br><span class="line">    <span class="comment"># Send ping requests to a server separated by approximately one second</span></span><br><span class="line">    <span class="comment"># 将ping请求发送到间隔约一秒钟的服务器</span></span><br><span class="line">    num = <span class="number">4</span></span><br><span class="line">    lost = <span class="number">0</span></span><br><span class="line">    delayList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        delay = doOnePing(dest, timeout)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">type</span>(delay) == <span class="built_in">str</span>):</span><br><span class="line">            <span class="built_in">print</span>(delay)</span><br><span class="line">            lost = lost + <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        delay = <span class="built_in">int</span>(delay * <span class="number">1000</span>)</span><br><span class="line">        delayList.append(delay)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;来自&quot;</span>, dest, <span class="string">&quot;的回复: 时间=&quot;</span>, delay, <span class="string">&quot;ms&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)  <span class="comment"># one second</span></span><br><span class="line">    <span class="built_in">print</span>(dest, <span class="string">&quot;的 Ping 统计信息:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\t数据包: 已发送 =&quot;</span>, num, <span class="string">&quot;，已接收 =&quot;</span>, num - lost, <span class="string">&quot;，丢失 =&quot;</span>, lost, <span class="string">&quot;(&quot;</span>, lost/num * <span class="number">100</span>, <span class="string">&quot;% 丢失)&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(delayList):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;往返行程的估计时间(以毫秒为单位):&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\t最短 =&quot;</span>, <span class="built_in">min</span>(delayList), <span class="string">&quot;ms，最长 =&quot;</span>, <span class="built_in">max</span>(delayList), <span class="string">&quot;ms，平均 =&quot;</span>, <span class="built_in">sum</span>(delayList)/<span class="built_in">len</span>(delayList), <span class="string">&quot;ms&quot;</span>)</span><br><span class="line"></span><br><span class="line">ping(<span class="string">&quot;qq.com&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.你的程序只能检测ICMP超时。修改Ping程序，解析ICMP响应错误代码，并向用户显示相应的错误结果。ICMP响应错误码示例有0：目标网络无法到达可达，1：目标主机无法到达。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">ICMP_ECHO_REQUEST = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checksum</span>(<span class="params">strCheck</span>):</span></span><br><span class="line">    csum = <span class="number">0</span></span><br><span class="line">    countTo = (<span class="built_in">len</span>(strCheck) / <span class="number">2</span>) * <span class="number">2</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt; countTo:</span><br><span class="line">        thisVal = strCheck[count + <span class="number">1</span>] * <span class="number">256</span> + strCheck[count]</span><br><span class="line">        csum = csum + thisVal</span><br><span class="line">        csum = csum &amp; <span class="number">0xffffffff</span></span><br><span class="line">        count = count + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> countTo &lt; <span class="built_in">len</span>(strCheck):</span><br><span class="line">        csum = csum + strCheck[<span class="built_in">len</span>(strCheck) - <span class="number">1</span>]</span><br><span class="line">        csum = csum &amp; <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line">    csum = (csum &gt;&gt; <span class="number">16</span>) + (csum &amp; <span class="number">0xffff</span>)</span><br><span class="line">    csum = csum + (csum &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    answer = ~csum</span><br><span class="line">    answer = answer &amp; <span class="number">0xffff</span></span><br><span class="line">    answer = answer &gt;&gt; <span class="number">8</span> | (answer &lt;&lt; <span class="number">8</span> &amp; <span class="number">0xff00</span>)</span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receiveOnePing</span>(<span class="params">mySocket, ID, timeout, destAddr</span>):</span></span><br><span class="line">    timeLeft = timeout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        startedSelect = time.time()</span><br><span class="line">        whatReady = select.select([mySocket], [], [], timeLeft)</span><br><span class="line">        howLongInSelect = (time.time() - startedSelect)</span><br><span class="line">        <span class="keyword">if</span> whatReady[<span class="number">0</span>] == []:  <span class="comment"># Timeout</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Request timed out.&quot;</span></span><br><span class="line"></span><br><span class="line">        timeReceived = time.time()</span><br><span class="line">        recPacket, addr = mySocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        header = recPacket[<span class="number">20</span>:<span class="number">28</span>]</span><br><span class="line">        header_type, header_code, header_checksum, header_packet_ID, header_sequence = struct.unpack(<span class="string">&quot;bbHHh&quot;</span>, header)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(header_type != <span class="number">0</span> <span class="keyword">or</span> header_code != <span class="number">0</span> <span class="keyword">or</span> header_packet_ID != ID <span class="keyword">or</span> header_sequence != <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span>(header_type == <span class="number">3</span> <span class="keyword">and</span> header_code == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;目的网络不可达&quot;</span></span><br><span class="line">            <span class="keyword">if</span>(header_type == <span class="number">3</span> <span class="keyword">and</span> header_code == <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;目的主机不可达&quot;</span></span><br><span class="line">            <span class="keyword">if</span>(header_type == <span class="number">3</span> <span class="keyword">and</span> header_code == <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;目的协议不可达&quot;</span></span><br><span class="line">            <span class="keyword">if</span>(header_type == <span class="number">3</span> <span class="keyword">and</span> header_code == <span class="number">3</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;目的端口不可达&quot;</span></span><br><span class="line">            <span class="keyword">if</span>(header_type == <span class="number">3</span> <span class="keyword">and</span> header_code == <span class="number">6</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;目的网络未知&quot;</span></span><br><span class="line">            <span class="keyword">if</span>(header_type == <span class="number">3</span> <span class="keyword">and</span> header_code == <span class="number">7</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;目的主机未知&quot;</span></span><br><span class="line">            <span class="keyword">if</span>(header_type == <span class="number">4</span> <span class="keyword">and</span> header_code == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;源抑制&quot;</span></span><br><span class="line">            <span class="keyword">if</span>(header_type == <span class="number">12</span> <span class="keyword">and</span> header_code == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;IP首部损坏&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Request error.&quot;</span></span><br><span class="line"></span><br><span class="line">        timeLeft = timeLeft - howLongInSelect</span><br><span class="line">        <span class="keyword">if</span> timeLeft &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Request timed out.&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> - timeLeft</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendOnePing</span>(<span class="params">mySocket, destAddr, ID</span>):</span></span><br><span class="line">    <span class="comment"># Header is type (8), code (8), checksum (16), id (16), sequence (16)</span></span><br><span class="line"></span><br><span class="line">    myChecksum = <span class="number">0</span></span><br><span class="line">    <span class="comment"># Make a dummy header with a 0 checksum.</span></span><br><span class="line">    <span class="comment"># 创建一个带有0校验和的伪头。</span></span><br><span class="line">    <span class="comment"># struct -- Interpret strings as packed binary data</span></span><br><span class="line">    <span class="comment"># struct-将字符串解释为打包的二进制数据</span></span><br><span class="line">    header = struct.pack(<span class="string">&quot;bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, <span class="number">1</span>)</span><br><span class="line">    data = struct.pack(<span class="string">&quot;d&quot;</span>, time.time())</span><br><span class="line">    <span class="comment"># Calculate the checksum on the data and the dummy header.</span></span><br><span class="line">    <span class="comment"># 计算数据和虚拟头的校验和。</span></span><br><span class="line">    myChecksum = checksum(header + data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get the right checksum, and put in the header</span></span><br><span class="line">    <span class="keyword">if</span> sys.platform == <span class="string">&#x27;darwin&#x27;</span>:</span><br><span class="line">        myChecksum = socket.htons(myChecksum) &amp; <span class="number">0xffff</span></span><br><span class="line">        <span class="comment"># Convert 16-bit integers from host to network byte order.</span></span><br><span class="line">        <span class="comment"># 将主机的16位整数转换为网络字节顺序。</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        myChecksum = socket.htons(myChecksum)</span><br><span class="line"></span><br><span class="line">    header = struct.pack(<span class="string">&quot;bbHHh&quot;</span>, ICMP_ECHO_REQUEST, <span class="number">0</span>, myChecksum, ID, <span class="number">1</span>)</span><br><span class="line">    packet = header + data</span><br><span class="line"></span><br><span class="line">    mySocket.sendto(packet, (destAddr, <span class="number">1</span>))  <span class="comment"># AF_INET address must be tuple, not str</span></span><br><span class="line">    <span class="comment"># Both LISTS and TUPLES consist of a number of objects</span></span><br><span class="line">    <span class="comment"># which can be referenced by their position number within the object</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doOnePing</span>(<span class="params">destAddr, timeout</span>):</span></span><br><span class="line">    icmp = socket.getprotobyname(<span class="string">&quot;icmp&quot;</span>)</span><br><span class="line"></span><br><span class="line">    mySocket = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp)</span><br><span class="line"></span><br><span class="line">    myID = os.getpid() &amp; <span class="number">0xFFFF</span>  <span class="comment"># Return the current process i</span></span><br><span class="line">    sendOnePing(mySocket, destAddr, myID)</span><br><span class="line">    delay = receiveOnePing(mySocket, myID, timeout, destAddr)</span><br><span class="line"></span><br><span class="line">    mySocket.close()</span><br><span class="line">    <span class="keyword">return</span> delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping</span>(<span class="params">host, timeout=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="comment"># timeout=1 means: If one second goes by without a reply from the server,</span></span><br><span class="line">    <span class="comment"># the client assumes that either the client’s ping or the server’s pong is lost</span></span><br><span class="line">    <span class="comment"># timeout = 1 表示：如果一秒钟没有收到服务器的答复，则客户端会认为客户端的ping或服务器的pong丢失了</span></span><br><span class="line">    dest = socket.gethostbyname(host)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在 Ping&quot;</span>, host, <span class="string">&quot;[&quot;</span>, dest, <span class="string">&quot;] :&quot;</span>)</span><br><span class="line">    <span class="comment"># Send ping requests to a server separated by approximately one second</span></span><br><span class="line">    <span class="comment"># 将ping请求发送到间隔约一秒钟的服务器</span></span><br><span class="line">    num = <span class="number">4</span></span><br><span class="line">    lost = <span class="number">0</span></span><br><span class="line">    delayList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        delay = doOnePing(dest, timeout)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">type</span>(delay) == <span class="built_in">str</span>):</span><br><span class="line">            <span class="built_in">print</span>(delay)</span><br><span class="line">            lost = lost + <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        delay = <span class="built_in">int</span>(delay * <span class="number">1000</span>)</span><br><span class="line">        delayList.append(delay)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;来自&quot;</span>, dest, <span class="string">&quot;的回复: 时间=&quot;</span>, delay, <span class="string">&quot;ms&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)  <span class="comment"># one second</span></span><br><span class="line">    <span class="built_in">print</span>(dest, <span class="string">&quot;的 Ping 统计信息:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\t数据包: 已发送 =&quot;</span>, num, <span class="string">&quot;，已接收 =&quot;</span>, num - lost, <span class="string">&quot;，丢失 =&quot;</span>, lost, <span class="string">&quot;(&quot;</span>, lost/num * <span class="number">100</span>, <span class="string">&quot;% 丢失)&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(delayList):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;往返行程的估计时间(以毫秒为单位):&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\t最短 =&quot;</span>, <span class="built_in">min</span>(delayList), <span class="string">&quot;ms，最长 =&quot;</span>, <span class="built_in">max</span>(delayList), <span class="string">&quot;ms，平均 =&quot;</span>, <span class="built_in">sum</span>(delayList)/<span class="built_in">len</span>(delayList), <span class="string">&quot;ms&quot;</span>)</span><br><span class="line"></span><br><span class="line">ping(<span class="string">&quot;www.12306.cn&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br><br><br>因特网控制报文协议（ICMP）<br>ICMP Header</p>
<p>ICMP报头从IP报头的第160位开始（使用IP选项除外）。<br><a href="/WestRoute.github.io/images/icmp.png" class="gallery-item"><img src="/WestRoute.github.io/images/icmp.png"></a><br>Type - ICMP 类型。<br>Code - 给定ICMP类型的子类型。<br>Checksum - 用ICMP头和ICMP数据计算出来的错误校验和，计算时将本字段值作为0输入。<br>ID - ID值，应在回显的情况下返回。<br>Sequence - 序列值，应在回显的情况下返回。<br>Echo Request</p>
<p>回显请求是一个ICMP消息，其数据将在回显（”pong”）中接收回来。主机必须响应所有回显请求，并在回显响应中包含从请求消息中接收到的所有数据。</p>
<ol>
<li><p>Type必须置为8。</p>
</li>
<li><p>Code必须置为0。</p>
</li>
<li><p>客户机可以使用ID值和Sequence值来匹配响应和请求。实际上，大多数Linux系统都为每一个ping进程使用唯一ID值，Sequence值在该进程中是不断递增的。Windows使用一个固定ID值，该标识符在Windows版本之间变化，并且只在启动时重置Sequence值。</p>
</li>
<li><p>接收到的回显响应必须完全包含回显请求中的数据。<br>Echo Reply 回显响应是用于响应回显请求而生成的ICMP消息，所有主机和路由器都必须实现该功能。</p>
</li>
<li><p>Type和Code必须置为0。</p>
</li>
<li><p>ID值和Sequence值用于让客户端匹配回显请求和回显响应。</p>
</li>
<li><p>回显响应必须完全包含接收到的回显请求中的数据。</p>
</li>
</ol>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>关于nmap</title>
    <url>/BassHero.github.io/2021/12/09/ISBN978-7-111-45378-9-05/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>参考来自：<a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer">Computer Network A Top-Down Approach Practice Answer-github</a></p>
<span id="more"></span>

<h2 id="chapter3"><a href="#chapter3" class="headerlink" title="chapter3"></a>chapter3</h2><p>RTT （Round Trip Time）<br>GBN协议：发送报文段9次，ACK8次<br>SR协议：发送报文段6次，ACK5次<br>TCP协议：发送报文段6次，ACK5次</p>
<h3 id="关于nmap的小实验"><a href="#关于nmap的小实验" class="headerlink" title="关于nmap的小实验"></a>关于nmap的小实验</h3><p>1.windows没有nmap工具，需要手动下载：<a href="https://nmap.org/">https://nmap.org/</a><br>2.检测目标主机某端口的TCP是否开放</p>
<p>无法到达指定的端口，可能是由于防火墙</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sT -p80 192.168.2.220</span><br><span class="line">Starting Nmap 7.80 ( https://nmap.org ) at 2019-12-07 14:48 ?D1ú±ê×?ê±??</span><br><span class="line">Nmap scan report for MI9-jzphone.lan (192.168.2.220)</span><br><span class="line">Host is up (0.074s latency).</span><br><span class="line"></span><br><span class="line">PORT   STATE    SERVICE</span><br><span class="line">80/tcp filtered http</span><br><span class="line">MAC Address: A8:9C:ED:A7:D9:EC (Xiaomi Communications)</span><br><span class="line"></span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 2.33 seconds</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>端口打开</span></figcaption><table><tr><td class="code"><pre><span class="line">nmap -sT -p80 192.168.2.1</span><br><span class="line">Starting Nmap 7.80 ( https://nmap.org ) at 2019-12-07 14:51 ?D1ú±ê×?ê±??</span><br><span class="line">Nmap scan report for phicomm.me (192.168.2.1)</span><br><span class="line">Host is up (0.0024s latency).</span><br><span class="line"></span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">80/tcp open  http</span><br><span class="line">MAC Address: 68:DB:54:CC:6B:BE (Phicomm (Shanghai))</span><br><span class="line"></span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 1.47 seconds</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>端口关闭</span></figcaption><table><tr><td class="code"><pre><span class="line">nmap -sT -p80 192.168.2.239</span><br><span class="line">Starting Nmap 7.80 ( https://nmap.org ) at 2019-12-07 14:56 ?D1ú±ê×?ê±??</span><br><span class="line">Nmap scan report for LAPTOP-3CP7H0GM.lan (192.168.2.239)</span><br><span class="line">Host is up (1.0s latency).</span><br><span class="line"></span><br><span class="line">PORT   STATE  SERVICE</span><br><span class="line">80/tcp closed http</span><br><span class="line"></span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 3.38 seconds</span><br></pre></td></tr></table></figure>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>套接字编程作业4：多线程Web代理服务器</title>
    <url>/BassHero.github.io/2021/12/09/ISBN978-7-111-45378-9-04/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>参考来自：<a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer">Computer Network A Top-Down Approach Practice Answer-github</a></p>
<span id="more"></span>
<h3 id="套接字编程作业4：多线程Web代理服务器"><a href="#套接字编程作业4：多线程Web代理服务器" class="headerlink" title="套接字编程作业4：多线程Web代理服务器"></a>套接字编程作业4：多线程Web代理服务器</h3><p>客户端通过代理服务器请求对象。代理服务器将客户端的请求转发到Web服务器。然后，Web服务器将生成响应消息并将其传递给代理服务器，代理服务器又将其发送给客户端。</p>
<h4 id="运行代理服务器"><a href="#运行代理服务器" class="headerlink" title="运行代理服务器"></a>运行代理服务器</h4><p>使用命令行模式运行您的代理服务器程序，然后从您的浏览器发送一个网页请求，将IP地址和端口号指向代理服务器。 例如：<a href="http://localhost:8888/www.google.com">http://localhost:8888/www.google.com</a> 为了在独立的计算机上使用浏览器和代理服务器， 因此，在运行代理服务器时，您需要将“localhost”更换为代理服务器的所在机器的IP地址。您还需要将“8888”替换您在代理服务程序中使用的端口号。</p>
<h4 id="配置浏览器"><a href="#配置浏览器" class="headerlink" title="配置浏览器"></a>配置浏览器</h4><p>您还可以直接配置您的Web浏览器以使用您的代理服务。 具体取决于您的浏览器。在Internet Explorer中，您可以在 工具 &gt; Internet选项 &gt; 连接选项卡 &gt; LAN设置 中设置代理。 在Netscape（包括衍生浏览器，如Mozilla）中，您可以在 工具 &gt; 选项 &gt; 高级选项 &gt; 网络选项 &gt; 连接设置 中设置代理。 在这两种情况下你都需要给出代理服务器的地址和端口号。你首先要毫无问题地在同一台计算机上运行代理服务器和浏览器。这种方式下，使用代理服务器获取网页就只需提供页面的URL。 例如 <a href="http://www.google.com/">http://www.google.com</a><br><br><br></p>
<figure class="highlight python"><figcaption><span>代理服务器的Python代码框架</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt;= <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Usage : &quot;python ProxyServer.py server_ip&quot;\n[server_ip : It is the IP Address Of Proxy Server&#x27;</span></span><br><span class="line">	sys.exit(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Create a server socket, bind it to a port and start listening</span></span><br><span class="line">tcpSerSock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="comment"># Fill in start.</span></span><br><span class="line"><span class="comment"># Fill in end.</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">	<span class="comment"># Strat receiving data from the client</span></span><br><span class="line">	<span class="built_in">print</span> <span class="string">&#x27;Ready to serve...&#x27;</span></span><br><span class="line">	tcpCliSock, addr = tcpSerSock.accept()</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&#x27;Received a connection from:&#x27;</span>, addr</span><br><span class="line">	message = <span class="comment"># Fill in start. # Fill in end.</span></span><br><span class="line">	<span class="built_in">print</span> message</span><br><span class="line">	<span class="comment"># Extract the filename from the given message</span></span><br><span class="line">	<span class="built_in">print</span> message.split()[<span class="number">1</span>]</span><br><span class="line">	filename = message.split()[<span class="number">1</span>].partition(<span class="string">&quot;/&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">	<span class="built_in">print</span> filename</span><br><span class="line">	fileExist = <span class="string">&quot;false&quot;</span></span><br><span class="line">	filetouse = <span class="string">&quot;/&quot;</span> + filename</span><br><span class="line">	<span class="built_in">print</span> filetouse</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="comment"># Check wether the file exist in the cache</span></span><br><span class="line">		f = <span class="built_in">open</span>(filetouse[<span class="number">1</span>:], <span class="string">&quot;r&quot;</span>)</span><br><span class="line">		outputdata = f.readlines()</span><br><span class="line">		fileExist = <span class="string">&quot;true&quot;</span></span><br><span class="line">		<span class="comment"># ProxyServer finds a cache hit and generates a response message</span></span><br><span class="line">		tcpCliSock.send(<span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>)</span><br><span class="line">		tcpCliSock.send(<span class="string">&quot;Content-Type:text/html\r\n&quot;</span>)</span><br><span class="line">		<span class="comment"># Fill in start.</span></span><br><span class="line">		<span class="comment"># Fill in end.</span></span><br><span class="line">			<span class="built_in">print</span> <span class="string">&#x27;Read from cache&#x27;</span></span><br><span class="line">	<span class="comment"># Error handling for file not found in cache</span></span><br><span class="line">	<span class="keyword">except</span> IOError:</span><br><span class="line">		<span class="keyword">if</span> fileExist == <span class="string">&quot;false&quot;</span>:</span><br><span class="line">			<span class="comment"># Create a socket on the proxyserver</span></span><br><span class="line">			c = <span class="comment"># Fill in start. # Fill in end.</span></span><br><span class="line">			hostn = filename.replace(<span class="string">&quot;www.&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">1</span>) </span><br><span class="line">			<span class="built_in">print</span> hostn</span><br><span class="line">			<span class="keyword">try</span>:</span><br><span class="line">				<span class="comment"># Connect to the socket to port 80</span></span><br><span class="line">				<span class="comment"># Fill in start.</span></span><br><span class="line">				<span class="comment"># Fill in end.</span></span><br><span class="line">				<span class="comment"># Create a temporary file on this socket and ask port 80</span></span><br><span class="line">				<span class="keyword">for</span> the file requested by the client</span><br><span class="line">				fileobj = c.makefile(<span class="string">&#x27;r&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">				fileobj.write(<span class="string">&quot;GET &quot;</span>+<span class="string">&quot;http://&quot;</span> + filename + <span class="string">&quot; HTTP/1.0\n\n&quot;</span>)</span><br><span class="line">				<span class="comment"># Read the response into buffer</span></span><br><span class="line">				<span class="comment"># Fill in start.</span></span><br><span class="line">				<span class="comment"># Fill in end.</span></span><br><span class="line">				<span class="comment"># Create a new file in the cache for the requested file.</span></span><br><span class="line">				<span class="comment"># Also send the response in the buffer to client socket and the corresponding file in the cache</span></span><br><span class="line">				tmpFile = <span class="built_in">open</span>(<span class="string">&quot;./&quot;</span> + filename,<span class="string">&quot;wb&quot;</span>)</span><br><span class="line">				<span class="comment"># Fill in start.</span></span><br><span class="line">				<span class="comment"># Fill in end.</span></span><br><span class="line">			<span class="keyword">except</span>:</span><br><span class="line">				<span class="built_in">print</span> <span class="string">&quot;Illegal request&quot;</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="comment"># HTTP response message for file not found</span></span><br><span class="line">			<span class="comment"># Fill in start.</span></span><br><span class="line">			<span class="comment"># Fill in end.</span></span><br><span class="line">	<span class="comment"># Close the client and the server sockets</span></span><br><span class="line">	tcpCliSock.close()</span><br><span class="line"><span class="comment"># Fill in start.</span></span><br><span class="line"><span class="comment"># Fill in end.</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><br><br></p>
<figure class="highlight python"><figcaption><span>答案</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt;= <span class="number">1</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Usage : &quot;python ProxyServer.py server_ip&quot;\n[server_ip : It is the IP Address Of Proxy Server&#x27;</span>)</span><br><span class="line">	sys.exit(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#Create a server socket, bind it to a port and start listening</span></span><br><span class="line">tcpSerSock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">tcpSerPort = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">tcpSerSock.bind((<span class="string">&quot;&quot;</span>, tcpSerPort))</span><br><span class="line"><span class="built_in">print</span>(tcpSerPort)</span><br><span class="line">tcpSerSock.listen(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">	<span class="comment"># Strat receiving data from the client</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Ready to serve...&#x27;</span>)</span><br><span class="line">	tcpCliSock, addr = tcpSerSock.accept()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Received a connection from:&#x27;</span>, addr)</span><br><span class="line">	message = tcpCliSock.recv(<span class="number">1024</span>)</span><br><span class="line">	message = message.decode()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;message:&quot;</span>, message)</span><br><span class="line">	<span class="keyword">if</span>(message == <span class="string">&#x27;&#x27;</span>):</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	<span class="comment"># Extract the filename from the given message</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;message.split()[1]:&quot;</span>, message.split()[<span class="number">1</span>])</span><br><span class="line">	filename = message.split()[<span class="number">1</span>].partition(<span class="string">&quot;/&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;filename:&quot;</span>, filename)</span><br><span class="line">	fileExist = <span class="string">&quot;false&quot;</span></span><br><span class="line">	filetouse = <span class="string">&quot;/&quot;</span> + filename</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;filetouse:&quot;</span>, filetouse)</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="comment"># Check wether the file exist in the cache</span></span><br><span class="line">		f = <span class="built_in">open</span>(<span class="string">&quot;WEB/&quot;</span> + filetouse[<span class="number">1</span>:], <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">		outputdata = f.read()</span><br><span class="line">		f.close()</span><br><span class="line">		fileExist = <span class="string">&quot;true&quot;</span></span><br><span class="line">		<span class="comment">#ProxyServer finds a cache hit and generates a response message</span></span><br><span class="line">		tcpCliSock.send(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.encode())</span><br><span class="line">		tcpCliSock.send(<span class="string">&quot;Content-Type:text/html\r\n\r\n&quot;</span>.encode())</span><br><span class="line">		tcpCliSock.send(outputdata)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;Read from cache&#x27;</span>)</span><br><span class="line">	<span class="comment">#Error handling for file not found in cache</span></span><br><span class="line">	<span class="keyword">except</span> IOError:</span><br><span class="line">		<span class="keyword">if</span> fileExist == <span class="string">&quot;false&quot;</span>:</span><br><span class="line">			<span class="comment">#Create a socket on the proxyserver</span></span><br><span class="line">			c = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">			hostn = filename.replace(<span class="string">&quot;www.&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">1</span>)</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;hostn:&quot;</span>, hostn)</span><br><span class="line">			<span class="keyword">try</span>:</span><br><span class="line">				<span class="comment">#Connect to the socket to port 80</span></span><br><span class="line">				serverName = hostn.partition(<span class="string">&quot;/&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">				serverPort = <span class="number">80</span></span><br><span class="line">				<span class="built_in">print</span>((serverName, serverPort))</span><br><span class="line">				c.connect((serverName, serverPort))</span><br><span class="line">				askFile = <span class="string">&#x27;&#x27;</span>.join(filename.partition(<span class="string">&#x27;/&#x27;</span>)[<span class="number">1</span>:])</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">&quot;askFile:&quot;</span>, askFile)</span><br><span class="line">				<span class="comment">#Create a temporary file on this socket and ask port 80</span></span><br><span class="line">				<span class="comment">#for the file requested by the client</span></span><br><span class="line">				fileobj = c.makefile(<span class="string">&#x27;rwb&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">				fileobj.write(<span class="string">&quot;GET &quot;</span>.encode() + askFile.encode() + <span class="string">&quot; HTTP/1.0\r\nHost: &quot;</span>.encode() + serverName.encode() + <span class="string">&quot;\r\n\r\n&quot;</span>.encode())</span><br><span class="line">				<span class="comment">#Read the response into buffer</span></span><br><span class="line">				serverResponse = fileobj.read()</span><br><span class="line">				<span class="comment">#Create a new file in the cache for the requested file.</span></span><br><span class="line">				<span class="comment">#Also send the response in the buffer to client socket and the corresponding file in the cache</span></span><br><span class="line">				filename = <span class="string">&quot;WEB/&quot;</span> + filename</span><br><span class="line">				filesplit = filename.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">				<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(filesplit) - <span class="number">1</span>):</span><br><span class="line">					<span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;/&quot;</span>.join(filesplit[<span class="number">0</span>:i+<span class="number">1</span>])):</span><br><span class="line">						os.makedirs(<span class="string">&quot;/&quot;</span>.join(filesplit[<span class="number">0</span>:i+<span class="number">1</span>]))</span><br><span class="line">				tmpFile = <span class="built_in">open</span>(filename, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">				<span class="built_in">print</span>(serverResponse)</span><br><span class="line">				serverResponse = serverResponse.split(<span class="string">b&#x27;\r\n\r\n&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">				<span class="built_in">print</span>(serverResponse)</span><br><span class="line">				tmpFile.write(serverResponse)</span><br><span class="line">				tmpFile.close()</span><br><span class="line">				tcpCliSock.send(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.encode())</span><br><span class="line">				tcpCliSock.send(<span class="string">&quot;Content-Type:text/html\r\n\r\n&quot;</span>.encode())</span><br><span class="line">				tcpCliSock.send(serverResponse)</span><br><span class="line">			<span class="keyword">except</span>:</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">&quot;Illegal request&quot;</span>)</span><br><span class="line">			c.close()</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="comment">#HTTP response message for file not found</span></span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;NET ERROR&quot;</span>)</span><br><span class="line">	<span class="comment">#Close the client and the server sockets</span></span><br><span class="line">	tcpCliSock.close()</span><br><span class="line">tcpSerSock.close()</span><br></pre></td></tr></table></figure>

<p><br><br><br><strong>可选练习</strong><br>1.目前代理服务器不能处理错误。这可能会导致一些问题，当客户端请求一个不可用的对象时，由于“404 Not Found”响应通常没有响应正文，而代理服务器会假设有正文并尝试读取它。当前代理服务器只支持HTTP GET方法。通过添加请求体来增加对POST的支持。<br><br></p>
<figure class="highlight python"><figcaption><span>答案</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">#改为Python3格式</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt;= <span class="number">1</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Usage : &quot;python ProxyServer.py server_ip&quot;\n[server_ip : It is the IP Address Of Proxy Server&#x27;</span>)</span><br><span class="line">	sys.exit(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#Create a server socket, bind it to a port and start listening</span></span><br><span class="line">tcpSerSock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">tcpSerPort = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">tcpSerSock.bind((<span class="string">&quot;&quot;</span>, tcpSerPort))</span><br><span class="line"><span class="built_in">print</span>(tcpSerPort)</span><br><span class="line">tcpSerSock.listen(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">	<span class="comment"># Strat receiving data from the client</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Ready to serve...&#x27;</span>)</span><br><span class="line">	tcpCliSock, addr = tcpSerSock.accept()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Received a connection from:&#x27;</span>, addr)</span><br><span class="line">	message = tcpCliSock.recv(<span class="number">1024</span>)</span><br><span class="line">	message = message.decode()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;message:&quot;</span>, message)</span><br><span class="line">	<span class="keyword">if</span>(message == <span class="string">&#x27;&#x27;</span>):</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	<span class="comment"># Extract the filename from the given message</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;message.split()[1]:&quot;</span>, message.split()[<span class="number">1</span>])</span><br><span class="line">	filename = message.split()[<span class="number">1</span>].partition(<span class="string">&quot;/&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;filename:&quot;</span>, filename)</span><br><span class="line">	fileExist = <span class="string">&quot;false&quot;</span></span><br><span class="line">	filetouse = <span class="string">&quot;/&quot;</span> + filename</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;filetouse:&quot;</span>, filetouse)</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="comment"># Check wether the file exist in the cache</span></span><br><span class="line">		f = <span class="built_in">open</span>(<span class="string">&quot;WEB/&quot;</span> + filetouse[<span class="number">1</span>:], <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">		outputdata = f.read()</span><br><span class="line">		f.close()</span><br><span class="line">		fileExist = <span class="string">&quot;true&quot;</span></span><br><span class="line">		<span class="comment">#ProxyServer finds a cache hit and generates a response message</span></span><br><span class="line">		tcpCliSock.send(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.encode())</span><br><span class="line">		tcpCliSock.send(<span class="string">&quot;Content-Type:text/html\r\n\r\n&quot;</span>.encode())</span><br><span class="line">		tcpCliSock.send(outputdata)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;Read from cache&#x27;</span>)</span><br><span class="line">	<span class="comment">#Error handling for file not found in cache</span></span><br><span class="line">	<span class="keyword">except</span> IOError:</span><br><span class="line">		<span class="keyword">if</span> fileExist == <span class="string">&quot;false&quot;</span>:</span><br><span class="line">			<span class="comment">#Create a socket on the proxyserver</span></span><br><span class="line">			c = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">			hostn = filename.replace(<span class="string">&quot;www.&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">1</span>)</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;hostn:&quot;</span>, hostn)</span><br><span class="line">			<span class="keyword">try</span>:</span><br><span class="line">				<span class="comment">#Connect to the socket to port 80</span></span><br><span class="line">				serverName = hostn.partition(<span class="string">&quot;/&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">				serverPort = <span class="number">80</span></span><br><span class="line">				<span class="built_in">print</span>((serverName, serverPort))</span><br><span class="line">				c.connect((serverName, serverPort))</span><br><span class="line">				askFile = <span class="string">&#x27;&#x27;</span>.join(filename.partition(<span class="string">&#x27;/&#x27;</span>)[<span class="number">1</span>:])</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">&quot;askFile:&quot;</span>, askFile)</span><br><span class="line">				<span class="comment">#Create a temporary file on this socket and ask port 80</span></span><br><span class="line">				<span class="comment">#for the file requested by the client</span></span><br><span class="line">				fileobj = c.makefile(<span class="string">&#x27;rwb&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">				fileobj.write(<span class="string">&quot;GET &quot;</span>.encode() + askFile.encode() + <span class="string">&quot; HTTP/1.0\r\nHost: &quot;</span>.encode() + serverName.encode() + <span class="string">&quot;\r\n\r\n&quot;</span>.encode())</span><br><span class="line">				<span class="comment">#Read the response into buffer</span></span><br><span class="line">				serverResponse = fileobj.read()</span><br><span class="line">				<span class="comment">#Create a new file in the cache for the requested file.</span></span><br><span class="line">				<span class="comment">#Also send the response in the buffer to client socket and the corresponding file in the cache</span></span><br><span class="line">				filename = <span class="string">&quot;WEB/&quot;</span> + filename</span><br><span class="line">				filesplit = filename.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">				<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(filesplit) - <span class="number">1</span>):</span><br><span class="line">					<span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;/&quot;</span>.join(filesplit[<span class="number">0</span>:i+<span class="number">1</span>])):</span><br><span class="line">						os.makedirs(<span class="string">&quot;/&quot;</span>.join(filesplit[<span class="number">0</span>:i+<span class="number">1</span>]))</span><br><span class="line">				tmpFile = <span class="built_in">open</span>(filename, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">				<span class="built_in">print</span>(serverResponse)</span><br><span class="line">				serverResponse = serverResponse.split(<span class="string">b&#x27;\r\n\r\n&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">				<span class="built_in">print</span>(serverResponse)</span><br><span class="line">				tmpFile.write(serverResponse)</span><br><span class="line">				tmpFile.close()</span><br><span class="line">				tcpCliSock.send(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.encode())</span><br><span class="line">				tcpCliSock.send(<span class="string">&quot;Content-Type:text/html\r\n\r\n&quot;</span>.encode())</span><br><span class="line">				tcpCliSock.send(serverResponse)</span><br><span class="line">			<span class="keyword">except</span>:</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">&quot;Illegal request&quot;</span>)</span><br><span class="line">			c.close()</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="comment">#HTTP response message for file not found</span></span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;NET ERROR&quot;</span>)</span><br><span class="line">	<span class="comment">#Close the client and the server sockets</span></span><br><span class="line">	tcpCliSock.close()</span><br><span class="line">tcpSerSock.close()</span><br></pre></td></tr></table></figure>

<br>
3.缓存：<br>
每当客户端发出特定请求时，典型的代理服务器会缓存网页。缓存的基本功能如下：当代理获得一个请求时，它将检查请求的对象是否已经在缓存中，如果是，则从缓存返回对象，从而不用联系服务器。<br><br>
如果对象未被缓存，则代理从服务器获取该对象，向客户端返回该对象，并缓存一个拷贝以备将来的请求。在实际环境下，代理服务器必须验证被缓存的响应是否仍然有效，并且它们能对客户端正确响应。您可以在RFC 2068中阅读有关缓存及其在HTTP中实现方式的更多细节。<br><br>
添加上述简单的缓存功能。您不需要实现任何替换或验证策略。然而您需要实现的是，将请求和响应写入磁盘（即缓存）并能从磁盘中获取它们，用于缓存被请求命中时。为此，您需要在代理中实现一些内部数据结构，以便跟踪哪些请求处于缓存中时，以及它们在磁盘上的位置。您也可以将此数据结构保存在内存中，因为没有必要关机之后持续保存这些数据。
<br>


<figure class="highlight python"><figcaption><span>答案</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt;= <span class="number">1</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Usage : &quot;python ProxyServer.py server_ip&quot;\n[server_ip : It is the IP Address Of Proxy Server&#x27;</span>)</span><br><span class="line">	sys.exit(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#Create a server socket, bind it to a port and start listening</span></span><br><span class="line">tcpSerSock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">tcpSerPort = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">tcpSerSock.bind((<span class="string">&quot;&quot;</span>, tcpSerPort))</span><br><span class="line"><span class="built_in">print</span>(tcpSerPort)</span><br><span class="line">tcpSerSock.listen(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">#Strat receiving data from the client</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Ready to serve...&#x27;</span>)</span><br><span class="line">    tcpCliSock, addr = tcpSerSock.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Received a connection from:&#x27;</span>, addr)</span><br><span class="line">    message = tcpCliSock.recv(<span class="number">1024</span>)</span><br><span class="line">    message = message.decode()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;message:&quot;</span>, message)</span><br><span class="line">    <span class="keyword">if</span>(message == <span class="string">&#x27;&#x27;</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">#Extract the filename from the given message</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;message.split()[1]:&quot;</span>, message.split()[<span class="number">1</span>])</span><br><span class="line">    filename = message.split()[<span class="number">1</span>].partition(<span class="string">&quot;/&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;filename:&quot;</span>, filename)</span><br><span class="line">    fileExist = <span class="string">&quot;false&quot;</span></span><br><span class="line">    filetouse = <span class="string">&quot;/&quot;</span> + filename</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;filetouse:&quot;</span>, filetouse)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#Check wether the file exist in the cache</span></span><br><span class="line">        f = <span class="built_in">open</span>(<span class="string">&quot;WEB/&quot;</span> + filetouse[<span class="number">1</span>:], <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">        outputdata = f.read()</span><br><span class="line">        f.close()</span><br><span class="line">        fileExist = <span class="string">&quot;true&quot;</span></span><br><span class="line">        <span class="comment"># ProxyServer finds a cache hit and generates a response message</span></span><br><span class="line">        tcpCliSock.send(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.encode())</span><br><span class="line">        tcpCliSock.send(<span class="string">&quot;Content-Type:text/html\r\n\r\n&quot;</span>.encode())</span><br><span class="line">        tcpCliSock.send(outputdata)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Read from cache&#x27;</span>)</span><br><span class="line">    <span class="comment">#Error handling for file not found in cache</span></span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="keyword">if</span> fileExist == <span class="string">&quot;false&quot;</span>:</span><br><span class="line">            <span class="comment">#Create a socket on the proxyserver</span></span><br><span class="line">            c = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">            hostn = filename.replace(<span class="string">&quot;www.&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;hostn:&quot;</span>, hostn)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment">#Connect to the socket to port 80</span></span><br><span class="line">                serverName = hostn.partition(<span class="string">&quot;/&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">                serverPort = <span class="number">80</span></span><br><span class="line">                <span class="built_in">print</span>((serverName, serverPort))</span><br><span class="line">                c.connect((serverName, serverPort))</span><br><span class="line">                askFile = <span class="string">&#x27;&#x27;</span>.join(filename.partition(<span class="string">&#x27;/&#x27;</span>)[<span class="number">1</span>:])</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;askFile:&quot;</span>, askFile)</span><br><span class="line">                <span class="comment">#Create a temporary file on this socket and ask port 80</span></span><br><span class="line">                <span class="comment">#for the file requested by the client</span></span><br><span class="line">                fileobj = c.makefile(<span class="string">&#x27;rwb&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span>(message.split()[<span class="number">0</span>] == <span class="string">&#x27;GET&#x27;</span>):</span><br><span class="line">                    fileobj.write(<span class="string">&quot;GET &quot;</span>.encode() + askFile.encode() + <span class="string">&quot; HTTP/1.0\r\nHost: &quot;</span>.encode() + serverName.encode() + <span class="string">&quot;\r\n\r\n&quot;</span>.encode())</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment">#POST</span></span><br><span class="line">                    fileobj.write(</span><br><span class="line">                        <span class="string">&quot;POST &quot;</span>.encode() + askFile.encode() + <span class="string">&quot; HTTP/1.0\r\nHost: &quot;</span>.encode() + serverName.encode() + <span class="string">&quot;\r\n\r\n&quot;</span>.encode())</span><br><span class="line">                    fileobj.write(message.split(<span class="string">&quot;\r\n\r\n&quot;</span>)[<span class="number">1</span>].encode())</span><br><span class="line">                <span class="comment">#Read the response into buffer</span></span><br><span class="line">                serverResponse = fileobj.read()</span><br><span class="line">                <span class="keyword">if</span> serverResponse.split()[<span class="number">0</span>] != <span class="string">b&#x27;404&#x27;</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;404&#x27;</span>)</span><br><span class="line">                    tcpCliSock.send(<span class="string">&quot;HTTP/1.1 404 Not Found\r\n\r\n&quot;</span>.encode())</span><br><span class="line">                    tcpCliSock.close()</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">#Create a new file in the cache for the requested file.</span></span><br><span class="line">                <span class="comment">#Also send the response in the buffer to client socket and the corresponding file in the cache</span></span><br><span class="line">                filename = <span class="string">&quot;WEB/&quot;</span> + filename</span><br><span class="line">                filesplit = filename.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(filesplit) - <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;/&quot;</span>.join(filesplit[<span class="number">0</span>:i+<span class="number">1</span>])):</span><br><span class="line">                        os.makedirs(<span class="string">&quot;/&quot;</span>.join(filesplit[<span class="number">0</span>:i+<span class="number">1</span>]))</span><br><span class="line">                tmpFile = <span class="built_in">open</span>(filename, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(serverResponse)</span><br><span class="line">                serverResponse = serverResponse.split(<span class="string">b&#x27;\r\n\r\n&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">                <span class="built_in">print</span>(serverResponse)</span><br><span class="line">                tmpFile.write(serverResponse)</span><br><span class="line">                tmpFile.close()</span><br><span class="line">                tcpCliSock.send(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.encode())</span><br><span class="line">                tcpCliSock.send(<span class="string">&quot;Content-Type:text/html\r\n\r\n&quot;</span>.encode())</span><br><span class="line">                tcpCliSock.send(serverResponse)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Illegal request&quot;</span>)</span><br><span class="line">            c.close()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#HTTP response message for file not found</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;NET ERROR&quot;</span>)</span><br><span class="line">    <span class="comment">#Close the client and the server sockets</span></span><br><span class="line">    tcpCliSock.close()</span><br><span class="line">tcpSerSock.close()</span><br></pre></td></tr></table></figure>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>套接字编程作业3：邮件客户端</title>
    <url>/BassHero.github.io/2021/12/09/ISBN978-7-111-45378-9-03/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>参考来自：<a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer">Computer Network A Top-Down Approach Practice Answer-github</a></p>
<span id="more"></span>

<h3 id="套接字编程作业3：邮件客户端"><a href="#套接字编程作业3：邮件客户端" class="headerlink" title="套接字编程作业3：邮件客户端"></a>套接字编程作业3：邮件客户端</h3><p>您的任务是开发一个简单的邮件客户端，将邮件发送给任意收件人。您的客户端将需要连接到邮件服务器，使用SMTP协议与邮件服务器进行对话，并向邮件服务器发送电子邮件。 Python提供了一个名为smtplib的模块，它内置了使用SMTP协议发送邮件的方法。但是我们不会在本实验中使用此模块，因为它隐藏了SMTP和套接字编程的细节。<br><br><br><br>为了限制垃圾邮件，一些邮件服务器不接受来源随意的TCP连接。对于下面所述的实验，您可能需要尝试连接到您的大学邮件服务器和流行的Webmail服务器（如AOL邮件服务器）。您也可以尝试从您的家和您的大学校园进行连接。<br><br></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">msg = <span class="string">&quot;\r\n I love computer networks!&quot;</span></span><br><span class="line">endmsg = <span class="string">&quot;\r\n.\r\n&quot;</span></span><br><span class="line"><span class="comment"># Choose a mail server (e.g. Google mail server) and call it mailserver </span></span><br><span class="line">mailserver = <span class="comment">#Fill in start   #Fill in end</span></span><br><span class="line"><span class="comment"># Create socket called clientSocket and establish a TCP connection with mailserver</span></span><br><span class="line"><span class="comment">#Fill in start</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Fill in end</span></span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span> recv</span><br><span class="line"><span class="keyword">if</span> recv[:<span class="number">3</span>] != <span class="string">&#x27;220&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;220 reply not received from server.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send HELO command and print server response.</span></span><br><span class="line">heloCommand = <span class="string">&#x27;HELO Alice\r\n&#x27;</span></span><br><span class="line">clientSocket.send(heloCommand)</span><br><span class="line">recv1 = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span> recv1</span><br><span class="line"><span class="keyword">if</span> recv1[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;250 reply not received from server.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send MAIL FROM command and print server response.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send RCPT TO command and print server response.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send DATA command and print server response.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send message data.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Message ends with a single period.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send QUIT command and get server response.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>


<figure class="highlight python"><figcaption><span>答案</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment"># Choose a mail server (e.g. Google mail server) and call it mailserver</span></span><br><span class="line">mailserver = <span class="string">&quot;smtp.163.com&quot;</span></span><br><span class="line">mailUser = <span class="string">&#x27;jz163wy&#x27;</span></span><br><span class="line">mailFromAddress = <span class="string">&#x27;jz163wy@163.com&#x27;</span></span><br><span class="line">mailPassWord = <span class="string">&#x27;******&#x27;</span></span><br><span class="line">mailToAddress = <span class="string">&#x27;ecnujz@qq.com&#x27;</span></span><br><span class="line"></span><br><span class="line">msg = <span class="string">&#x27;FROM: &#x27;</span> + mailFromAddress + <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">msg += <span class="string">&#x27;TO: &#x27;</span> + mailToAddress +  <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">msg += <span class="string">&#x27;Subject: &#x27;</span> + <span class="string">&#x27;test&#x27;</span> +  <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">msg += <span class="string">&quot;\r\n I love computer networks!&quot;</span></span><br><span class="line">endmsg = <span class="string">&quot;\r\n.\r\n&quot;</span></span><br><span class="line"><span class="comment">#Create socket called clientSocket and establish a TCP connection with mailserver</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">clientSocket.connect((mailserver, <span class="number">25</span>))</span><br><span class="line"></span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">recv = recv.decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> recv[:<span class="number">3</span>] != <span class="string">&#x27;220&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;220 reply not received from server.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Send HELO command and print server response.</span></span><br><span class="line">heloCommand = <span class="string">&#x27;HELO mailserver\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocket.send(heloCommand.encode())</span><br><span class="line">    recv = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#登录过程</span></span><br><span class="line">loginCommand = <span class="string">&#x27;auth login\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocket.send(loginCommand.encode())</span><br><span class="line">    recv = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;334&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#邮箱账户经过base64编码</span></span><br><span class="line">userCommand = base64.b64encode(mailUser.encode()) + <span class="string">b&#x27;\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocket.send(userCommand)</span><br><span class="line">    recv = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;334&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#邮箱密码经过base64编码 这里不展示密码了</span></span><br><span class="line">passCommand = base64.b64encode(mailPassWord.encode()) + <span class="string">b&#x27;\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocket.send(passCommand)</span><br><span class="line">    recv = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;235&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send MAIL FROM command and print server response.</span></span><br><span class="line">MFCommand = <span class="string">&#x27;MAIL FROM: &lt;&#x27;</span>+ mailFromAddress + <span class="string">&#x27;&gt;\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocket.send(MFCommand.encode())</span><br><span class="line">    recv = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send RCPT TO command and print server response.</span></span><br><span class="line">RTCommand = <span class="string">&#x27;RCPT TO: &lt;&#x27;</span>+ mailToAddress + <span class="string">&#x27;&gt;\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocket.send(RTCommand.encode())</span><br><span class="line">    recv = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send DATA command and print server response.</span></span><br><span class="line">DATACommand = <span class="string">&#x27;DATA\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocket.send(DATACommand.encode())</span><br><span class="line">    recv = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;354&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send message data.</span></span><br><span class="line">clientSocket.send(msg.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment">#Message ends with a single period.</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocket.send(endmsg.encode())</span><br><span class="line">    recv = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send QUIT command and get server response.</span></span><br><span class="line">QUITCommand = <span class="string">&#x27;QUIT\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocket.send(QUITCommand.encode())</span><br><span class="line">    recv = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;221&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<br>

<p><strong>可选练习</strong><br>1.类似Google邮件的服务器（如地址：smtp.gmail.com，端口：587））要求您的客户端在发送MAIL FROM命令之前，需要为了身份验证和安全原因添加传输层安全（TLS）或安全套接字层（SSL）。将TLS / SSL命令添加到现有的命令中，并使用上述地址和端口为Google邮件服务器实现客户端。<br><br><br></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"></span><br><span class="line"><span class="comment">#Choose a mail server (e.g. Google mail server) and call it mailserver</span></span><br><span class="line">mailserver = <span class="string">&quot;smtp.163.com&quot;</span></span><br><span class="line">mailUser = <span class="string">&#x27;jz163wy&#x27;</span></span><br><span class="line">mailFromAddress = <span class="string">&#x27;jz163wy@163.com&#x27;</span></span><br><span class="line">mailPassWord = <span class="string">&#x27;******&#x27;</span></span><br><span class="line">mailToAddress = <span class="string">&#x27;ecnujz@qq.com&#x27;</span></span><br><span class="line"></span><br><span class="line">msg = <span class="string">&#x27;FROM: &#x27;</span> + mailFromAddress + <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">msg += <span class="string">&#x27;TO: &#x27;</span> + mailToAddress +  <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">msg += <span class="string">&#x27;Subject: &#x27;</span> + <span class="string">&#x27;test&#x27;</span> +  <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">msg += <span class="string">&quot;\r\n I love computer networks!&quot;</span></span><br><span class="line">endmsg = <span class="string">&quot;\r\n.\r\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Create socket called clientSocket and establish a TCP connection with mailserver</span></span><br><span class="line">context = ssl.create_default_context()</span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">clientSocket.connect((mailserver, <span class="number">465</span>))</span><br><span class="line">clientSocketSSL = context.wrap_socket(clientSocket, server_hostname=mailserver)</span><br><span class="line"></span><br><span class="line">recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">recv = recv.decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> recv[:<span class="number">3</span>] != <span class="string">&#x27;220&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;220 reply not received from server.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Send HELO command and print server response.</span></span><br><span class="line">heloCommand = <span class="string">&#x27;HELO mailserver\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(heloCommand.encode())</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#登录过程</span></span><br><span class="line">loginCommand = <span class="string">&#x27;auth login\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(loginCommand.encode())</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;334&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#邮箱账户经过base64编码</span></span><br><span class="line">userCommand = base64.b64encode(mailUser.encode()) + <span class="string">b&#x27;\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(userCommand)</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;334&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#邮箱密码经过base64编码 这里不展示密码了</span></span><br><span class="line">passCommand = base64.b64encode(mailPassWord.encode()) + <span class="string">b&#x27;\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(passCommand)</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;235&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send MAIL FROM command and print server response.</span></span><br><span class="line">MFCommand = <span class="string">&#x27;MAIL FROM: &lt;&#x27;</span>+ mailFromAddress + <span class="string">&#x27;&gt;\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(MFCommand.encode())</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send RCPT TO command and print server response.</span></span><br><span class="line">RTCommand = <span class="string">&#x27;RCPT TO: &lt;&#x27;</span>+ mailToAddress + <span class="string">&#x27;&gt;\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(RTCommand.encode())</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send DATA command and print server response.</span></span><br><span class="line">DATACommand = <span class="string">&#x27;DATA\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(DATACommand.encode())</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;354&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send message data.</span></span><br><span class="line">clientSocketSSL.send(msg.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment">#Message ends with a single period.</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(endmsg.encode())</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send QUIT command and get server response.</span></span><br><span class="line">QUITCommand = <span class="string">&#x27;QUIT\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(QUITCommand.encode())</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;221&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">clientSocketSSL.close()</span><br></pre></td></tr></table></figure>

<br>
2.您当前的SMTP邮件客户端只能在电子邮件正文中发送文本消息。修改您的客户端，使其可以发送包含文本和图像的电子邮件。


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#改为Python3格式</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"></span><br><span class="line"><span class="comment">#Choose a mail server (e.g. Google mail server) and call it mailserver</span></span><br><span class="line">mailserver = <span class="string">&quot;smtp.163.com&quot;</span></span><br><span class="line">mailUser = <span class="string">&#x27;jz163wy&#x27;</span></span><br><span class="line">mailFromAddress = <span class="string">&#x27;jz163wy@163.com&#x27;</span></span><br><span class="line">mailPassWord = <span class="string">&#x27;******&#x27;</span></span><br><span class="line">mailToAddress = <span class="string">&#x27;ecnujz@qq.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#transfer image and html</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;timg.jpg&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    image_data = base64.b64encode(f.read())</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;hello.html&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    html_data = base64.b64encode(f.read())</span><br><span class="line"></span><br><span class="line"><span class="comment">#构造邮件正文</span></span><br><span class="line">msg = <span class="string">&#x27;FROM: &#x27;</span> + mailFromAddress + <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">msg += <span class="string">&#x27;TO: &#x27;</span> + mailToAddress +  <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">msg += <span class="string">&#x27;Subject: &#x27;</span> + <span class="string">&#x27;text and picture&#x27;</span> +  <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">msg += <span class="string">&#x27;Content-Type:multipart/related; boundary=&quot;----=_NextPart_000_0012345JZ&quot;\r\n&#x27;</span></span><br><span class="line">msg += <span class="string">&#x27;MIME-Version: 1.0\r\n&#x27;</span></span><br><span class="line">msg += <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">msg = msg.encode()</span><br><span class="line">msg += <span class="string">&#x27;------=_NextPart_000_0012345JZ\r\n&#x27;</span>.encode()</span><br><span class="line">msg += <span class="string">&#x27;Content-Type: text/html; charset=UTF-8\r\n&#x27;</span>.encode()</span><br><span class="line">msg += <span class="string">&#x27;Content-Transfer-Encoding: base64\r\n&#x27;</span>.encode()</span><br><span class="line">msg += <span class="string">&#x27;\r\n&#x27;</span>.encode()</span><br><span class="line">msg += html_data</span><br><span class="line">msg += <span class="string">&#x27;\r\n&#x27;</span>.encode()</span><br><span class="line">msg += <span class="string">&#x27;\r\n&#x27;</span>.encode()</span><br><span class="line">msg += <span class="string">&#x27;------=_NextPart_000_0012345JZ\r\n&#x27;</span>.encode()</span><br><span class="line">msg += <span class="string">&#x27;Content-Type: image/jpeg; name=&quot;timg.jpg&quot;\r\n&#x27;</span>.encode()</span><br><span class="line">msg += <span class="string">&#x27;Content-Transfer-Encoding: base64\r\n&#x27;</span>.encode()</span><br><span class="line">msg += <span class="string">&#x27;Content-ID: JZJZJZJZJZJZJZJZ&#x27;</span>.encode()</span><br><span class="line">msg += <span class="string">&#x27;\r\n&#x27;</span>.encode()</span><br><span class="line">msg += image_data + <span class="string">&quot;\r\n&quot;</span>.encode()</span><br><span class="line">msg += <span class="string">&#x27;\r\n&#x27;</span>.encode()</span><br><span class="line">msg += <span class="string">&#x27;------=_NextPart_000_0012345JZ--\r\n&#x27;</span>.encode()</span><br><span class="line">endmsg = <span class="string">&quot;\r\n.\r\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Create socket called clientSocket and establish a TCP connection with mailserver</span></span><br><span class="line">context = ssl.create_default_context()</span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">clientSocket.connect((mailserver, <span class="number">465</span>))</span><br><span class="line">clientSocketSSL = context.wrap_socket(clientSocket, server_hostname=mailserver)</span><br><span class="line"></span><br><span class="line">recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">recv = recv.decode()</span><br><span class="line"><span class="built_in">print</span>(recv)</span><br><span class="line"><span class="keyword">if</span> recv[:<span class="number">3</span>] != <span class="string">&#x27;220&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;220 reply not received from server.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Send HELO command and print server response.</span></span><br><span class="line">heloCommand = <span class="string">&#x27;HELO mailserver\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(heloCommand.encode())</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#登录过程</span></span><br><span class="line">loginCommand = <span class="string">&#x27;auth login\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(loginCommand.encode())</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;334&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#邮箱账户经过base64编码</span></span><br><span class="line">userCommand = base64.b64encode(mailUser.encode()) + <span class="string">b&#x27;\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(userCommand)</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;334&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#邮箱密码经过base64编码 这里不展示密码了</span></span><br><span class="line">passCommand = base64.b64encode(mailPassWord.encode()) + <span class="string">b&#x27;\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(passCommand)</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;235&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send MAIL FROM command and print server response.</span></span><br><span class="line">MFCommand = <span class="string">&#x27;MAIL FROM: &lt;&#x27;</span>+ mailFromAddress + <span class="string">&#x27;&gt;\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(MFCommand.encode())</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send RCPT TO command and print server response.</span></span><br><span class="line">RTCommand = <span class="string">&#x27;RCPT TO: &lt;&#x27;</span>+ mailToAddress + <span class="string">&#x27;&gt;\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(RTCommand.encode())</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send DATA command and print server response.</span></span><br><span class="line">DATACommand = <span class="string">&#x27;DATA\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(DATACommand.encode())</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;354&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send message data.</span></span><br><span class="line">clientSocketSSL.send(msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Message ends with a single period.</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(endmsg.encode())</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send QUIT command and get server response.</span></span><br><span class="line">QUITCommand = <span class="string">&#x27;QUIT\r\n&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    clientSocketSSL.send(QUITCommand.encode())</span><br><span class="line">    recv = clientSocketSSL.recv(<span class="number">1024</span>)</span><br><span class="line">    recv = recv.decode()</span><br><span class="line">    <span class="built_in">print</span>(recv)</span><br><span class="line">    <span class="keyword">if</span> recv[:<span class="number">3</span>] == <span class="string">&#x27;221&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">clientSocketSSL.close()</span><br></pre></td></tr></table></figure>

<br></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>套接字编程作业1：Web服务器</title>
    <url>/BassHero.github.io/2021/12/09/ISBN978-7-111-45378-9_01/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>参考来自：<a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer">Computer Network A Top-Down Approach Practice Answer-github</a></p>
<span id="more"></span>
<h2 id="chapter01"><a href="#chapter01" class="headerlink" title="chapter01"></a>chapter01</h2><p><strong>因特网协议栈中的5个层次</strong><br>应用层：提供了一些网络应用程序和应用层协议。<br>运输层：在应用程序端点之间传输运输层报文。主要有TCP和UDP两种协议。<br>网络层：负责将分组从一台主机移动到另一台主机。<br>链路层：沿着路经将数据报传递给下一层结点。<br>物理层：将整个帧从一个网络元素移动到邻近的网络元素。</p>
<table>
<thead>
<tr>
<th>OSI</th>
<th>TCP/IP</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>应用层</td>
</tr>
<tr>
<td>表示层</td>
<td>-</td>
</tr>
<tr>
<td>会话层</td>
<td>-</td>
</tr>
<tr>
<td>运输层</td>
<td>运输层</td>
</tr>
<tr>
<td>网络层</td>
<td>网际层IP</td>
</tr>
<tr>
<td>数据连接层</td>
<td>网络连接层</td>
</tr>
<tr>
<td>物理层</td>
<td>-</td>
</tr>
</tbody></table>
<br>

<p><strong>R12. 与分组交换网络相比，电路交换网络有哪些优点？在电路交换网络中，TDM比FDM有哪些优点？</strong></p>
<p>答案：<br>电路交换网络适合实时服务。交付质量高。<br>TDM比FDM的优点如下：（来源于网络）</p>
<ol>
<li>当发生拥塞等网络问题时，TDM中的数据丢失可能只会是一部分，而FDM中就可能是大部分或全部。</li>
<li>TDM适合数字信号传输，而FDM适合模拟信号传输，因为现在通信网络多是传输数字信号，所以TDM比FDM好。</li>
<li>因为频分复用连接建立后，当中途没有数据传输时，他所占有的频段带宽不能被其他连接使用，故可能存在空置，而在时分复用的统计时分模式下，连接建立后，当某个连接暂时不用传输数据时可以少分时间片或者不分，即其时隙的分配时“按需分配”，这样就让出了相应的传输时间给其他连接。<br></li>
</ol>
<p><strong>R16. 考虑从某源主机跨越一条固定路由向某目的主机发送一分组。列出端到端时延组成部分。这些时延中的哪些是固定的，哪些是变化的？</strong></p>
<p>答案：<br>端到端时延组成部分有：结点处理时延，排队时延，传输时延，传播时延。<br>时延中固定的部分有：传输时延 传播时延<br>时延中变化的部分有：结点处理时延 排队时延<br><br><br>怎么查看自己电脑的IP地址：ipconfig/all<br><br><br></p>
<h2 id="chapter-02"><a href="#chapter-02" class="headerlink" title="chapter 02"></a>chapter 02</h2><h3 id="套接字编程作业1：Web服务器"><a href="#套接字编程作业1：Web服务器" class="headerlink" title="套接字编程作业1：Web服务器"></a>套接字编程作业1：Web服务器</h3><p>开发一个处理一个HTTP请求的Web服务器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#import socket module</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="comment">#Prepare a sever socket</span></span><br><span class="line">serverPort = <span class="number">80</span></span><br><span class="line">serverSocket.bind((<span class="string">&quot;&quot;</span>, serverPort))</span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#Establish the connection</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Ready to serve...&#x27;</span>)</span><br><span class="line">    connectionSocket, addr = serverSocket.accept()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        message = connectionSocket.recv(<span class="number">1024</span>)</span><br><span class="line">        filename = message.split()[<span class="number">1</span>]</span><br><span class="line">        f = <span class="built_in">open</span>(filename[<span class="number">1</span>:])</span><br><span class="line">        outputdata = f.read()</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="comment">#Send one HTTP header line into socket</span></span><br><span class="line">        outputdata = <span class="string">&#x27;HTTP/1.1 200 OK\r\n\r\n&#x27;</span> + outputdata</span><br><span class="line">        <span class="comment">#Send the content of the requested file to the client</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(outputdata)):</span><br><span class="line">            connectionSocket.send(outputdata[i].encode())</span><br><span class="line">        connectionSocket.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;OK!&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="comment">#Send response message for file not found</span></span><br><span class="line">        outputdata = <span class="string">&#x27;HTTP/1.1 404 Not Found\r\n\r\n&#x27;</span></span><br><span class="line">        <span class="comment">#Close client socket</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(outputdata)):</span><br><span class="line">            connectionSocket.send(outputdata[i].encode())</span><br><span class="line">        connectionSocket.close()</span><br><span class="line">serverSocket.close()</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<p><strong>可选练习</strong><br>目前，这个Web服务器一次只处理一个HTTP请求。请实现一个能够同时处理多个请求的多线程服务器。使用线程，首先创建一个主线程，在固定端口监听客户端请求。当从客户端收到TCP连接请求时，它将通过另一个端口建立TCP连接，并在另外的单独线程中为客户端请求提供服务。这样在每个请求/响应对的独立线程中将有一个独立的TCP连接。</p>
<figure class="highlight python"><figcaption><span>服务器端</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">MAIN_PORT = <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, port</span>):</span></span><br><span class="line"><span class="built_in">super</span>().__init__()</span><br><span class="line">self.port = port</span><br><span class="line">self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">self.server_socket.bind((<span class="string">&#x27;localhost&#x27;</span>, self.port))</span><br><span class="line">self.server_socket.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;新端口 <span class="subst">&#123;self.port&#125;</span> 等待客户端连接...&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">client_socket, addr = self.server_socket.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;端口 <span class="subst">&#123;self.port&#125;</span> 已连接客户端 <span class="subst">&#123;addr&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理请求</span></span><br><span class="line">request = client_socket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;收到请求[<span class="subst">&#123;self.port&#125;</span>]: <span class="subst">&#123;request&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟处理耗时</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送响应</span></span><br><span class="line">response = <span class="string">f&quot;服务器响应自端口 <span class="subst">&#123;self.port&#125;</span>&quot;</span></span><br><span class="line">client_socket.send(response.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">client_socket.close()</span><br><span class="line">self.server_socket.close()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;端口 <span class="subst">&#123;self.port&#125;</span> 处理异常: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_server</span>():</span></span><br><span class="line">main_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">main_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">main_socket.bind((<span class="string">&#x27;localhost&#x27;</span>, MAIN_PORT))</span><br><span class="line">main_socket.listen(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;主服务器启动，监听端口 <span class="subst">&#123;MAIN_PORT&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">client_socket, addr = main_socket.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;接收到客户端连接: <span class="subst">&#123;addr&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配新端口</span></span><br><span class="line">temp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">temp_socket.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">new_port = temp_socket.getsockname()[<span class="number">1</span>]</span><br><span class="line">temp_socket.close()  <span class="comment"># 释放临时端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动新端口监听线程</span></span><br><span class="line">handler = ClientHandler(new_port)</span><br><span class="line">handler.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送新端口给客户端</span></span><br><span class="line">client_socket.send(<span class="built_in">str</span>(new_port).encode())</span><br><span class="line">client_socket.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;已分配端口 <span class="subst">&#123;new_port&#125;</span> 给客户端 <span class="subst">&#123;addr&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;主服务器异常: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">main_server()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><figcaption><span>用户端</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span>():</span></span><br><span class="line"><span class="comment"># 第一步：连接主服务器获取新端口</span></span><br><span class="line">main_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">main_sock.connect((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">8000</span>))</span><br><span class="line">new_port = <span class="built_in">int</span>(main_sock.recv(<span class="number">1024</span>).decode())</span><br><span class="line">main_sock.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;获取到新端口: <span class="subst">&#123;new_port&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：连接新端口</span></span><br><span class="line">client_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client_sock.connect((<span class="string">&#x27;localhost&#x27;</span>, new_port))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line">client_sock.send(<span class="string">&quot;客户端请求&quot;</span>.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收响应</span></span><br><span class="line">response = client_sock.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;收到响应: <span class="subst">&#123;response&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">client_sock.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">client()</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<p>不使用浏览器，编写自己的HTTP客户端来测试你的服务器。您的客户端将使用一个TCP连接用于连接到服务器，向服务器发送HTTP请求，并将服务器响应显示出来。您可以假定发送的HTTP请求将使用GET方法。 客户端应使用命令行参数指定服务器IP地址或主机名，服务器正在监听的端口，以及被请求对象在服务器上的路径。以下是运行客户端的输入命令格式。<br><br></p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="title">client</span>.py server_host server_<span class="keyword">port</span> filename</span><br></pre></td></tr></table></figure>

<p>Answer:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#import socket module</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">webProcess</span>(<span class="params">connectionSocket</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        message = connectionSocket.recv(<span class="number">1024</span>)</span><br><span class="line">        filename = message.split()[<span class="number">1</span>]</span><br><span class="line">        f = <span class="built_in">open</span>(filename[<span class="number">1</span>:], <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">        outputdata = f.read()</span><br><span class="line">        outputdata = outputdata.decode()</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="comment">#Send one HTTP header line into socket</span></span><br><span class="line">        outputdata = <span class="string">&#x27;HTTP/1.1 200 OK\r\n\r\n&#x27;</span> + outputdata</span><br><span class="line">        <span class="comment">#Send the content of the requested file to the client</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(outputdata)):</span><br><span class="line">            connectionSocket.send(outputdata[i].encode())</span><br><span class="line">        connectionSocket.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;OK!&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="comment">#Send response message for file not found</span></span><br><span class="line">        outputdata = <span class="string">&#x27;HTTP/1.1 404 Not Found\r\n\r\n&#x27;</span></span><br><span class="line">        <span class="comment">#Close client socket</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(outputdata)):</span><br><span class="line">            connectionSocket.send(outputdata[i].encode())</span><br><span class="line">        connectionSocket.close()</span><br><span class="line"></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="comment">#Prepare a sever socket</span></span><br><span class="line">serverPort = <span class="number">80</span></span><br><span class="line">serverSocket.bind((<span class="string">&quot;&quot;</span>, serverPort))</span><br><span class="line">serverSocket.listen(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#Establish the connection</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Ready to serve...&#x27;</span>)</span><br><span class="line">    connectionSocket, addr = serverSocket.accept()</span><br><span class="line">    thread = threading.Thread(target = webProcess, args = (connectionSocket, ))</span><br><span class="line">    thread.start()</span><br><span class="line">serverSocket.close()</span><br></pre></td></tr></table></figure>




</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>套接字编程作业2：UDPping程序</title>
    <url>/BassHero.github.io/2021/12/09/ISBN978-7-111-45378-9_02/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>参考来自：<a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer">Computer Network A Top-Down Approach Practice Answer-github</a></p>
<span id="more"></span>
<h3 id="套接字编程作业2：UDPping程序"><a href="#套接字编程作业2：UDPping程序" class="headerlink" title="套接字编程作业2：UDPping程序"></a>套接字编程作业2：UDPping程序</h3><p>客户端向服务器发送10次ping。因为UDP是不可靠的协议，所以从客户端发送到服务器的数据包可能在网络中丢失。因此，客户端不能无限期地等待ping消息的回复。客户等待服务器回答的时间至多为一秒，如果在一秒内没有收到回复，您的客户端程序应该假定数据包在网络传输期间丢失。<br><br>您需要查找Python文档，以了解如何在数据报套接字上设置超时值。</p>
<p>具体来说，您的客户端程序应该<br>1.使用UDP发送ping消息（注意：不同于TCP，您不需要首先建立连接，因为UDP是无连接协议。）<br>2.从服务器输出响应消息<br>3.如果从服务器受到响应，则计算并输出每个数据包的往返时延（RTT）（以秒为单位），<br>4.否则输出“请求超时”<br>在开发过程中，您应该先在计算机上运行UDPPingerServer.py，并通过向localhost（或127.0.0.1）发送数据包来测试客户端。调试完成代码后，您应该能看到ping服务器和ping客户端在不同机器上通过网络进行通信。<br><br></p>
<p><strong>其他阅读链接：</strong><a href="/BassHero.github.io/2021/12/17/ping/" title="ping">ping</a><br><br></p>
<figure class="highlight python"><figcaption><span>UDPPingerClient.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">serverName = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    time1 = time.time()</span><br><span class="line">    outputdata = <span class="string">&#x27;Ping &#x27;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot; &quot;</span> + <span class="built_in">str</span>(time1)</span><br><span class="line">    <span class="comment"># 设置超时 单位秒</span></span><br><span class="line">    clientSocket.settimeout(<span class="number">1</span>)</span><br><span class="line">    clientSocket.sendto(outputdata.encode(), (serverName, serverPort))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">        timeDiff = time.time() - time1</span><br><span class="line">        <span class="built_in">print</span>(modifiedMessage.decode() + <span class="string">&quot; RTT: &quot;</span> + <span class="built_in">str</span>(timeDiff))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;lost &quot;</span> + <span class="built_in">str</span>(i))</span><br></pre></td></tr></table></figure>
<p><strong>可选练习</strong><br><br><br>1.目前，程序计算每个数据包的往返时间（RTT），并单独打印出来。请按照标准ping程序的模式修改。您需要在客户端每次ping后显示最小，最大和平均RTT。另外，还需计算丢包率（百分比）。<br><br></p>
<figure class="highlight python"><figcaption><span>UDPPingerClient.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">serverName = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    time1 = time.time()</span><br><span class="line">    outputdata = <span class="string">&#x27;Heartbeat &#x27;</span> + <span class="built_in">str</span>(time1)</span><br><span class="line">    clientSocket.sendto(outputdata.encode(), (serverName, serverPort))</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<br>
2.UDP Ping的另一个类似的应用是UDP Heartbeat。<br><br>心跳可用于检查应用程序是否已启动并运行，并报告单向丢包。客户端在UDP数据包中将一个序列号和当前时间戳发送给正在监听客户端心跳的服务器。服务器收到数据包后，计算时差，报告丢包（若发生）。如果心跳数据包在指定的一段时间内丢失，我们可以假设客户端应用程序已经停止。实现UDP Heartbeat（客户端和服务器端）。<br><br>您需要修改给定的UDPPingerServer.py和您自己的UDP ping客户端。
<br><br>


<figure class="highlight python"><figcaption><span>UDPPingerServer.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">#We will need the following module to generate randomized lost packets</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create a UDP socket</span></span><br><span class="line"><span class="comment">#Notice the use of SOCK_DGRAM for UDP packets</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"><span class="comment">#Assign IP address and port number to socket</span></span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">12000</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    message, address = serverSocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    message = message.decode()</span><br><span class="line">    message = message.split()[<span class="number">1</span>]</span><br><span class="line">    timeDiff = time.time() - <span class="built_in">float</span>(message)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;receive RTT:&quot;</span>, timeDiff)</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>python05</title>
    <url>/BassHero.github.io/2021/11/10/python05/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>使用beautifulSoup实现的网站遍历爬虫</p>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment">#define the variable</span></span><br><span class="line">pages = <span class="built_in">set</span>()</span><br><span class="line">random.seed(datetime.datetime.now())</span><br><span class="line"></span><br><span class="line"><span class="comment">#define the function</span></span><br><span class="line"><span class="comment">#ページ内にあるすべて内部リンクを調べる</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getInternalLinks</span>(<span class="params">bs,includeUrl</span>):</span></span><br><span class="line">    includeUrl = <span class="string">&#x27;&#123;&#125;://&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(urlparse(includeUrl).scheme,</span><br><span class="line">    urlparse(includeUrl).netloc)</span><br><span class="line">    internalLinks = []</span><br><span class="line"></span><br><span class="line">        <span class="comment">#&#x27;^(/|.*&#x27;+includeUrl+&#x27;)&#x27;)はregex記法といいます</span></span><br><span class="line">        <span class="comment">#ここでは「//」から始まるリンクだけ探し出す</span></span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> bs.find_all(<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">        href=re.<span class="built_in">compile</span>(<span class="string">&#x27;^(/|.*&#x27;</span>+includeUrl+<span class="string">&#x27;)&#x27;</span>)):</span><br><span class="line">        <span class="keyword">if</span> link.attrs[<span class="string">&#x27;href&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> link.attrs[<span class="string">&#x27;href&#x27;</span>] <span class="keyword">not</span> <span class="keyword">in</span> internalLinks:</span><br><span class="line">                <span class="keyword">if</span>(link.attrs[<span class="string">&#x27;href&#x27;</span>].startswith(<span class="string">&#x27;/&#x27;</span>)):</span><br><span class="line">                    internalLinks.append(</span><br><span class="line">                    includeUrl+link.attrs[<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    internalLinks.append(link.attrs[<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> internalLinks</span><br><span class="line"></span><br><span class="line"><span class="comment">##ページ内にあるすべて外部リンクを調べる</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getExternalLinks</span>(<span class="params">bs,excludeUrl</span>):</span></span><br><span class="line">    externalLinks =[]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#「http」や「www」から始まるかつ、いままで出ていないリンクだけ探し出す</span></span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> bs.find_all(<span class="string">&#x27;a&#x27;</span>,href=re.<span class="built_in">compile</span>(<span class="string">&#x27;^(http|www)((?!&#x27;</span>+excludeUrl+<span class="string">&#x27;).)*$&#x27;</span>)):</span><br><span class="line">        <span class="keyword">if</span> link.attrs[<span class="string">&#x27;href&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> link.attrs[<span class="string">&#x27;href&#x27;</span>] <span class="keyword">not</span> <span class="keyword">in</span> externalLinks:</span><br><span class="line">                externalLinks.append(link.attrs[<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> externalLinks</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getRandomExternalLink</span>(<span class="params">startingPage</span>):</span></span><br><span class="line">    html = urlopen(startingPage)</span><br><span class="line">    bs = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    externalLinks = getExternalLinks(bs,</span><br><span class="line">    urlparse(startingPage).netloc)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(externalLinks) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;No external links, looking around the site for one&#x27;</span>)</span><br><span class="line">        domain = <span class="string">&#x27;&#123;&#125;://&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(urlparse(startingPage).scheme,</span><br><span class="line">        urlparse(startingPage).netloc)</span><br><span class="line">        internalLinks = getInternalLinks(bs, domain)</span><br><span class="line">        <span class="keyword">return</span> getRandomExternalLink(internalLinks[random.randint(<span class="number">0</span>,</span><br><span class="line">        <span class="built_in">len</span>(internalLinks)-<span class="number">1</span>)])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> externalLinks[random.randint(<span class="number">0</span>, <span class="built_in">len</span>(externalLinks)-<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">followExternalOnly</span>(<span class="params">startingSite</span>):</span></span><br><span class="line">    externalLink = getRandomExternalLink(startingSite)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Random external link is: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(externalLink))</span><br><span class="line">    followExternalOnly(externalLink)</span><br><span class="line"></span><br><span class="line"><span class="comment">#main:</span></span><br><span class="line">followExternalOnly(<span class="string">&#x27;http://oreilly.com&#x27;</span>)</span><br></pre></td></tr></table></figure>

</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <tags>
        <tag>技术,cheatsheet</tag>
      </tags>
  </entry>
  <entry>
    <title>c和c++ 管道通讯</title>
    <url>/BassHero.github.io/2021/11/09/pipe/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>用来复习和对比</p>
<span id="more"></span>
<details><summary>server.c(可点开查看)</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hPipe = <span class="built_in">CreateFile</span>(<span class="string">&quot;\\\\.\\pipe\\mypipe&quot;</span>,</span><br><span class="line">        GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hPipe == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> szBuff[<span class="number">32</span>];</span><br><span class="line">        DWORD dwBytesWritten;</span><br><span class="line">        <span class="built_in">fgets</span>(szBuff, <span class="built_in"><span class="keyword">sizeof</span></span>(szBuff), stdin);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">WriteFile</span>(hPipe, szBuff, <span class="built_in">strlen</span>(szBuff), &amp;dwBytesWritten, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hPipe);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<details><summary>client.c(可点开查看)</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hPipe = <span class="built_in">CreateNamedPipe</span>(<span class="string">&quot;\\\\.\\pipe\\mypipe&quot;</span>, <span class="comment">//lpName</span></span><br><span class="line">        PIPE_ACCESS_DUPLEX,             <span class="comment">// dwOpenMode</span></span><br><span class="line">        PIPE_TYPE_BYTE | PIPE_WAIT,     <span class="comment">// dwPipeMode</span></span><br><span class="line">        <span class="number">3</span>,                              <span class="comment">// nMaxInstances</span></span><br><span class="line">        <span class="number">0</span>,                              <span class="comment">// nOutBufferSize</span></span><br><span class="line">        <span class="number">0</span>,                              <span class="comment">// nInBufferSize</span></span><br><span class="line">        <span class="number">100</span>,                            <span class="comment">// nDefaultTimeOut</span></span><br><span class="line">        <span class="literal">NULL</span>);                          <span class="comment">// lpSecurityAttributes</span></span><br><span class="line">    <span class="keyword">if</span> (hPipe == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ConnectNamedPipe</span>(hPipe, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hPipe);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> szBuff[<span class="number">256</span>];</span><br><span class="line">        DWORD dwBytesRead;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ReadFile</span>(hPipe, szBuff, <span class="built_in"><span class="keyword">sizeof</span></span>(szBuff), &amp;dwBytesRead, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        szBuff[dwBytesRead] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PipeServer: %s&quot;</span>, szBuff);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FlushFileBuffers</span>(hPipe);</span><br><span class="line">    <span class="built_in">DisconnectNamedPipe</span>(hPipe);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hPipe);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<details><summary>server.cpp(可点开查看)</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;create pipe and connect\n&quot;</span>);</span><br><span class="line">      <span class="keyword">char</span> pStr[<span class="number">255</span>];</span><br><span class="line">	DWORD    dwWrite;</span><br><span class="line">	HANDLE hPipe = <span class="built_in">CreateNamedPipe</span>(<span class="string">&quot;\\\\.\\Pipe\\mypipe&quot;</span>, PIPE_ACCESS_DUPLEX, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT</span><br><span class="line">		, PIPE_UNLIMITED_INSTANCES, <span class="number">0</span>, <span class="number">0</span>, NMPWAIT_WAIT_FOREVER, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="comment">//waiting to be connected</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ConnectNamedPipe</span>(hPipe, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;connect successful\n&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;put down the phases.\n&quot;</span>;</span><br><span class="line">		cin&gt;&gt;pStr;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">WriteFile</span>(hPipe, pStr, <span class="built_in">strlen</span>(pStr), &amp;dwWrite, <span class="literal">NULL</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;write failed...&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(pStr==<span class="string">&quot;q&quot;</span>) <span class="keyword">break</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;data sended: &quot;</span> &lt;&lt; pStr &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;put down the phases again.enter &#x27;q&#x27; to quit.\n&quot;</span>;</span><br><span class="line">			cin&gt;&gt;pStr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DisconnectNamedPipe</span>(hPipe);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hPipe);<span class="comment">//关闭管道</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;close\n&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<details><summary>client.cpp(可点开查看)</summary>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 5</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">char</span> str[<span class="number">1</span>] ;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;namedpipe:client online\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;P key to connect the pipe\n&quot;</span>);</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;wait connect\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WaitNamedPipe</span>(<span class="string">&quot;\\\\.\\Pipe\\mypipe&quot;</span>, NMPWAIT_WAIT_FOREVER) == FALSE)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;open pipe\n&quot;</span>);</span><br><span class="line">	HANDLE hPipe = <span class="built_in">CreateFile</span>(<span class="string">&quot;\\\\.\\Pipe\\mypipe&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">long</span>)hPipe == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	BOOL fSuccess = <span class="literal">false</span>;</span><br><span class="line">	DWORD len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buffer[BUFSIZE];</span><br><span class="line">	string recvData = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> buffercnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		fSuccess = <span class="built_in">ReadFile</span>(hPipe, buffer, BUFSIZE * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>), &amp;len, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">char</span> buffer2[BUFSIZE + <span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="built_in">memcpy</span>(buffer2, buffer, len);</span><br><span class="line">		<span class="comment">//recvData.append(buffer2);</span></span><br><span class="line">		<span class="keyword">if</span> (!fSuccess)&#123;</span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;pipe error\n&quot;</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//cout &lt;&lt; &quot;recv data form server: &quot; &lt;&lt; recvData.c_str() &lt;&lt; endl &lt;&lt; endl;</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;recv data form server: &quot;</span> &lt;&lt; buffer2 &lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">FlushFileBuffers</span>(hPipe);</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DisconnectNamedPipe</span>(hPipe);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hPipe);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>c++09 String类</title>
    <url>/BassHero.github.io/2021/11/08/cpp09string/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h3 id="string类构造函数"><a href="#string类构造函数" class="headerlink" title="string类构造函数"></a>string类构造函数</h3><p>string类其实是基于一个类型模板。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">class</span> <span class="title">traits</span> =</span> char_traits&lt;charT&gt;,</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> =</span> allocator&lt;charT&gt; &gt;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">basic_string</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> string    = basic_string&lt;<span class="keyword">char</span>&gt;;</span><br><span class="line">  <span class="keyword">using</span> u8string  = basic_string&lt;<span class="keyword">char8_t</span>&gt;;   <span class="comment">// C++20から</span></span><br><span class="line">  <span class="keyword">using</span> u16string = basic_string&lt;<span class="keyword">char16_t</span>&gt;;  <span class="comment">// C++11から</span></span><br><span class="line">  <span class="keyword">using</span> u32string = basic_string&lt;<span class="keyword">char32_t</span>&gt;;  <span class="comment">// C++11から</span></span><br><span class="line">  <span class="keyword">using</span> wstring   = basic_string&lt;<span class="keyword">wchar_t</span>&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">namespace</span> pmr &#123;  <span class="comment">// C++17から</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="keyword">class</span> <span class="title">traits</span> =</span> char_traits&lt;charT&gt;&gt;</span><br><span class="line">      <span class="keyword">using</span> basic_string =</span><br><span class="line">        std::basic_string&lt;charT, traits, polymorphic_allocator&lt;charT&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> string    = basic_string&lt;<span class="keyword">char</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> u8string  = basic_string&lt;<span class="keyword">char8_t</span>&gt;; <span class="comment">// C++20から</span></span><br><span class="line">    <span class="keyword">using</span> u16string = basic_string&lt;<span class="keyword">char16_t</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> u32string = basic_string&lt;<span class="keyword">char32_t</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> wstring   = basic_string&lt;<span class="keyword">wchar_t</span>&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>头文件string.h和cstring支持对c-风格字符串进行操纵的c库字符串函数，但不支持string类。</p>
<!--more-->

<table>
<thead>
<tr>
<th>构造函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string(const char * s)</td>
<td>将string对象初始化为s指向NBTS。NBTS为null-byte-temnated string的缩写，表示以空字符结束的字符串（传统的C字符串）</td>
</tr>
<tr>
<td>string(size_type n,char c)</td>
<td>创建一个包含n个元素的string对象，<br>其中每个元素都被初始化为字符c</td>
</tr>
<tr>
<td>string(const string &amp; str)</td>
<td>复制构造函数</td>
</tr>
<tr>
<td>string()</td>
<td>创建一个的string对象，长度为0</td>
</tr>
<tr>
<td>string(const char * s, size_type n)</td>
<td>将string对象初始化为s指向的NBTS中的前n字符，即使超过了NBTS端</td>
</tr>
<tr>
<td>template<clas Iter> string(Iter begin,Iter end)</td>
<td>将string对象初始化为区间(begin,end)内的字符，其中begin和end的行为就像指针</td>
</tr>
<tr>
<td>string(const string &amp; str,string size_type n = npos)</td>
<td>将string对象初始化为对象str中从位置pos开始到结尾的字符，<br>或从位置pos开始的n个字符</td>
</tr>
<tr>
<td>string(string &amp;&amp; str)noexcept</td>
<td>将string对象初始化为string对象(移动构造函数)</td>
</tr>
<tr>
<td>string(initializer_list<char>il)</td>
<td>将string对象初始化为初始化列表il中的字符</td>
</tr>
</tbody></table>
<p>重载运算符+=,=,&lt;&lt;,[]<br></p>
<p><strong>string(initializer_list<char>il)</strong> 允许一下使用方式</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">string piano_man=&#123;<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line">string comp_lang &#123;<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;p&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="string类输入"><a href="#string类输入" class="headerlink" title="string类输入"></a>string类输入</h3><table>
<thead>
<tr>
<th>输入方式</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>c-</td>
<td>char info;<br>cin&gt;&gt;info;<br>cin.getlin(info,100);<br>cin.get(info,100);</td>
</tr>
<tr>
<td>string对象</td>
<td>string stuff;<br>cin &gt;&gt; stuff;<br>getline(cin,stuff);<br></td>
</tr>
</tbody></table>
<p>两个版本都有getline，区别是string对象的getline将自动调整目标string对象的大小。<br>对于c-风格的输入，cin是调用对象，而对于string对象输入，cin是一个函数参数。</p>
<h3 id="string类功能"><a href="#string类功能" class="headerlink" title="string类功能"></a>string类功能</h3><p>find()<br>capacity()<br>reserve()</p>
<p>如果你有string，但需要c-风格字符串。比如open接受c-风格字符串</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">string filename<span class="comment">;</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Enter file name&quot;</span><span class="comment">;</span></span><br><span class="line">cin&gt;&gt; filename<span class="comment">;</span></span><br><span class="line">ofstream fout<span class="comment">;</span></span><br><span class="line">fout.open(filename.c_str())<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="智能指针模板–delete指针对策"><a href="#智能指针模板–delete指针对策" class="headerlink" title="智能指针模板–delete指针对策"></a>智能指针模板–delete指针对策</h3><p>auto_ptr,unique_ptr,share_ptr可以将new活得的地址付给这些对象，当智能指针过期时(离开代码块时)，其析构函数释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="function">auto_ptr&lt;<span class="keyword">double</span>&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> <span class="keyword">double</span>)</span></span>;</span><br><span class="line">      *ap=<span class="number">25.5</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意：<br>1.不能指向非堆内存<br>2.两个指针不能指向同一个对象<br>3.使用newp[]时不能用auto_ptr，share_ptr</p>
<h3 id="标准模板库–泛型编程"><a href="#标准模板库–泛型编程" class="headerlink" title="标准模板库–泛型编程"></a>标准模板库–泛型编程</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>size(),swap(),begin(),engd(),push_back(),erase(),insert()<br>for_each(),random_shuffle(),sort()</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span><span class="constructor">_each(<span class="params">books</span>.<span class="params">begain</span>()</span>,books.<span class="keyword">end</span><span class="literal">()</span>,ShowReveiw)</span><br></pre></td></tr></table></figure>

<p>基于范围的for</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">double</span> prices[<span class="number">5</span>] =&#123;<span class="number">4</span>.<span class="number">99</span>,<span class="number">10</span>.<span class="number">99</span>,<span class="number">6</span>.<span class="number">87</span>,<span class="number">7</span>.<span class="number">99</span>,<span class="number">8</span>.<span class="number">49</span>&#125;;</span><br><span class="line"><span class="attribute">for</span>(double x: prices) cout&lt;&lt; x &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>基于范围的for修改内容</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">for(<span class="attribute">auto</span> &amp;x: books) <span class="built_in">InflateReview</span>(x);</span><br></pre></td></tr></table></figure>
<br>

<p><strong>16.11 inserts.cpp</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// inserts.cpp -- copy!) and insert iterators </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">const</span> std::string &amp; s)</span> </span>&#123; std::cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	string s1[<span class="number">4</span>] = &#123; <span class="string">&quot;fine&quot;</span>, <span class="string">&quot;fish&quot;</span>, <span class="string">&quot;fashion&quot;</span>, <span class="string">&quot;fate&quot;</span> &#125;;</span><br><span class="line">	string s2[<span class="number">2</span>] = &#123; <span class="string">&quot;busy&quot;</span>, <span class="string">&quot;bats&quot;</span> &#125;;</span><br><span class="line">	string s3[<span class="number">2</span>] = &#123; <span class="string">&quot;silly&quot;</span>, <span class="string">&quot;singers&quot;</span> &#125;;</span><br><span class="line">	<span class="function">vector&lt;string&gt; <span class="title">words</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">	<span class="built_in">copy</span>(s1, s1 + <span class="number">4</span>, words.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), output);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// construct anonymous back_insert_iterator object</span></span><br><span class="line">	<span class="built_in">copy</span>(s2, s2 + <span class="number">2</span>, back_insert_iterator&lt;vector&lt;string&gt; &gt;(words));</span><br><span class="line">	for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), output);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// construct anonymous insert_iterator object</span></span><br><span class="line">	<span class="built_in">copy</span>(s3, s3 + <span class="number">2</span>, insert_iterator&lt;vector&lt;string&gt; &gt;(words, words.<span class="built_in">begin</span>()));</span><br><span class="line">	for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), output);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WorseThan()</p>
<h4 id="容器种类"><a href="#容器种类" class="headerlink" title="容器种类"></a>容器种类</h4><h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h5><h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>双向链表</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//list.cpp -- using a list</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outint</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	<span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">one</span><span class="params">(<span class="number">5</span>, <span class="number">2</span>)</span></span>; <span class="comment">// list of 5 2s </span></span><br><span class="line">	<span class="keyword">int</span> stuff[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt; two;</span><br><span class="line">	two.<span class="built_in">insert</span>(two.<span class="built_in">begin</span>(), stuff, stuff + <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">int</span> more[<span class="number">6</span>] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">three</span><span class="params">(two)</span></span>;</span><br><span class="line">	three.<span class="built_in">insert</span>(three.<span class="built_in">end</span>(), more, more + <span class="number">6</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;List one: &quot;</span>;</span><br><span class="line">	for_each(one.<span class="built_in">begin</span>(), one.<span class="built_in">end</span>(), outint);</span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List two: &quot;</span>;</span><br><span class="line">	for_each(two.<span class="built_in">begin</span>(), two.<span class="built_in">end</span>(), outint);</span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List three: &quot;</span>;</span><br><span class="line">	for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">	three.<span class="built_in">remove</span>(<span class="number">2</span>);</span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List three minus 2s: &quot;</span>;</span><br><span class="line">	for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">	three.<span class="built_in">splice</span>(three.<span class="built_in">begin</span>(), one);</span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List three after splice: &quot;</span>;</span><br><span class="line">	for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List one: &quot;</span>;</span><br><span class="line">	for_each(one.<span class="built_in">begin</span>(), one.<span class="built_in">end</span>(), outint);</span><br><span class="line">	three.<span class="built_in">unique</span>();</span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List three after unique: &quot;</span>;</span><br><span class="line">	for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">	three.<span class="built_in">sort</span>();</span><br><span class="line">	three.<span class="built_in">unique</span>();</span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List three after sort &amp;• unique: &quot;</span>;</span><br><span class="line">	for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">	two.<span class="built_in">sort</span>();</span><br><span class="line">	three.<span class="built_in">merge</span>(two);</span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Sorted two merged into three: &quot;</span>;</span><br><span class="line">	for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h5><h5 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h5><h5 id="prioprity-queue"><a href="#prioprity-queue" class="headerlink" title="prioprity_queue"></a>prioprity_queue</h5><h5 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h5><h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><p>array不是STL容器，无法调节容器的大小，但是copy()，for_each()可以用于array。</p>
<h4 id="关联容器-set-multiset-map-multimap"><a href="#关联容器-set-multiset-map-multimap" class="headerlink" title="关联容器 :set,multiset,map,multimap"></a>关联容器 :set,multiset,map,multimap</h4><p><strong>16.13 setops.cpp</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//setops.cpp -- some set operations</span></span><br><span class="line">#<span class="keyword">include</span> &lt;iostream&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;<span class="built_in">string</span>&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;set&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;algorithm&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;iterator&gt;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> main<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">	using namespace std;</span><br><span class="line">	const <span class="built_in">int</span> N = <span class="number">6</span>;</span><br><span class="line">	<span class="built_in">string</span> s1<span class="literal">[N]</span> = &#123; <span class="string">&quot;buffoon&quot;</span>,<span class="string">&quot;thinkers&quot;</span>,<span class="string">&quot;for&quot;</span>,<span class="string">&quot;heavy&quot;</span>,<span class="string">&quot;can&quot;</span>,<span class="string">&quot;for&quot;</span> &#125;;</span><br><span class="line">	<span class="built_in">string</span> s2<span class="literal">[N]</span> = &#123; <span class="string">&quot;metal&quot;</span>, <span class="string">&quot;any&quot;</span>, <span class="string">&quot;food&quot;</span>,<span class="string">&quot;elegant&quot;</span>,<span class="string">&quot;deliver&quot;</span>,<span class="string">&quot;for&quot;</span> &#125;;</span><br><span class="line"> </span><br><span class="line">	set&lt;<span class="built_in">string</span>&gt; <span class="constructor">A(<span class="params">s1</span>, <span class="params">s1</span> + N)</span>;</span><br><span class="line">	set&lt;<span class="built_in">string</span>&gt; <span class="constructor">B(<span class="params">s2</span>, <span class="params">s2</span> + N)</span>;</span><br><span class="line"> </span><br><span class="line">	ostream_iterator&lt;<span class="built_in">string</span>, <span class="built_in">char</span>&gt; out(cout, <span class="string">&quot; &quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Set A&quot;</span>;</span><br><span class="line">	copy(<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>, <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>, out);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Set B: &quot;</span>;</span><br><span class="line">	copy(<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>, <span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>, out);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Union of A and B:\n&quot;</span>;</span><br><span class="line">	set<span class="constructor">_union(A.<span class="params">begin</span>()</span> , <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>, <span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>, <span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>, out); </span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Intersection of A and B:\n&quot;</span>;</span><br><span class="line">	set<span class="constructor">_intersection(A.<span class="params">begin</span>()</span>, <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>, <span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>, <span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>, out); </span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Difference of A and B:\n&quot;</span>;</span><br><span class="line">	set<span class="constructor">_difference(A.<span class="params">begin</span>()</span>, <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>, <span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>, <span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>, out);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	set&lt;<span class="built_in">string</span>&gt; C; cout &lt;&lt; <span class="string">&quot;Set C:\n&quot;</span>;</span><br><span class="line">	set<span class="constructor">_union(A.<span class="params">begin</span>()</span>, <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>, <span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>, <span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>, insert_iterator&lt;set&lt;<span class="built_in">string</span>&gt; &gt;(C, <span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>)); </span><br><span class="line">	copy(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>, <span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>, out);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">string</span> s3(<span class="string">&quot;grungy&quot;</span>);</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>insert(s3);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Set C after insertion:\n&quot;</span>;</span><br><span class="line">	copy(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>, <span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>, out);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Showing a range:\n&quot;</span>;</span><br><span class="line">	copy(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>lower<span class="constructor">_bound(<span class="string">&quot;ghost&quot;</span>)</span>, <span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>upper<span class="constructor">_bound(<span class="string">&quot;spook&quot;</span>)</span>, out);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>16.14 multimap.cpp</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//multmap.cpp -- use a multimap</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="keyword">const</span> KeyType, std::string&gt; Pair; </span><br><span class="line"><span class="keyword">typedef</span> std::multimap&lt;KeyType, std::string&gt; MapCode;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std; MapCode codes;</span><br><span class="line">	codes.<span class="built_in">insert</span>(<span class="built_in">Pair</span>(<span class="number">415</span>, <span class="string">&quot;San Francisco&quot;</span>));</span><br><span class="line">	codes.<span class="built_in">insert</span>(<span class="built_in">Pair</span>(<span class="number">510</span>, <span class="string">&quot;Oakland&quot;</span>));</span><br><span class="line">	codes.<span class="built_in">insert</span>(<span class="built_in">Pair</span>(<span class="number">718</span>, <span class="string">&quot;Brooklyn&quot;</span>));</span><br><span class="line">	codes.<span class="built_in">insert</span>(<span class="built_in">Pair</span>(<span class="number">718</span>, <span class="string">&quot;Staten Island&quot;</span>));</span><br><span class="line">	codes.<span class="built_in">insert</span>(<span class="built_in">Pair</span>(<span class="number">415</span>, <span class="string">&quot;San Rafael&quot;</span>));</span><br><span class="line">	codes.<span class="built_in">insert</span>(<span class="built_in">Pair</span>(<span class="number">510</span>, <span class="string">&quot;Berkeley&quot;</span>));</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Number of cities with area code 415: &quot;</span> &lt;&lt; codes.<span class="built_in">count</span>(<span class="number">415</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Number of cities with area code 718: &quot;</span> &lt;&lt; codes.<span class="built_in">count</span>(<span class="number">718</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Number of cities with area code 510: &quot;</span> &lt;&lt; codes.<span class="built_in">count</span>(<span class="number">510</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Area Code City\n&quot;</span>;</span><br><span class="line">	MapCode::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = codes.<span class="built_in">begin</span>(); it != codes.<span class="built_in">end</span>(); ++it)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (*it).first &lt;&lt; <span class="string">&quot;	&quot;</span> &lt;&lt; (*it).second &lt;&lt; endl;</span><br><span class="line">	pair&lt;MapCode::iterator, MapCode::iterator&gt; range = codes.<span class="built_in">equal_range</span>(<span class="number">718</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Cities with area code 718 :\n&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (it = range.first; it != range.second; ++it)</span><br><span class="line">		cout &lt;&lt; (*it).second &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><p>很多STL算法都是用函数对象————也叫做函数符(functor)。<br>函数符是可以以函数方式与()结合使用的任意对象。即定义了函数operator()()的类。<br>可以像这样定义一个类;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linear</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> slope;</span><br><span class="line">      <span class="keyword">double</span> y0;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      Linear(<span class="keyword">double</span> s1_=<span class="number">1</span>,<span class="keyword">double</span> y_=<span class="number">0</span>): slope(s1_),y0(y_)&#123;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;<span class="keyword">return</span> y0 + slope * x;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样重载()运算符将使得能够像函数那样使用Linear对象:<br>Linear f1;<br>Linear f2(2.5,10.0);<br>double y1 = f1(12.5); //y1=0+1<em>12.5<br>double y2 = f2(0.4);  //y2=10.0+2.5</em>0.4</p>
<h5 id="函数符概念"><a href="#函数符概念" class="headerlink" title="函数符概念"></a>函数符概念</h5><p>生成器是不用参数就可以调用的函数符<br>一元函数是用一个参数就可以调用的函数符<br>二元函数是用两个参数就可以调用的函数符</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>就地版本和复制版本</p>
<p>la.remove(4);<br>调用该方法后，链表中值为4的元素都会被删除，同时链表的长度也会被改变。<br>remove(lb.begin(),lb.end(),4);<br>这个remove是STL算法，是函数不是成员，不能调整链表长度。</p>
<p><strong>16.18 listrmv.cpp</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// listrmv.cpp -- applying the STL to a string </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="keyword">const</span> <span class="keyword">int</span> LIM = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	<span class="keyword">int</span> ar[LIM] = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span> &#125;;</span><br><span class="line">	<span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">la</span><span class="params">(ar, ar + LIM)</span></span>;</span><br><span class="line">	<span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">lb</span><span class="params">(la)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Original list contents:\n\t&quot;</span>;</span><br><span class="line">	for_each(la.<span class="built_in">begin</span>(), la.<span class="built_in">end</span>(), Show);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	la.<span class="built_in">remove</span>(<span class="number">4</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After using the remove() method:\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;la:\t&quot;</span>;</span><br><span class="line">	for_each(la.<span class="built_in">begin</span>(), la.<span class="built_in">end</span>(), Show);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;::iterator last;</span><br><span class="line">	last = <span class="built_in">remove</span>(lb.<span class="built_in">begin</span>(), lb.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After using the remove() functionin&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;lb:\t&quot;</span>;</span><br><span class="line">	for_each(lb.<span class="built_in">begin</span>(), lb.<span class="built_in">end</span>(), Show); cout &lt;&lt; endl;</span><br><span class="line">	lb.<span class="built_in">erase</span>(last, lb.<span class="built_in">end</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After using the erase!) method:\n&quot;</span>; cout &lt;&lt; <span class="string">&quot;lbAt&quot;</span>;</span><br><span class="line">	for_each(lb.<span class="built_in">begin</span>(), lb.<span class="built_in">end</span>(), Show); cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; v &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
希望得到一个按输入顺序排列的单词列表，一个按字母顺序排列的单词列表。
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; words;</span><br><span class="line">string input;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt; input &amp;&amp; input != <span class="string">&quot;quit&quot;</span>)</span><br><span class="line">     <span class="function">words <span class="title">push_back</span><span class="params">(input)</span></span>;</span><br><span class="line"></span><br><span class="line">set&lt;string&gt; wordeset;</span><br><span class="line"><span class="built_in">transform</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),</span><br><span class="line">	insert_iterator&lt;set&lt;string&gt;&gt;.(wordset,wordset.<span class="built_in">begin</span>()),ToLower);</span><br></pre></td></tr></table></figure>
<br>单词出现计数
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="keyword">int</span>&gt;wordmap;</span><br><span class="line">set&lt;string&gt;::iterator si;</span><br><span class="line"><span class="keyword">for</span>(si = wordset.<span class="built_in">begin</span>();si != wordset.<span class="built_in">endd</span>();si++)</span><br><span class="line">  wordmap.<span class="built_in">insert</span>(pair&lt;string,<span class="keyword">int</span>&gt;(*si,<span class="built_in">count</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),*si)));</span><br></pre></td></tr></table></figure>
wordmap["the"]:word出现过的次数
<details><summary>16.19 usealgo.cpp(可点开查看)</summary>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//usealgo.cpp -- using several STL elements </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">toLower</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">tolower</span>(ch);&#125;</span><br><span class="line"><span class="function">string &amp; <span class="title">ToLower</span><span class="params">(string &amp; st)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> string &amp; s)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;string&gt; words;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter words (enter quit to quit):\n&quot;</span>;</span><br><span class="line">	string input;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; input &amp;&amp; input != <span class="string">&quot;quit&quot;</span>)</span><br><span class="line">		words.<span class="built_in">push_back</span>(input);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;You entered the following words:\n&quot;</span>;</span><br><span class="line">	for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), display);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// place words in set, converting to lowercase</span></span><br><span class="line">	set&lt;string&gt; wordset;</span><br><span class="line">	<span class="built_in">transform</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), insert_iterator&lt;set&lt;string&gt; &gt;(wordset, wordset.<span class="built_in">begin</span>()), ToLower);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\nAlphabetic list of words:\n&quot;</span>;</span><br><span class="line">	for_each(wordset.<span class="built_in">begin</span>(), wordset.<span class="built_in">end</span>(), display);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// place word and frequency in map </span></span><br><span class="line">	map&lt;string, <span class="keyword">int</span>&gt; wordmap;</span><br><span class="line">	set&lt;string&gt;::iterator si;</span><br><span class="line">	<span class="keyword">for</span> (si = wordset.<span class="built_in">begin</span>(); si != wordset.<span class="built_in">end</span>(); si++)</span><br><span class="line">		wordmap[*si] = <span class="built_in">count</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), *si);</span><br><span class="line">	<span class="comment">// display map contents</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\nWord frequency:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (si = wordset.<span class="built_in">begin</span>();</span><br><span class="line">		si != wordset.<span class="built_in">end</span>(); si++) cout &lt;&lt; *si &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; wordmap[*si] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//预定tolower是int型，所以需要定义string型</span></span><br><span class="line"><span class="function">string &amp; <span class="title">ToLower</span><span class="params">(string &amp; st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">transform</span>(st.<span class="built_in">begin</span>(), st.<span class="built_in">end</span>(), st.<span class="built_in">begin</span>(), toLower);</span><br><span class="line">	<span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> string &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h4 id="其他库"><a href="#其他库" class="headerlink" title="其他库"></a>其他库</h4><p>Vector模板类是一个容器类和算法系统的一部分，它支持面向容器的操作，如排序，插入，转移容器。<br>valarray类模板面向数值计算的二，不是STL的一部分，没有pushback()和insert()<br>array是为代替内置数组而设计的，有更好、更安全的接口。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">double</span>&gt; ved1(<span class="number">10</span>),ved2(<span class="number">10</span>),ved3(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">array</span>&lt;<span class="type">double</span>,<span class="number">10</span>&gt;vod1,vod2,vod3;</span><br><span class="line">valarray&lt;<span class="type">double</span>&gt; vad1(<span class="number">10</span>),vad2(<span class="number">10</span>),vad(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*将两个数组的第一个元素之和放入第三个数组的第一个元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">//vector</span><br><span class="line"><span class="keyword">transform</span>(ved1.<span class="keyword">begin</span>(),ved1.<span class="keyword">end</span>(),ved2.<span class="keyword">begin</span>(),ved2.<span class="keyword">end</span>(),plus&lt;<span class="type">double</span>&gt;());</span><br><span class="line">//<span class="keyword">array</span></span><br><span class="line"><span class="keyword">transform</span>(vod1.<span class="keyword">begin</span>(),vod1.<span class="keyword">end</span>(),vod2.<span class="keyword">begin</span>(),vod2.<span class="keyword">end</span>(),plus&lt;<span class="type">double</span>&gt;());</span><br><span class="line"></span><br><span class="line">//valarray</span><br><span class="line">vad3=vad1+vad2;   //overload</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*将数组元素扩大2.5倍</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">//STL</span><br><span class="line"><span class="keyword">transform</span>(ved1.<span class="keyword">begin</span>(),ved1.<span class="keyword">end</span>(),ved2.<span class="keyword">begin</span>(),ved2.<span class="keyword">end</span>(),bindlst(multiplies&lt;<span class="type">double</span>&gt;(),<span class="number">2.5</span>));</span><br><span class="line"></span><br><span class="line">//valarray</span><br><span class="line">vad3=<span class="number">2.5</span>*vad3;   //overload</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*自然对数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">//STL</span><br><span class="line"><span class="keyword">transform</span>(ved1.<span class="keyword">begin</span>(),ved1.<span class="keyword">end</span>(),ved2.<span class="keyword">begin</span>(),ved2.<span class="keyword">end</span>(),<span class="keyword">log</span>);</span><br><span class="line"></span><br><span class="line">//valarray</span><br><span class="line">vad3=log(vad3);   //overload</span><br></pre></td></tr></table></figure>
<p>valarray适用预处理数组的循环使用，最大的缺点是无法像STl自动调整长度。<br>c++11提供begin和end<br>sort(begin(vad),end(vad));<br>以下演示先vactor的push_back和自动调整大小来搜集数据，再复制到valarray对象中执行数学运算。</p>
<details><summary>16.20 valvect.cpp(可点开查看)</summary>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// valvect.cpp -- comparing vector and valarray </span><br><span class="line">#<span class="keyword">include</span> &lt;iostream&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;valarray&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;vector&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	using namespace std;</span><br><span class="line">	vector&lt;<span class="keyword">double</span>&gt; <span class="keyword">data</span>;</span><br><span class="line">	<span class="keyword">double</span> temp;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter numbers (&lt;=0 to quit):\n&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; temp &amp;&amp; temp &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">data</span>.push_back(temp);</span><br><span class="line">	sort(<span class="keyword">data</span>.begin(), <span class="keyword">data</span>.<span class="keyword">end</span>());</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">size</span> = <span class="keyword">data</span>.<span class="built_in">size</span>();</span><br><span class="line">	valarray&lt;<span class="keyword">double</span>&gt; numbers(<span class="built_in">size</span>);</span><br><span class="line">	<span class="built_in">int</span> i;</span><br><span class="line">	for (i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">		numbers[i] = <span class="keyword">data</span>[i];</span><br><span class="line">	valarray&lt;<span class="keyword">double</span>&gt; sq_rts(<span class="built_in">size</span>);</span><br><span class="line">	sq_rts = <span class="built_in">sqrt</span>(numbers);</span><br><span class="line">	valarray&lt;<span class="keyword">double</span>&gt; results(<span class="built_in">size</span>);</span><br><span class="line">	results = numbers + <span class="number">2.0</span> * sq_rts;</span><br><span class="line">	cout.setf(ios_base::fixed);</span><br><span class="line">	cout.<span class="keyword">precision</span>(<span class="number">4</span>);</span><br><span class="line">	for (i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout.width(<span class="number">8</span>);</span><br><span class="line">		cout &lt;&lt; numbers[i] &lt;&lt; <span class="string">&#x27;: &#x27;</span>;</span><br><span class="line">		cout.width(<span class="number">8</span>);</span><br><span class="line">		cout &lt;&lt; results[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;done\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>slice数组索引：起始索引，索引数和跨距</p>
<details><summary>16.21 vslice.cpp(可点开查看)</summary>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vslice.cpp -- using valarray slices</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;valarray&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::valarray&lt;<span class="keyword">int</span>&gt; vint; <span class="comment">// simplify declarations </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">const</span> vint &amp; v, <span class="keyword">int</span> cols)</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::slice;	<span class="comment">// from &lt;valarray&gt;</span></span><br><span class="line">	<span class="keyword">using</span> std::cout;</span><br><span class="line">	<span class="function">vint <span class="title">valint</span><span class="params">(SIZE)</span></span>;	<span class="comment">// think of as 4 rows of 3</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; ++i)</span><br><span class="line">		valint[i] = std::<span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Original array:\n&quot;</span>;</span><br><span class="line">	<span class="built_in">show</span>(valint, <span class="number">3</span>); <span class="comment">// show in 3 columns</span></span><br><span class="line">	<span class="function">vint <span class="title">vcol</span><span class="params">(valint[slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>)])</span></span>; <span class="comment">// extract 2nd column</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Second column:\n&quot;</span>;</span><br><span class="line">	<span class="built_in">show</span>(vcol, <span class="number">1</span>);<span class="comment">// show in 1 column </span></span><br><span class="line">	<span class="function">vint <span class="title">vrow</span><span class="params">(valint[slice(<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>)])</span></span>;<span class="comment">// extract 2nd row</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Second row:\n&quot;</span>;</span><br><span class="line">	<span class="built_in">show</span>(vrow, <span class="number">3</span>);</span><br><span class="line">	valint[<span class="built_in">slice</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>)] = <span class="number">10</span>;<span class="comment">// assign to 2nd column</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Set last column to 10:\n&quot;</span>; <span class="built_in">show</span>(valint, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Set first column to sum of next two:\n&quot;</span>;</span><br><span class="line">	<span class="comment">// + not defined for slices, so convert to valarray&lt;int&gt;</span></span><br><span class="line">	valint[<span class="built_in">slice</span>(<span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>)] = <span class="built_in">vint</span>(valint[<span class="built_in">slice</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>)]) + <span class="built_in">vint</span>(valint[<span class="built_in">slice</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>)]);</span><br><span class="line">	<span class="built_in">show</span>(valint, <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">const</span> vint &amp; v, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::cout;</span><br><span class="line">	<span class="keyword">using</span> std::endl;</span><br><span class="line">	<span class="keyword">int</span> lim = v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout.<span class="built_in">width</span>(<span class="number">3</span>);</span><br><span class="line">		cout &lt;&lt; v[i];</span><br><span class="line">		<span class="keyword">if</span> (i % cols == cols - <span class="number">1</span>)</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (lim % cols != <span class="number">0</span>)</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>c++08 异常处理</title>
    <url>/BassHero.github.io/2021/11/06/cpp08except/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<p>Throw –&gt;Try –&gt;Catch<br>thorw不会引起异常</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>abort()：向标准错误流发送消息 bnormal program terminaton<br>throw “message”：throw是一种跳转，及命令程序跳转到另一条语句。message用来指出异常的特征。<br>try：可能出现error的程序<br>catch：用来捕获throw抛出的异常，{}内是出现error之后的处理(这里是要求输入新数字)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//error3.cpp -- using an exception</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hmean</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> x, y, z;</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span>;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; x &gt;&gt; y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span><span class="comment">//start of try block</span></span><br><span class="line">		&#123;</span><br><span class="line">			z = <span class="built_in">hmean</span>(x, y);</span><br><span class="line">		&#125;<span class="comment">//end of try block</span></span><br><span class="line">		<span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> <span class="keyword">char</span> * s)<span class="comment">//start of exception handler</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Enter a new pair of numbers: &quot;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;<span class="comment">//end of handler</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Harmonic mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Enter next set of numbers &lt;q to quit&gt; : &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Bye!\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hmean</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == -b)</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">&quot;bad hmean() arguments: a = -b not allowed&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2.0</span> * a * b / (a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="将对象用作异常类型"><a href="#将对象用作异常类型" class="headerlink" title="将对象用作异常类型"></a>将对象用作异常类型</h4><p>没看懂<br><br></p>
<h4 id="异常规范"><a href="#异常规范" class="headerlink" title="异常规范"></a>异常规范</h4><p>throw可以在函数体中抛出异常，也可以在函数声明中指明当前函数能抛出的异常。<br>double harm(double a) throw(bad_thing);//throw bad_thing exception<br>double marm(double) throw;//doesnt throw<br>可使用新增的noexcept指出函数不会抛出异常<br>double marm() noexcept;</p>
<h4 id="栈解退"><a href="#栈解退" class="headerlink" title="栈解退"></a>栈解退</h4><p>当引用对引发异常的函数进行调用的函数时，涉及栈解退。<br><a href="/WestRoute.github.io/images/cmemoery.png" class="gallery-item"><img src="/WestRoute.github.io/images/cmemoery.png"></a><br>程序将函数指令的返回地址存入栈中，当被调用的函数执行完毕后，程序将用该地址来确定从哪里继续执行。<br>在栈中，这些函数被视为自动变量。如果被调用的函数调用了其他函数，则后者的信息也将添加在栈中。<br>假设最顶部的函数由于出现异常而被中止，栈直到找到try的}地址为止一直释放栈，控制权转为块尾的异常处理。<br>栈和函数返回一样，对与栈中的自动类对象，类的析构函数会被调用。<br>然而函数返回仅仅是处理该函数放在栈中的对象，而throw语句则处理try-catch之间整个函数调用序列放在战中的对象。</p>
<details><summary>error5.h(可点开查看)</summary>

<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//error5.cpp -- unwinding the stack</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;exc_mean.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string <span class="keyword">word</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">demo</span>(<span class="keyword">const</span> string &amp; str)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">word</span> = str;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;demo &quot;</span> &lt;&lt; <span class="keyword">word</span> &lt;&lt; <span class="string">&quot; created\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">demo</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;demo &quot;</span> &lt;&lt; <span class="keyword">word</span> &lt;&lt; <span class="string">&quot; destroyed\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;demo &quot;</span> &lt;&lt; <span class="keyword">word</span> &lt;&lt; <span class="string">&quot; lives!\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// function prototypes</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hmean</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">gmean</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">means</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::cout;</span><br><span class="line">	<span class="keyword">using</span> std::cin;</span><br><span class="line">	<span class="keyword">using</span> std::endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">double</span> x, y, z;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">demo <span class="title">d1</span><span class="params">(<span class="string">&quot;found in block in main() &quot;</span>)</span></span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Enter two numbers : &quot;</span>;</span><br><span class="line">		<span class="keyword">while</span> (cin &gt;&gt; x &gt;&gt; y)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">try</span><span class="comment">// stare of try block</span></span><br><span class="line">			&#123;</span><br><span class="line">				z = <span class="built_in">means</span>(x, y);</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;The mean mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;is &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;Enter next pair: &quot;</span>;</span><br><span class="line">			&#125; <span class="comment">// end of try block</span></span><br><span class="line"> </span><br><span class="line">			<span class="built_in"><span class="keyword">catch</span></span> (bad_hmean &amp; bg) <span class="comment">// start of catch block</span></span><br><span class="line">			&#123;</span><br><span class="line">				bg.<span class="built_in">mesg</span>();</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;Try again.\n&quot;</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="built_in"><span class="keyword">catch</span></span> (bad_gmean &amp; hg)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; hg.<span class="built_in">mesg</span>();</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;Values used: &quot;</span> &lt;&lt; hg.vl &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; hg.v2 &lt;&lt; endl;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;Sorry, you don&#x27;t get to play any more.\n&quot;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="comment">// end of catch block</span></span><br><span class="line">		&#125;</span><br><span class="line">		d1.<span class="built_in">show</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Bye!\n&quot;</span>;</span><br><span class="line">	cin.<span class="built_in">get</span>(); </span><br><span class="line">	cin.<span class="built_in">get</span>(); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hmean</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == -b)</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">bad_hmean</span>(a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2.0</span> * a * b / (a + b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">gmean</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">bad_gmean</span>(a, b); <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(a * b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">means</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> am, hm, gm;</span><br><span class="line">	<span class="function">demo <span class="title">d2</span><span class="params">(<span class="string">&quot;found in means&#123;)&quot;</span>)</span></span>;</span><br><span class="line">	am = (a + b) / <span class="number">2.0</span>;	<span class="comment">// arithmetic mean</span></span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		hm = <span class="built_in">hmean</span>(a, b);</span><br><span class="line">		gm = <span class="built_in">gmean</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in"><span class="keyword">catch</span></span> (bad_hmean &amp; bg) <span class="comment">// start of catch block</span></span><br><span class="line">	&#123;</span><br><span class="line">		bg.<span class="built_in">mesg</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Caught in means()\n&quot;</span>;</span><br><span class="line">		<span class="keyword">throw</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	d2.<span class="built_in">show</span>();</span><br><span class="line">	<span class="keyword">return</span> (am + hm + gm) / <span class="number">3.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h4 id="exception类"><a href="#exception类" class="headerlink" title="exception类"></a>exception类</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">except.h或者exception.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>1.stdexcept<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logic_error:可通过编译修改<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;domain_error<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invaild_argument<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length_error<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out_of_bounds<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;runtime_error:无可避免的问题<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;range_error<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;overflow_error<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;underflow_error<br>2.bad_alloc和new</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>在不用异常处理时，当无法分配请求的内存量时，返回空指针。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Trying to get a big block of memory:\n&quot;</span>;</span><br><span class="line">	pb = new Big[<span class="number">10000</span>]; <span class="regexp">//</span> <span class="number">1</span>,<span class="number">600</span>,<span class="number">000</span>,<span class="number">000</span> bytes</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Got past the new request:\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">catch (bad_alloc &amp; ba)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Caught the exception!\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; ba.what() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">exit</span>(EXIT_FAILURE);</span><br></pre></td></tr></table></figure>
<p>也可以不抛出异常</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi= <span class="built_in"><span class="keyword">new</span></span> (std::nothrow) <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure>

<h4 id="异常，类和继承"><a href="#异常，类和继承" class="headerlink" title="异常，类和继承"></a>异常，类和继承</h4><p>异常，类和继承以三种方式互相关联。<br>注意，bad_index()在class Sales的公开部分里，这使得外部类的catch块可以使用这个类作为类型。<br>Sales::bad_index()是logic_error类派生来的，能够储存和报告数组索引的超界值(out of bounds values)。</p>
<details><summary>sales.h(可点开查看)</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sales.h -- exceptions and inheritance </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> &#123;</span> MONTHS = <span class="number">12</span> &#125;;	<span class="comment">// could be a static const  </span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">bad_index</span> :</span> <span class="keyword">public</span> std::logic_error</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> bi; <span class="comment">// bad index value </span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">bad_index</span><span class="params">(<span class="keyword">int</span> ix, <span class="keyword">const</span> std::string &amp; s = <span class="string">&quot;Index error in Sales object\n&quot;</span>)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">bi_val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bi; &#125;</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">bad_index</span>() <span class="keyword">throw</span>() &#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Sales</span><span class="params">(<span class="keyword">int</span> yy = <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="built_in">Sales</span>(<span class="keyword">int</span> yy, <span class="keyword">const</span> <span class="keyword">double</span> * gr, <span class="keyword">int</span> n);</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Sales</span>() &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Year</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> year; &#125;</span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>;</span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">double</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> gross[MONTHS];</span><br><span class="line">	<span class="keyword">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LabeledSales</span> :</span> <span class="keyword">public</span> Sales</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">nbad_index</span> :</span> <span class="keyword">public</span> Sales::bad_index</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string lbl;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">nbad_index</span>(<span class="keyword">const</span> std::string &amp; lb, <span class="keyword">int</span> ix, <span class="keyword">const</span> std::string &amp; s = <span class="string">&quot;Index error in LabeledSales object\n&quot;</span>);</span><br><span class="line">		<span class="function"><span class="keyword">const</span> std::string &amp; <span class="title">label_val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> lbl; &#125;</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">nbad_index</span>() <span class="keyword">throw</span>() &#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">LabeledSales</span><span class="params">(<span class="keyword">const</span> std::string &amp; lb = <span class="string">&quot;none&quot;</span>, <span class="keyword">int</span> yy = <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="built_in">LabeledSales</span>(<span class="keyword">const</span> std::string &amp; lb, <span class="keyword">int</span> yy, <span class="keyword">const</span> <span class="keyword">double</span> * gr, <span class="keyword">int</span> n);</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">LabeledSales</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> std::string &amp; <span class="title">Label</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>;</span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">double</span> &amp; <span class="keyword">operator</span>[] (<span class="keyword">int</span> i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string label;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>
之所以析构函数virtual ~bad_index() throw() {}使用了异常规范是因为bad_index是继承于C++98的except类，而except类的析构函数就是这样写的。而C++11中，except类的析构函数没有异常规范。
当数组索引超界，operator[]()会引发异常。

<p>带异常规范的函数没有与列表中的一场匹配时会导致问题，默认情况下，未捕获的异常将导致程序终止。<br>set_terminate()函数可以修改terminate()函数不去调用abort()来中止程序。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">void myQuit()&#123;</span><br><span class="line">   cou&lt;&lt;<span class="string">&quot;Terminating due to uncaught exception.\n&quot;</span></span><br><span class="line">   <span class="keyword">exit</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set_terminate(myQuit);</span><br></pre></td></tr></table></figure>
<p>原则上，异常规范应包含调用函数的其他函数所引发的异常，如果发生意外异常，程序将调用unexcept()函数。<br>在这种情况想捕获所有异常，可以</p>
<figure class="highlight mercury"><table><tr><td class="code"><pre><span class="line">void myUnexcepted()&#123;</span><br><span class="line">	throw std::bad_exception();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">...</span><br><span class="line">set_unexcepted(myUnexcepted);</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">...</span><br><span class="line">double Argh(double, double) throw(out_of_bounds,bad_exception)&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">try</span>&#123;</span><br><span class="line">		x<span class="built_in">=</span>Argh(a,b);</span><br><span class="line">	&#125;<span class="built_in">catch</span>(out_of_bounds)&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;<span class="built_in">catch</span>(bad_exception)&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序设计时就应该实现设计好异常，因为异常不适合模板和动态分配。</p>
<h4 id="RTTI（Runtime-Type-Identification）RTTI只适合在包含虚函数的类使用"><a href="#RTTI（Runtime-Type-Identification）RTTI只适合在包含虚函数的类使用" class="headerlink" title="RTTI（Runtime Type Identification）RTTI只适合在包含虚函数的类使用"></a>RTTI（Runtime Type Identification）RTTI只适合在包含虚函数的类使用</h4><p>dynamic_cast 使用基类指针生成一个指向派生类的指针（是否可以安全的将对象的地址赋给特定类型的指针），返回0则为空指针。<br>typeid 返回一个指出对象的类型的值<br>type_info 结构储存了特定类型的信息</p>
<details><summary>dynamic_cast的使用(可点开查看)</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//rttil.cpp -- using the RTTI dynamic_cast operator</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> std::cout; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> hold;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Grand</span>(<span class="keyword">int</span> h = <span class="number">0</span>) : <span class="built_in">hold</span>(h) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am a grand class h\n&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hold; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Superb</span> :</span> <span class="keyword">public</span> Grand</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Superb</span>(<span class="keyword">int</span> h = <span class="number">0</span>) : <span class="built_in">Grand</span>(h) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am a superb class!!\n&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Say</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;I hold the superb value of: &quot;</span> &lt;&lt; <span class="built_in">Value</span>() &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magnificent</span> :</span> <span class="keyword">public</span> Superb</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Magnificent</span>(<span class="keyword">int</span> h = <span class="number">0</span>, <span class="keyword">char</span> c = <span class="string">&#x27;A&#x27;</span>) : <span class="built_in">Superb</span>(h), <span class="built_in">ch</span>(c) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am a magnificent class I !!\n&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Say</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I hold the character &quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot; and the integer &quot;</span> &lt;&lt; <span class="built_in">Value</span>() &lt;&lt; <span class="string">&quot;!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Grand * <span class="title">GetOne</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">	std::<span class="built_in">srand</span>(std::<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	Grand * pg;</span><br><span class="line">	Superb * ps;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pg - <span class="built_in">GetOne</span>();</span><br><span class="line">		pg-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">		<span class="keyword">if</span> (ps = <span class="keyword">dynamic_cast</span>&lt;Superb *&gt;(pg))</span><br><span class="line">			ps-&gt;<span class="built_in">Say</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Grand * <span class="title">GetOne</span><span class="params">()</span> <span class="comment">// generate one of three kinds of objects randomly</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		   Grand * p;</span><br><span class="line">		   <span class="built_in"><span class="keyword">switch</span></span>(std::<span class="built_in">rand</span>() % <span class="number">3</span>)</span><br><span class="line">		   &#123;</span><br><span class="line">		   <span class="keyword">case</span>	<span class="number">0</span>:	p = <span class="keyword">new</span> <span class="built_in">Grand</span>(std::<span class="built_in">rand</span>()  % <span class="number">100</span>);</span><br><span class="line">			   <span class="keyword">break</span>;</span><br><span class="line">		   <span class="keyword">case</span>	<span class="number">1</span>:	p = <span class="keyword">new</span> <span class="built_in">Superb</span>(std::<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">			   <span class="keyword">break</span>;</span><br><span class="line">		   <span class="keyword">case</span>	<span class="number">2</span>:	p = <span class="keyword">new</span> <span class="built_in">Magnificent</span>(std::<span class="built_in">rand</span>() % <span class="number">100</span>, <span class="string">&#x27;A&#x27;</span> + std::<span class="built_in">rand</span>() % <span class="number">26</span>);</span><br><span class="line">			   <span class="keyword">break</span>;</span><br><span class="line">		   &#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h4 id="更严格的类型转换"><a href="#更严格的类型转换" class="headerlink" title="更严格的类型转换"></a>更严格的类型转换</h4><p>dynamic_cast;  向上转换 (Low类和High类是is-a关系)pointerLow=dynamic_cast&lt;Low*&gt;pointerHigh;<br>const_cast;  const–&gt;volatile 可以修改指针，但不能修改 const int等；<br>static_cast;<br>reinterpret_cast;比较危险的转换<br>reinterpret_cast示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dat</span>&#123;</span><span class="keyword">short</span> a;<span class="keyword">short</span> b;&#125;;</span><br><span class="line"><span class="keyword">long</span> value _0xA224B118;</span><br><span class="line">dat*pd=<span class="keyword">reinterpret_cast</span>&lt;dat*&gt;(&amp;value);</span><br><span class="line">cout&lt;&lt;hex&lt;&lt;pd-&gt;a;</span><br></pre></td></tr></table></figure>


<p><br><br><br></p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>c++07　友元</title>
    <url>/BassHero.github.io/2021/11/06/cpp07friends/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>友元类的所有方法可以访问原始类的私有成员和保护成员</p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p><strong>或 |</strong><br>运算规则：0|0=0&nbsp;&nbsp;&nbsp;&nbsp;0|1=1&nbsp;&nbsp;&nbsp;&nbsp;1|0=1&nbsp;&nbsp;&nbsp;&nbsp;1|1=1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3|5即&nbsp;&nbsp;&nbsp;&nbsp;0000 0011| 0000 0101 = 0000 0111，因此，3|5的值得7<br><strong>异或 ^</strong><br>运算规则：0^0=0&nbsp;&nbsp;&nbsp;&nbsp;0^1=1&nbsp;&nbsp;&nbsp;&nbsp;1^0=1&nbsp;&nbsp;&nbsp;&nbsp;1^1=0<br><strong>取反运算符 (~)</strong><br>运算规则：　<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ～1=0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ～0=1<br><strong>复合赋值运算符</strong><br>&amp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例：a&amp;=b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相当于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a=a&amp;b<br>|=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例：a|=b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相当于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a=a|b<br>/&gt;&gt;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例：a&gt;&gt;=b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相当于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a=a&gt;&gt;b<br>&lt;&lt;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例：a&lt;&lt;=b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相当于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a=a&lt;&lt;b<br>^=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例：a^=b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相当于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a=a^b</p>
<p><strong>条件运算符</strong></p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">void onoff() &#123;<span class="keyword">state</span> = (<span class="keyword">state</span> == On)? Off :On;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>按位异或和赋值运算符</strong></p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">void onoff() &#123;<span class="keyword">state</span> ^= <span class="number">1</span>;&#125;//true(<span class="number">1</span>) or flase(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="友元类-1"><a href="#友元类-1" class="headerlink" title="友元类"></a>友元类</h4><p>让Remote::setchan()成为Tv类的友元的方法是，在Tv类声明中将其声明为友元：<br>且<strong>顺序不得改变</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Tvfm.h</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Tv</span></span>; <span class="comment">//forward declartion</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Remote</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setchan</span><span class="params">(Tv &amp;t,<span class="keyword">int</span> c)</span></span>;</span><br><span class="line">    .. </span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Tv</span></span>&#123;</span><br><span class="line">    friend <span class="keyword">void</span> Remote::setchan(Tv &amp;t,<span class="keyword">int</span> c);</span><br><span class="line">    ....</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<blockquote><p>在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。<br>栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。<br>在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。</p>
</blockquote>
<br>
有时将函数作为两个类的友元更合理，比如一个测量设备class Probe，和一个分析设备class Analyzer，需要使用能同步的计时器。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Analyzer</span>;</span>  <span class="comment">//forward declartion</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Probe</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">(Analyzer &amp;a, <span class="keyword">const</span> Probe &amp;p)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">(Probe &amp;p,<span class="keyword">const</span> Analyzer &amp;a)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Analyzer</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">(Analyzer &amp;a, <span class="keyword">const</span> Probe &amp;p)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">(Probe &amp;p,<span class="keyword">const</span> Analyzer &amp;a)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//define the friend functions</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">(Analyzer &amp;a, <span class="keyword">const</span> Probe &amp;p)</span></span>&#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">(Probe &amp;p,<span class="keyword">const</span> Analyzer &amp;a)</span></span>&#123; ... &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>

<h3 id="嵌套类（nested-class）"><a href="#嵌套类（nested-class）" class="headerlink" title="嵌套类（nested class）"></a>嵌套类（nested class）</h3><p><strong>结构体是一种在默认情况下其成员为公有的类</strong>，以下是优化11.10和12.11<br><br></p>
<details><summary>11.10 mytime3.h(可点开查看)</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYTIME3_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTIME3_H_</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">int</span> hours;</span><br><span class="line">       <span class="keyword">int</span> minutes;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Time</span>();</span><br><span class="line">       <span class="built_in">Timr</span>(<span class="keyword">int</span> h, <span class="keyword">int</span> m=<span class="number">0</span>);</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">addMin</span><span class="params">(<span class="keyword">int</span> m)</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">addHr</span><span class="params">(<span class="keyword">int</span> h)</span></span>;</span><br><span class="line">       Time <span class="keyword">operator</span>+&#123;<span class="keyword">const</span> Time &amp; t&#125; <span class="keyword">const</span>;</span><br><span class="line">       Time <span class="keyword">operator</span>-&#123;<span class="keyword">const</span> Time &amp; t&#125; <span class="keyword">const</span>;</span><br><span class="line">       Time <span class="keyword">operator</span>*&#123;<span class="keyword">const</span> Time &amp; t&#125; <span class="keyword">const</span>;</span><br><span class="line">       <span class="keyword">friend</span> Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time&amp;t)&#123;</span><br><span class="line">           <span class="keyword">return</span> t *m;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">friend</span> std::ostream &amp; <span class="keyword">operator</span> &lt;&lt;(std::ostream &amp;os, <span class="keyword">const</span> Time &amp;t);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>
<details><summary>12.11 queue.cpp(可点开查看)</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//queue.cpp -- Queue and Customer methods</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line">Queue::<span class="built_in">Queue</span>(<span class="keyword">int</span> qs <span class="comment">/* = Q_SIZE */</span>) :<span class="built_in">qsize</span>(qs)</span><br><span class="line">&#123;</span><br><span class="line">	front = rear = <span class="literal">NULL</span>;</span><br><span class="line">	items = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Queue::~<span class="built_in">Queue</span>()</span><br><span class="line">&#123;</span><br><span class="line">	Node * temp;</span><br><span class="line">	<span class="keyword">while</span> (front != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = front;</span><br><span class="line">		front = front-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Queue::isempty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> items == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Queue::isfull</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> items == qsize;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue::queuecount</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> items;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Queue::enqueue</span><span class="params">(<span class="keyword">const</span> Item &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isfull</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	Node * add = <span class="keyword">new</span> Node;</span><br><span class="line">	add-&gt;item = item;</span><br><span class="line">	add-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	items++;</span><br><span class="line">	<span class="keyword">if</span> (front == <span class="literal">NULL</span>)</span><br><span class="line">		front = add;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		rear-&gt;next = add;</span><br><span class="line">	rear = add;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Queue::dequeue</span><span class="params">(Item &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (front == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	item = front-&gt;item;</span><br><span class="line">	items--;</span><br><span class="line">	Node * temp = front;</span><br><span class="line">	front = front-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> temp;</span><br><span class="line">	<span class="keyword">if</span> (items == <span class="number">0</span>)</span><br><span class="line">		rear = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Customer::set</span><span class="params">(<span class="keyword">long</span> when)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	processtime = std::<span class="built_in">rand</span>() % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">	arrive = when;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<br><br>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">class Queue&#123;</span><br><span class="line">  class <span class="keyword">Node</span><span class="title">&#123;</span></span><br><span class="line"><span class="title">    public</span>:</span><br><span class="line">        Item item;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">*next</span>;</span><br><span class="line">        <span class="keyword">Node</span><span class="title">(const</span> Item &amp;i):item(i),next(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
该构造函数将节点的item成员初始化为i，并将next指针指设置为0（空指针的方法之一）

<blockquote><p>空指针的方法：<br>1.0<br>2.NULL，但是需要写一个NULL的有文件<br>3.nullptr（C::11）</p>
</blockquote>
<p>重新编写enqueue方法</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">bool Queue::enqueue(const Item &amp;item)&#123;</span><br><span class="line">  if(isfull()) return flase;</span><br><span class="line">  <span class="keyword">Node</span><span class="title">* add</span>=new <span class="keyword">Node</span><span class="title">(item</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
将queue模板转定义为模板
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// queuetp.h -- queue template with a nested class </span></span><br><span class="line">#ifndef QUEUETP_H_</span><br><span class="line">#define QUEUETP_H_</span><br><span class="line"> </span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">Item</span>&gt;</span><br><span class="line"> </span><br><span class="line"><span class="symbol">class</span> <span class="symbol">QueueTP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">enum</span> &#123; Q_SIZE = <span class="number">10</span> &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Node is a nested class definition </span></span><br><span class="line">	<span class="keyword">class</span> <span class="symbol">Node</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Item item;</span><br><span class="line">		Node * next;</span><br><span class="line">		Node(<span class="keyword">const</span> Item &amp; i) :item(i), next(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"> </span><br><span class="line">	Node * front; <span class="comment">// pointer to front of Queue</span></span><br><span class="line">	Node * rear; <span class="comment">// pointer to rear of Queue</span></span><br><span class="line">	<span class="built_in">int</span> items; <span class="comment">// current number of items in Queue</span></span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">int</span> qsize; <span class="comment">// maximum number of items in Queue</span></span><br><span class="line">	QueueTP(<span class="keyword">const</span> QueueTP &amp; q) : qsize(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	QueueTP &amp; operator= (<span class="keyword">const</span> QueueTP &amp; q) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	QueueTP(<span class="built_in">int</span> qs = Q_SIZE);</span><br><span class="line">	~QueueTP();</span><br><span class="line">	<span class="built_in">bool</span> isempty() <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> items == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">bool</span> isfull() <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">return</span> items == qsize;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">int</span> queuecount() <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> items;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">bool</span> enqueue(<span class="keyword">const</span> Item &amp;item); <span class="comment">// add item to end </span></span><br><span class="line">	<span class="built_in">bool</span> dequeue(Item &amp;item) ;	<span class="comment">// remove item from front</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// QueueTP methods</span></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">Item</span>&gt;</span><br><span class="line"><span class="symbol">QueueTP</span>&lt;<span class="symbol">Item</span>&gt;::<span class="symbol">QueueTP</span>(<span class="symbol">int</span> <span class="symbol">qs</span>) : <span class="symbol">qsize</span>(<span class="symbol">qs</span>)</span><br><span class="line">&#123;</span><br><span class="line">	front = rear = <span class="number">0</span>; </span><br><span class="line">	items = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">Item</span>&gt;</span><br><span class="line"><span class="symbol">QueueTP</span>&lt;<span class="symbol">Item</span>&gt; ::~<span class="symbol">QueueTP</span>()</span><br><span class="line">&#123;</span><br><span class="line">	Node * temp;</span><br><span class="line">	<span class="keyword">while</span> (front != <span class="number">0</span>)	<span class="comment">// while queue is not yet empty</span></span><br><span class="line">	&#123;</span><br><span class="line">		temp = front; <span class="comment">// save address of front item </span></span><br><span class="line">		front = front-&gt;next;<span class="comment">// reset pointer to next item </span></span><br><span class="line">		delete temp; <span class="comment">// delete former front</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Add item to queue</span></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">Item</span>&gt;</span><br><span class="line"><span class="symbol">bool</span> <span class="symbol">QueueTP</span>&lt;<span class="symbol">Item</span>&gt;::<span class="symbol">enqueue</span>(<span class="symbol">const</span> <span class="symbol">Item</span> &amp; <span class="symbol">item</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (isfull())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	Node * add = new Node(item); <span class="comment">// create node // on failure, new throws std::bad_alloc exception </span></span><br><span class="line">	items++;</span><br><span class="line">	<span class="keyword">if</span> (front == <span class="number">0</span>)	<span class="comment">// if queue is empty,</span></span><br><span class="line">		front = add;	<span class="comment">// place item at front</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		rear-&gt;next = add; <span class="comment">// else place at rear</span></span><br><span class="line">	rear = add;<span class="comment">// have rear point to new node</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// Place front item into item variable and remove from queue </span></span><br><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">Item</span>&gt;</span><br><span class="line"><span class="symbol">bool</span> <span class="symbol">QueueTP</span>&lt;<span class="symbol">Item</span>&gt;::<span class="symbol">dequeue</span>(<span class="symbol">Item</span> &amp; <span class="symbol">item</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (front == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">	item = front-&gt;item;<span class="comment">// set item to first item in queue</span></span><br><span class="line">	items--;</span><br><span class="line">	Node * temp = front; <span class="comment">// save location of first item </span></span><br><span class="line">	front = front -&gt; next; <span class="comment">// reset front to next item</span></span><br><span class="line">	delete temp;  <span class="comment">// delete former first item</span></span><br><span class="line">	<span class="keyword">if</span> (items == <span class="number">0</span>)</span><br><span class="line">		rear = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
测试
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nested.cpp -- using a queue that has a nested class </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;queuetp.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::string;</span><br><span class="line">	<span class="keyword">using</span> std::cin;</span><br><span class="line">	<span class="keyword">using</span> std::cout;</span><br><span class="line"> </span><br><span class="line">	<span class="function">QueueTP&lt;string&gt; <span class="title">cs</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	string temp;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span> (!cs.<span class="built_in">isfull</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Please enter your name. You will be served in the order of arrival.\nname: &quot;</span>;</span><br><span class="line">		<span class="built_in">getline</span>(cin, temp);</span><br><span class="line">		cs.<span class="built_in">enqueue</span>(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The queue is full. Processing begins!\n&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span> (!cs.<span class="built_in">isempty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cs.<span class="built_in">dequeue</span>(temp);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Now processing &quot;</span> &lt;&lt; temp &lt;&lt; <span class="string">&quot;...\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>C　PrimerPlus(6) 14私有继承与类模板</title>
    <url>/BassHero.github.io/2021/09/25/cpp06classtemplate/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h3 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h3><p>实现has-a关系的方法除了包含还有私有继承。<br>推荐使用包含。<br><strong>私有成员永远只能被本类的成员函数访问，或者是友元访问，除此以外，即使是其派生出的子类，也不能直接访问这些私有成员。</strong><br>私有继承也是默认的继承方式，如果没有继承方式的关键字说明，默认为私有继承。<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>私有继承-如何定义类</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Student</span> : <span class="symbol">private</span> <span class="symbol">std::<span class="symbol">string</span>,<span class="symbol">private</span></span> <span class="symbol">std::<span class="symbol">valarray</span></span>&lt;<span class="symbol">double</span>&gt;&#123;</span><br><span class="line">    <span class="comment">//上文指出student类是从string类和valarray类派生而来</span></span><br><span class="line">    <span class="comment">//多重继承</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在包含中，人们使用这样的构造函数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Student(const char* str,const double <em>pd,int n):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name(str),scores</em>(pd,n)//use object name<br>在私有继承中，人们使用这样的构造函数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Student(const char* str,const double *pd,int n):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background-color:#ffcccb">std::string(str)</span>,<span style="background-color:#ffcccb">ArrayDB(pd,n)</span>//use class name</p>
<h4 id="访问基类的方法"><a href="#访问基类的方法" class="headerlink" title="访问基类的方法"></a>访问基类的方法</h4><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> Student::Average() const&#123;</span><br><span class="line">    <span class="keyword">if</span> (ArrayDb::<span class="built_in">size</span>()&gt;<span class="number">0</span>) <span class="keyword">return</span> ArrayDb::<span class="built_in">sum</span>()/ArrayDb::<span class="built_in">size</span>();</span><br><span class="line">    //<span class="keyword">use</span> <span class="keyword">class</span> <span class="keyword">name</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问基类的对象-—-强制类型转换与-this指针"><a href="#访问基类的对象-—-强制类型转换与-this指针" class="headerlink" title="访问基类的对象 —=强制类型转换与*this指针"></a>访问基类的对象 —=强制类型转换与*this指针</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure>

<h4 id="访问基类友元函数"><a href="#访问基类友元函数" class="headerlink" title="访问基类友元函数"></a>访问基类友元函数</h4><p>友元函数定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os,<span class="keyword">const</span> Student &amp; stu)&#123;</span><br><span class="line">    os &lt;&lt;<span class="string">&quot;Scores for &quot;</span>&lt;&lt;(<span class="keyword">const</span> string &amp;) stu &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果plato是Student对象的话，plato指向的是Student &amp; stu，os指向的是cout地引用：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">os&lt;&lt; stu<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>私有继承需要通过显式地转换为基类来调用函数</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">os &lt;&lt;<span class="string">&quot;Scores for &quot;</span>&lt;&lt;(<span class="keyword">const</span> string &amp;) stu &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h3><p>保护成员扩大的访问范围表现在：基类的保护成员可以在派生类的成员函数中被访问。<br>| 特征        | 公有继承     | 保护继承   | 私有继承   |<br>|———-|————–|————-|————–|<br>| 公有成员变成| public   | protected   | private   |<br>| 保护成员变成| protected   | protected  | private   |<br>| 私有成员变成| interface   | interfce   | interface   |<br>| 隐式向上转换| True   | True(派生类)   | False   |</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>多重继承的问题：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.从两个不同的基类继承同名方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.继承同一个类的实例<br>解决方法————虚基类，可以从多个类派生出的对象只继承一个基类对象(virtual public的次序无关紧要)。</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line">class <span class="type">Singer</span>: virtual public <span class="type">Woker</span><span class="meta">&#123;...&#125;</span>;</span><br><span class="line">class <span class="type">Waiter</span>: public virtual <span class="type">Woker</span><span class="meta">&#123;...&#125;</span>;</span><br><span class="line"></span><br><span class="line">class <span class="type">SingerWaiter</span> : public <span class="type">Singer</span>, public <span class="type">Waiter</span>;</span><br></pre></td></tr></table></figure>

<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>10章的Stack类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> Item;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="class"><span class="keyword">enum</span> &#123;</span>MAX=<span class="number">10</span>&#125;;</span><br><span class="line">      Item items[MAX];</span><br><span class="line">      <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Stack</span>();</span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">isempty</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">isfull</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> Item&amp;item)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(Item&amp;item)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>替换为stack模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stacktp.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STACKTP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKTP_H_</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="class"><span class="keyword">enum</span> &#123;</span>MAX=<span class="number">10</span>&#125;;</span><br><span class="line">      Item items[MAX];</span><br><span class="line">      <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Stack</span>();</span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">isempty</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">isfull</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> Item &amp; item)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(Item &amp; item)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> Stack &lt;Type&gt;::<span class="built_in">Stack</span>()&#123;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="keyword">bool</span> Stack&lt;Type&gt;::<span class="built_in">isempty</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="keyword">bool</span> Stack::isfull&#123;</span><br><span class="line">    <span class="keyword">return</span> top == MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="function"><span class="keyword">bool</span> <span class="title">Stack::push</span><span class="params">(<span class="keyword">const</span> Item &amp; item)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ( top &lt; MAX )&#123;</span><br><span class="line">        items[top++]=item;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;<span class="keyword">else</span>  <span class="keyword">return</span> flase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="function"><span class="keyword">bool</span> <span class="title">Stack::pop</span><span class="params">(Item &amp; item)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ( top &lt; MAX )&#123;</span><br><span class="line">        items=item[--top];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;<span class="keyword">else</span>  <span class="keyword">return</span> flase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>泛型识标符、类型参数————Type，赋给他的不是能是数字，只能是类型。<br>与函数模板的区别，需要显示提供所需的类型：<br><strong>Stack<a href="std::String">std::String</a> st;</strong></p>
<h4 id="类模板使用指针"><a href="#类模板使用指针" class="headerlink" title="类模板使用指针"></a>类模板使用指针</h4><p>不推荐<br><br></p>
<h4 id="类模板用作容器————数组模板"><a href="#类模板用作容器————数组模板" class="headerlink" title="类模板用作容器————数组模板"></a>类模板用作容器————数组模板</h4><br>

<h4 id="递归使用模板制作2维数组"><a href="#递归使用模板制作2维数组" class="headerlink" title="递归使用模板制作2维数组"></a>递归使用模板制作2维数组</h4><p>请注意，在模板语法中维的顺序与等价的二维数组相反，即i，j互换。<br><br></p>
<h4 id="默认模板参数类型"><a href="#默认模板参数类型" class="headerlink" title="默认模板参数类型"></a>默认模板参数类型</h4><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class <span class="type">T1</span>,class <span class="type">T2</span> = <span class="built_in">int</span>&gt; class <span class="type">Topo</span><span class="meta">&#123;...&#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Topo</span>&lt;double,double&gt; m1;</span><br><span class="line"><span class="type">Topo</span>&lt;double&gt;m2;</span><br></pre></td></tr></table></figure>
<br>

<h4 id="模板的具体化"><a href="#模板的具体化" class="headerlink" title="模板的具体化"></a>模板的具体化</h4><p>如果有多个模板，编译器会首先选择具体化最高的模板。</p>
<h5 id="隐式实例化"><a href="#隐式实例化" class="headerlink" title="隐式实例化"></a>隐式实例化</h5><p>目前为止都是隐式实例化,声明对象后指出类型</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Array</span>&lt;<span class="type">double</span>,<span class="number">100</span>&gt; stuff;</span><br></pre></td></tr></table></figure>
<br>

<h5 id="显式实例化"><a href="#显式实例化" class="headerlink" title="显式实例化"></a>显式实例化</h5><p>修饰词用template</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;</span>string,<span class="number">100</span>&gt;;</span><br></pre></td></tr></table></figure>
<br>

<h5 id="显式具体化"><a href="#显式具体化" class="headerlink" title="显式具体化"></a>显式具体化</h5><p>为特殊类型特化，需要对模板进行修改。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">SortedArray</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>泛式模板的T可以是数值，可以是类(需要定义T::opertor&gt;())，但是T不能是const char*(将会按照单个字符来排列)，这时就需要显式具体化模板<br><br></p>
<h5 id="部分具体化"><a href="#部分具体化" class="headerlink" title="部分具体化"></a>部分具体化</h5><p>即部分限制模板的通用性，比如指定一个具体的类型。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//general template </span></span><br><span class="line">  template &lt;<span class="keyword">class</span> <span class="symbol">T1,<span class="symbol">class</span></span> <span class="symbol">T2,<span class="symbol">class</span></span> <span class="symbol">T3</span>&gt;<span class="symbol">class</span> <span class="symbol">paris</span>&#123;&#125;;</span><br><span class="line"><span class="comment">//specialiazed template </span></span><br><span class="line">  template &lt;<span class="keyword">class</span> <span class="symbol">T1</span> &gt;<span class="symbol">class</span> <span class="symbol">paris</span>&lt;<span class="symbol">T1,<span class="symbol">int</span></span>&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>
<br>

<h4 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h4><p>模板可做结构，类和模板类成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tempmemb.cpp--- template members</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout; </span><br><span class="line"><span class="keyword">using</span> std::endl; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">beta</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V&gt; <span class="comment">// nested template class member </span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">hold</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		V val;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">hold</span>(V v = <span class="number">0</span>) : <span class="built_in">val</span>(v) &#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; cout &lt;&lt; val &lt;&lt; endl; &#125;</span><br><span class="line">		<span class="function">V <span class="title">Value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">beta</span>(T t, <span class="keyword">int</span> i) : <span class="built_in">q</span>(t), <span class="built_in">n</span>(i) &#123;&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="comment">// template method</span></span><br><span class="line">	<span class="function">U <span class="title">blab</span><span class="params">(U u, T t)</span> </span>&#123; <span class="keyword">return</span> (n.<span class="built_in">Value</span>() + q.<span class="built_in">Value</span>()) * u / t &#125;</span><br><span class="line">	<span class="keyword">void</span> <span class="built_in">Show</span>() <span class="keyword">const</span> &#123; q.<span class="built_in">show</span>(); n.<span class="built_in">show</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">beta&lt;<span class="keyword">double</span>&gt; <span class="title">guy</span><span class="params">(<span class="number">3.5</span>, <span class="number">3</span>)</span></span>; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T was set to double\n&quot;</span>; </span><br><span class="line">	guy.<span class="built_in">Show</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;V was set to T, which is-double, then V was set to int\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; guy.<span class="built_in">blab</span>(<span class="number">10</span>, <span class="number">2.3</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;U was set to int\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; guy.<span class="built_in">blab</span>(<span class="number">10.0</span>, <span class="number">2.3</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;U was set to double\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Done\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
**上述定义将T，V和U作为模板参数，因为模板是嵌套的，必须如下声明：**
template<typename T>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;template<typename V>
而不能用这个方法：~~template<typename T，typename V>~~
<br>

<h4 id="模板作为参数"><a href="#模板作为参数" class="headerlink" title="模板作为参数"></a>模板作为参数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// tempparm.cpp - templates as parameters </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stacktp.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Thing</span> &gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crab</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Thing&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">	Thing&lt;<span class="keyword">double</span>&gt; s2; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Crab</span> () &#123;&#125;;</span><br><span class="line">	<span class="comment">// assumes the thing class has pushd and pop() members</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> sl.<span class="built_in">push</span>(a) &amp;&amp; s2.<span class="built_in">push</span>(x); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> &amp; a, <span class="keyword">double</span> &amp; x)</span> </span>&#123; <span class="keyword">return</span> sl.<span class="built_in">pop</span>(a) &amp;&amp; s2.<span class="built_in">pop</span>(x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::cout;</span><br><span class="line">	<span class="keyword">using</span> std::cin;</span><br><span class="line">	<span class="keyword">using</span> std::endl;</span><br><span class="line">	Crab&lt;Stack&gt; nebula;</span><br><span class="line">	<span class="comment">// Stack must match template &lt;typename T&gt; class thing </span></span><br><span class="line">	<span class="keyword">int</span> ni;</span><br><span class="line">	<span class="keyword">double</span> nb;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter int double pairs, such as 4 3.5 (0 0 to end):\n&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; ni &gt;&gt; nb &amp;&amp; ni &gt; <span class="number">0</span> &amp;&amp; nb &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!nebula.<span class="built_in">push</span>(ni, nb))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (nebula.<span class="built_in">pop</span>(ni, nb))</span><br><span class="line">		cout &lt;&lt; ni &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; nb &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Done.\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>

<h4 id="模板类和友元"><a href="#模板类和友元" class="headerlink" title="模板类和友元"></a>模板类和友元</h4><p>模板的友元分为3类：<br>1.非模板友元<br>2.约束模板友元<br>3.非约束模板友元<br><br><br></p>
<h5 id="非模板友元"><a href="#非模板友元" class="headerlink" title="非模板友元"></a>非模板友元</h5><p>格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasFriend</span>&lt;</span><span class="keyword">int</span>&gt;&#123;</span><br><span class="line">      <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">report</span> <span class="params">(HasFriend&lt;T&gt; &amp;)</span></span>;</span><br><span class="line">      ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="模板类的约束模板友元"><a href="#模板类的约束模板友元" class="headerlink" title="模板类的约束模板友元"></a>模板类的约束模板友元</h5><p>首先在类定义里声明模板，然后在函数定义里再次声明友元</p>
<p>&lt;&gt;指出这是模板具体化，report可以省略因为可以从参数来判断，<br>counts()没有参数，因此必须使用参数模板语法<TT>来指明其具体化，TT指的是HasFriendT类的参数类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">void</span> <span class="title">counts</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(T &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">hasfriendT</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">void</span> counts&lt;TT&gt;();</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">void</span> report&lt;&gt;(hasfriendT&lt;TT&gt; &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假设声明了   HasFriendT<int> squack；<br>编译器将用int代替<TT></p>
<h5 id="非约束模板友元"><a href="#非约束模板友元" class="headerlink" title="非约束模板友元"></a>非约束模板友元</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">manyfriendT</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C,<span class="keyword">typename</span> D&gt;<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">(C &amp;,D &amp;)</span></span>;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">void</span> report&lt;&gt;(hasfriendT&lt;T T&gt;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="模板别名"><a href="#模板别名" class="headerlink" title="模板别名"></a>模板别名</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">   <span class="keyword">using</span>  arrtype = std::array&lt;T,<span class="number">12</span>&gt;;</span><br></pre></td></tr></table></figure>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>C　PrimerPlus(5) 13类继承与接口</title>
    <url>/BassHero.github.io/2021/09/24/cpp05Inherit/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口与实现</p>
<blockquote><p>使用公有继承时，类可以继承接口，可能还有实现（基类的纯虚函数提供接口，但不提供实现）\n<br>获得接口是is-a关系的组成部分。\n<br>而使用组合，类可以获得实现，但不能获得接口。不继承接口是has-a关系的组成部分。\n</p>
</blockquote>
<br>

<p><strong>而使用组合，类可以获得实现，但不能获得接口。</strong>:组合通过object.function()引用。<br><br><br></p>
<h3 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Circle</span> ：<span class="symbol">public</span> <span class="symbol">Ellipse</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;抽象类（ABC，abstract）必须包含一个<strong>纯虚函数</strong>（virtual）。<br>基类指针可以访问派生类对象，但是不能访问仅属于派生类的元素，这时候我们用虚函数来调用子类的这个函数。<br>纯虚函数则是用来实现接口。</p>
<p>虚类，即含有虚函数但不含有纯虚函数的类。<br>抽象类，即含有纯虚函数和非虚函数的类。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基类使用动态分配内存，并重新定义赋值和复制构造函数，派生类也是用new时必须为派生类定义显示的析构函数、复制构造函数和赋值构造函数。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;派生类</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">hasDMA</span> :<span class="symbol">public</span> <span class="symbol">baseDMA</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       char* style;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;定义派生类独有的析构函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">baeDMA::~<span class="function"><span class="title">baseDMA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> []  label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hase DMA::~<span class="function"><span class="title">hasDMA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] style;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当派生类想要生成基类的temp-copy时无法访问基类数据，派生类的复制构造函数必须<strong>调用</strong>基类的复制构造函数来处理共享的基类数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hasDMA::<span class="built_in">hasDMA</span>(<span class="keyword">const</span> hasDMA &amp;hs): <span class="built_in">baseDMA</span>(hs)&#123;</span><br><span class="line">    style=<span class="keyword">new</span> <span class="keyword">char</span>[std::<span class="built_in">strlen</span>(hs.style)+<span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(style,hs.style);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;派生类赋值构造函数则是需要通过显式调用.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//baseClass</span></span><br><span class="line">baseDMA &amp; baseDMA::<span class="keyword">operator</span>=(<span class="keyword">const</span> baseDMA &amp;rs)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==&amp;rs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] label;</span><br><span class="line">    label=<span class="keyword">new</span> <span class="keyword">char</span>[std::<span class="built_in">strlen</span>(hs.style)+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">strcpy</span>(label,rs.label);</span><br><span class="line">    rating=rs.rating;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stance</span></span><br><span class="line">hasDMA &amp; hasDMA::<span class="keyword">operator</span>=(<span class="keyword">const</span> hasDMA &amp;hs)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==&amp;hs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    baseDMA::<span class="keyword">operator</span>=(hs);</span><br><span class="line">    <span class="keyword">delete</span> [] label;</span><br><span class="line">    label=<span class="keyword">new</span> <span class="keyword">char</span>[std::<span class="built_in">strlen</span>(hs.style)+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">strcpy</span>(label,rs.label);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>dma.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DMA_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DMA_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//  Base Class Using DMA</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">baseDMA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> * label;</span><br><span class="line">    <span class="keyword">int</span> rating;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">baseDMA</span>(<span class="keyword">const</span> <span class="keyword">char</span> * l = <span class="string">&quot;null&quot;</span>, <span class="keyword">int</span> r = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">baseDMA</span>(<span class="keyword">const</span> baseDMA &amp; rs);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">baseDMA</span>();</span><br><span class="line">    baseDMA &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> baseDMA &amp; rs);</span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, </span><br><span class="line">                                     <span class="keyword">const</span> baseDMA &amp; rs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// derived class without DMA</span></span><br><span class="line"><span class="comment">// no destructor needed</span></span><br><span class="line"><span class="comment">// uses implicit copy constructor</span></span><br><span class="line"><span class="comment">// uses implicit assignment operator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lacksDMA</span> :</span><span class="keyword">public</span> baseDMA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> COL_LEN = <span class="number">40</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> color[COL_LEN];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lacksDMA</span>(<span class="keyword">const</span> <span class="keyword">char</span> * c = <span class="string">&quot;blank&quot;</span>, <span class="keyword">const</span> <span class="keyword">char</span> * l = <span class="string">&quot;null&quot;</span>,</span><br><span class="line">              <span class="keyword">int</span> r = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">lacksDMA</span>(<span class="keyword">const</span> <span class="keyword">char</span> * c, <span class="keyword">const</span> baseDMA &amp; rs);</span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, </span><br><span class="line">                                     <span class="keyword">const</span> lacksDMA &amp; rs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// derived class with DMA</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hasDMA</span> :</span><span class="keyword">public</span> baseDMA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> * style;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hasDMA</span>(<span class="keyword">const</span> <span class="keyword">char</span> * s = <span class="string">&quot;none&quot;</span>, <span class="keyword">const</span> <span class="keyword">char</span> * l = <span class="string">&quot;null&quot;</span>,</span><br><span class="line">              <span class="keyword">int</span> r = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">hasDMA</span>(<span class="keyword">const</span> <span class="keyword">char</span> * s, <span class="keyword">const</span> baseDMA &amp; rs);</span><br><span class="line">    <span class="built_in">hasDMA</span>(<span class="keyword">const</span> hasDMA &amp; hs);</span><br><span class="line">    ~<span class="built_in">hasDMA</span>();</span><br><span class="line">    hasDMA &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> hasDMA &amp; rs);  </span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, </span><br><span class="line">                                     <span class="keyword">const</span> hasDMA &amp; rs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><br><br><br>dma.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dma.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">// baseDMA methods</span></span><br><span class="line">baseDMA::<span class="built_in">baseDMA</span>(<span class="keyword">const</span> <span class="keyword">char</span> * l, <span class="keyword">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    label = <span class="keyword">new</span> <span class="keyword">char</span>[std::<span class="built_in">strlen</span>(l) + <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(label, l);</span><br><span class="line">    rating = r;</span><br><span class="line">&#125;</span><br><span class="line">baseDMA::<span class="built_in">baseDMA</span>(<span class="keyword">const</span> baseDMA &amp; rs)</span><br><span class="line">&#123;</span><br><span class="line">    label = <span class="keyword">new</span> <span class="keyword">char</span>[std::<span class="built_in">strlen</span>(rs.label) + <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(label, rs.label);</span><br><span class="line">    rating = rs.rating;</span><br><span class="line">&#125;</span><br><span class="line">baseDMA::~<span class="built_in">baseDMA</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] label;</span><br><span class="line">&#125;</span><br><span class="line">baseDMA &amp; baseDMA::<span class="keyword">operator</span>=(<span class="keyword">const</span> baseDMA &amp; rs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rs)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] label;</span><br><span class="line">    label = <span class="keyword">new</span> <span class="keyword">char</span>[std::<span class="built_in">strlen</span>(rs.label) + <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(label, rs.label);</span><br><span class="line">    rating = rs.rating;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="keyword">const</span> baseDMA &amp; rs)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Label: &quot;</span> &lt;&lt; rs.label &lt;&lt; std::endl;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Rating: &quot;</span> &lt;&lt; rs.rating &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lacksDMA methods</span></span><br><span class="line">lacksDMA::<span class="built_in">lacksDMA</span>(<span class="keyword">const</span> <span class="keyword">char</span> * c, <span class="keyword">const</span> <span class="keyword">char</span> * l, <span class="keyword">int</span> r)</span><br><span class="line">    : <span class="built_in">baseDMA</span>(l, r)</span><br><span class="line">&#123;</span><br><span class="line">    std::<span class="built_in">strncpy</span>(color, c, <span class="number">39</span>);</span><br><span class="line">    color[<span class="number">39</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">lacksDMA::<span class="built_in">lacksDMA</span>(<span class="keyword">const</span> <span class="keyword">char</span> * c, <span class="keyword">const</span> baseDMA &amp; rs)</span><br><span class="line">    : <span class="built_in">baseDMA</span>(rs)</span><br><span class="line">&#123;</span><br><span class="line">    std::<span class="built_in">strncpy</span>(color, c, COL_LEN - <span class="number">1</span>);</span><br><span class="line">    color[COL_LEN - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="keyword">const</span> lacksDMA &amp; ls)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; (<span class="keyword">const</span> baseDMA &amp;) ls;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Color: &quot;</span> &lt;&lt; ls.color &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hasDMA methods</span></span><br><span class="line">hasDMA::<span class="built_in">hasDMA</span>(<span class="keyword">const</span> <span class="keyword">char</span> * s, <span class="keyword">const</span> <span class="keyword">char</span> * l, <span class="keyword">int</span> r)</span><br><span class="line">         : <span class="built_in">baseDMA</span>(l, r)</span><br><span class="line">&#123;</span><br><span class="line">    style = <span class="keyword">new</span> <span class="keyword">char</span>[std::<span class="built_in">strlen</span>(s) + <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(style, s);</span><br><span class="line">&#125;</span><br><span class="line">hasDMA::<span class="built_in">hasDMA</span>(<span class="keyword">const</span> <span class="keyword">char</span> * s, <span class="keyword">const</span> baseDMA &amp; rs)</span><br><span class="line">         : <span class="built_in">baseDMA</span>(rs)</span><br><span class="line">&#123;</span><br><span class="line">    style = <span class="keyword">new</span> <span class="keyword">char</span>[std::<span class="built_in">strlen</span>(s) + <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(style, s);</span><br><span class="line">&#125;</span><br><span class="line">hasDMA::<span class="built_in">hasDMA</span>(<span class="keyword">const</span> hasDMA &amp; hs)</span><br><span class="line">         : <span class="built_in">baseDMA</span>(hs)  <span class="comment">// invoke base class copy constructor</span></span><br><span class="line">&#123;</span><br><span class="line">    style = <span class="keyword">new</span> <span class="keyword">char</span>[std::<span class="built_in">strlen</span>(hs.style) + <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(style, hs.style);</span><br><span class="line">&#125;</span><br><span class="line">hasDMA::~<span class="built_in">hasDMA</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] style;</span><br><span class="line">&#125;</span><br><span class="line">hasDMA &amp; hasDMA::<span class="keyword">operator</span>=(<span class="keyword">const</span> hasDMA &amp; hs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;hs)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    baseDMA::<span class="keyword">operator</span>=(hs);  <span class="comment">// copy base portion</span></span><br><span class="line">    <span class="keyword">delete</span> [] style;         <span class="comment">// prepare for new style</span></span><br><span class="line">    style = <span class="keyword">new</span> <span class="keyword">char</span>[std::<span class="built_in">strlen</span>(hs.style) + <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(style, hs.style);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="keyword">const</span> hasDMA &amp; hs)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; (<span class="keyword">const</span> baseDMA &amp;) hs;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Style: &quot;</span> &lt;&lt; hs.style &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><br><br></p>
<h3 id="const的位置与用法"><a href="#const的位置与用法" class="headerlink" title="const的位置与用法"></a>const的位置与用法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保证<span style="background-color:#ffcccb">参数</span>不被修改</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="type">Star</span>::star(<span class="keyword">const</span> <span class="built_in">char</span> *s)<span class="meta">&#123;...&#125;</span></span><br><span class="line">//即使时数组指针也无法修改</span><br></pre></td></tr></table></figure>
<p><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保证<span style="background-color:#ffcccb">调用对象</span>不被修改</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> <span class="type">Star</span>::show() <span class="keyword">const</span> <span class="meta">&#123;...&#125;</span></span><br><span class="line">//即this.的所有参数无法修改</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也可以放于返回值之前，意味着可以初始化返回对象中的变量，但无法修改返回对象的数据</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>C　PrimerPlus(4) 11使用类12类的动态内存</title>
    <url>/BassHero.github.io/2021/09/23/cpp04objectAndClass/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h3 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h3><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Time</span> <span class="keyword">Time</span>::operator+(const <span class="keyword">Time</span> &amp;t)const&#123;</span><br><span class="line">    <span class="keyword">Time</span> <span class="built_in">sum</span>;</span><br><span class="line">    <span class="built_in">sum</span>.minutes = minutes + t.minutes;</span><br><span class="line">    <span class="built_in">sum</span>.hours = hours + t.hours+su.minutes/<span class="number">60</span>;</span><br><span class="line">    <span class="built_in">sum</span>.minutes %= <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>通过让函数称为类的友元，可以赋予该函数与类的成员函数相同的访问权限<br>符号重载实现B<em>2.78， 友元的符号重载实现2.78</em>B<br>&nbsp;&nbsp;&nbsp;&nbsp;1.将友元函数的声明放入类声明中   2.不要再定义函数时加上friend</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="type">Time</span> operator:(double m,<span class="keyword">const</span> <span class="type">Time</span> &amp;t)&#123;</span><br><span class="line">    <span class="type">Time</span> <span class="literal">result</span>;</span><br><span class="line">    long totalminutes = t.hours*m*<span class="number">60</span>  +  t.minutes*m</span><br><span class="line">    <span class="literal">result</span>.minutes = totalminutes%<span class="number">60</span>;</span><br><span class="line">    <span class="literal">result</span>.hours = totalminutes/<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br><br></p>
<h3 id="类的动态内存"><a href="#类的动态内存" class="headerlink" title="类的动态内存"></a>类的动态内存</h3><p> &nbsp;&nbsp;&nbsp;&nbsp;<strong>类对象作为函数参数调用时，将会产生对象的副本，而这个个副本是调用类中的拷贝构造函数实现的，如果类中没有自定义拷贝构造，编译器会自动生成一个缺省的函数，该函数有以下特点：</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、对于基本类型的成员变量，按字节复制<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、对于类类型的成员变量，将自动调用相应类的拷贝函数来初始化<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、指针只是简单的赋值，而不会自动分配内存<br><br><br> &nbsp;&nbsp;&nbsp;&nbsp;当退出该函数时，副本将调用析构函数，删除该指针，指针所指向内存也已被释放。将原始对象只保留一个指针值。当该类再次调用析构函数时会出现double free的错误。<br> 解决方法：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、自定义拷贝函数<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、将对象作为引用传递</p>
<p><br><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;特殊成员函数：默认构造函数，默认析构函数，复制构造函数，赋值运算函数，地址运算函数<br><br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;复制构造函数：创建一个新对象并将其初始化一个 <strong>现有对象</strong>，参数为指向类对象的常量。<strong>按值进行复制</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;NULL是表示空指针的C语言宏。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>C PrimerPlus(3) 函数与命名空间</title>
    <url>/BassHero.github.io/2021/09/22/cpp03funcAndNamespace/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h3 id="8-5显式具体化"><a href="#8-5显式具体化" class="headerlink" title="8.5显式具体化"></a>8.5显式具体化</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;显式具体化：可以提供具体化函数定义。</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// non template function prototype</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(job&amp;,job&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//template prototype</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;,T &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//explicit specialization for the job type</span></span><br><span class="line"><span class="comment">//程序选择时，显式具体化优先于第二个模板生成</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> Swap&lt;job&gt;(job &amp;,job &amp;);</span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;习题8.8：操作string，输入字符转成大写。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="9-1内存模型和名称空间"><a href="#9-1内存模型和名称空间" class="headerlink" title="9.1内存模型和名称空间"></a>9.1内存模型和名称空间</h3></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>C PrimerPlus(2) string与char[]、char*</title>
    <url>/BassHero.github.io/2021/09/21/cpp02string/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h3 id="c语言"><a href="#c语言" class="headerlink" title="c语言"></a>c语言</h3><p>printf只能用char*型，所以需要转换成string型。<br><code>str.c_str()</code></p>
<h4 id="string-h-函数库"><a href="#string-h-函数库" class="headerlink" title="string.h 函数库"></a>string.h 函数库</h4><p><strong>连接文字符</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;char *strcat(char *s, chat *a);<br>&nbsp;&nbsp;&nbsp;&nbsp;char *strncat(char *s, chat *a, int n);<br><strong>比较</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;int strcmp(char *s, chat *t);<br>&nbsp;&nbsp;&nbsp;&nbsp;int strncmp(char *s, chat *t, int n);<br><strong>复制</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;char *strcpy(char *d, chat *s);<br>&nbsp;&nbsp;&nbsp;&nbsp;char *strncpy(char *d, chat *s, int n);<br><strong>求长</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;int strlen(chat *s);<br><strong>位置</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;char *strchr(chat *s, int c);<br>&nbsp;&nbsp;&nbsp;&nbsp;char *strrchr(chat *s, int c);<br>&nbsp;&nbsp;&nbsp;&nbsp;char *strstr(chat *s, char *ss);    </p>
<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>方便程度：  char[] &gt; char* &gt; string</p>
<h4 id="使用-char-注意-‘-0’"><a href="#使用-char-注意-‘-0’" class="headerlink" title="使用 char[] 注意 ‘\0’"></a>使用 char[] 注意 ‘\0’</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">&quot;DNA&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = &#123;<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="char-转换成-string"><a href="#char-转换成-string" class="headerlink" title="char[] 转换成 string"></a>char[] 转换成 string</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">&quot;CGTCAAACGG&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">dna_seq</span><span class="params">(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; dna_seq &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// CGTCAAACGG</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="char-转换成-string-1"><a href="#char-转换成-string-1" class="headerlink" title="char* 转换成 string"></a>char* 转换成 string</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* char_ptr = <span class="string">&quot;CGTCAAACGG&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string dna_seq = std::<span class="built_in">string</span>(char_ptr);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; dna_seq &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// CGTCAAACGG</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="string可以用-0-来访问"><a href="#string可以用-0-来访问" class="headerlink" title="string可以用 [0] 来访问"></a>string可以用 [0] 来访问</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">change</span><span class="params">(string &amp;str)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a string (q to quit): &quot;</span>;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    <span class="keyword">while</span> (str != <span class="string">&quot;q&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str = <span class="built_in">change</span>(str);</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Next string (q to quit): &quot;</span>;</span><br><span class="line">        <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bye.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">string <span class="title">change</span><span class="params">(string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        str[i] = <span class="built_in">toupper</span>(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>C PrimerPlus(1) 对象与类</title>
    <url>/BassHero.github.io/2021/09/20/cpp01class/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><span id="more"></span>
<h3 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h3><p>需要同时编译两个文件，即：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">g</span>++ <span class="comment">bank</span><span class="string">.</span><span class="comment">cpp</span> <span class="comment">usebank</span><span class="string">.</span><span class="comment">cpp</span></span><br></pre></td></tr></table></figure>
<p>成员函数</p>
<p><strong>内联</strong> 内联函数是代码被插入到调用者代码处的函数。在C++中，在类的内部定义了函数体的函数，被默认为是内联函数。而不管你是否有inline关键字。 </p>
<p><strong>私有成员函数</strong>  在类定义文件中定义。</p>
<p><strong>构造函数</strong>  类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p>
<p><strong>析构函数</strong>  在每次删除所创建的对象时执行。析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p>
<h4 id="编程练习题第6问"><a href="#编程练习题第6问" class="headerlink" title="编程练习题第6问"></a>编程练习题第6问</h4><!--more-->

<p>six.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIX_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIX_H_</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Move</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Move</span>(<span class="keyword">double</span> a = <span class="number">0.0</span>, <span class="keyword">double</span> b = <span class="number">0.0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showmove</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Move <span class="title">add</span><span class="params">(<span class="keyword">const</span> Move &amp;m)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">double</span> a = <span class="number">0.0</span>, <span class="keyword">double</span> b = <span class="number">0.0</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>six.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;six.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Move::<span class="built_in">Move</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    x = a;</span><br><span class="line">    y = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move::showmove</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Move <span class="title">Move::add</span><span class="params">(<span class="keyword">const</span> Move &amp;m)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Move temp;</span><br><span class="line">    temp.x = m.x + <span class="keyword">this</span>-&gt;x; <span class="comment">//加上调用对象的x值;</span></span><br><span class="line">    temp.y = m.y + <span class="keyword">this</span>-&gt;y; <span class="comment">//加上调用对象的y值;</span></span><br><span class="line">    <span class="keyword">return</span> temp;            <span class="comment">//返回值为一个新对象;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move::reset</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = a;</span><br><span class="line">    y = b;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>testSix.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;six.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::endl;</span><br><span class="line">    Move temp;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Starting values:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    temp.<span class="built_in">showmove</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After x + 2, y + 5:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    temp.<span class="built_in">reset</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    temp.<span class="built_in">showmove</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After adding new object value:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    temp = temp.<span class="built_in">add</span>(temp); <span class="comment">//对象赋值;</span></span><br><span class="line">    temp.<span class="built_in">showmove</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="编程练习题第8问"><a href="#编程练习题第8问" class="headerlink" title="编程练习题第8问"></a>编程练习题第8问</h4><p>eight.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EIGHT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EIGHT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Item;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">10</span>;</span><br><span class="line">    Item items[MAX];</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">List</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_data</span><span class="params">(Item item)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_full</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">void</span> (*pf)(Item &amp;))</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>eight.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;eight.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">List::<span class="built_in">List</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;index = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List::add_data</span><span class="params">(Item item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;items[index++] = item;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">List::is_empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">List::is_full</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MAX == index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List::visit</span><span class="params">(<span class="keyword">void</span> (*pf)(Item &amp;))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;index; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        (*pf)(<span class="keyword">this</span>-&gt;items[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>testEight.cpp</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;eight.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Item &amp;item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    Item temp;</span><br><span class="line">    List mylist;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The list include following functions:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a to add an number.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v to visit every number.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;q to exit the menu.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please enter your choice: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; ch &amp;&amp; <span class="built_in">tolower</span>(ch) != <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (cin.<span class="built_in">get</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">tolower</span>(ch) != <span class="string">&#x27;a&#x27;</span> &amp;&amp; <span class="built_in">tolower</span>(ch) != <span class="string">&#x27;v&#x27;</span>) <span class="comment">//处理错误选择;</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Please enter a, v or q: &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">tolower</span>(ch))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Please enter an number: &quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (!(cin &gt;&gt; temp)) <span class="comment">//处理错误非数值输入;</span></span><br><span class="line">            &#123;</span><br><span class="line">                cin.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">while</span> (cin.<span class="built_in">get</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Please enter an number again: &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mylist.<span class="built_in">is_full</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;The list is full. Can&#x27;t add new number.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mylist.<span class="built_in">add_data</span>(temp);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Add number &quot;</span> &lt;&lt; temp &lt;&lt; <span class="string">&quot; successfully.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mylist.<span class="built_in">is_empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No number.\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Visit every number:&quot;</span> &lt;&lt; endl;</span><br><span class="line">                mylist.<span class="built_in">visit</span>(traverse);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n\n\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The list include following functions:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a to add an number.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v to visit every number.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;q to exit the menu.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please enter your choice: &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bye.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Item &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; item &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="10-1对象与类"><a href="#10-1对象与类" class="headerlink" title="10.1对象与类"></a>10.1对象与类</h3><p>抽象方法 设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。</p>
<p>虚方法</p>
<p>抽象方法和虚方法的区别<br>1.虚方法必须有实现部分，抽象方法没有提供实现部分，抽象方法是一种强制派生类覆盖的方法，否则派生类将不能被实例化。<br>2.抽象方法只能在抽象类中声明，虚方法不是。如果类包含抽象方法，那么该类也是抽象的，也必须声明类是抽象的。<br>3.抽象方法必须在派生类中重写，这一点和接口类似，虚方法不需要再派生类中重写。</p>
<p>静态联编 在编译时期完成的联编</p>
<p>动态联编 编译器生成能够在程序运行时选择的正确的虚方法的代码</p>
<p><br><br><br><br><br><br><br><br></p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>技术</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>《哲学的故事》笔记</title>
    <url>/BassHero.github.io/2021/09/01/ISBN978-7-568-91092-7/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>（美）杜兰特著；蒋剑峰，张程程译. —杭州：浙江大学出版社</p>
<span id="more"></span>
<h3 id="第一章-柏拉图"><a href="#第一章-柏拉图" class="headerlink" title="第一章 柏拉图"></a>第一章 柏拉图</h3><p>古希腊第一批天文学家<br>起初哲学是物理性质的</p>
<p> 并将民主贬斥为无能的虚伪 。从某种意义上当时的雅典几乎谈不上民主。奴隶。<br>伯罗奔尼撒战争（前431-前404） 赛提亚反对民主</p>
<p>苏格拉底<br>一个人只要不违法1妨碍他去做任何他想做的事情便是毫无理由的。这种离散式的个人主义大大削弱了雅典人民的个性。<br>《苏格拉底自辩篇》<br>1.伦理学<br>《理想国》摘录<br>正义是强者的利益<br>非正义受到谴责是因为谴责他的人怕自己吃苦头，而并非真的出于任何道德上的顾虑<br>按照自身的利益来展开赞扬和谴责，这样的正义是属于愚民的奴隶式道德。一个人的正正的美德是勇气和智慧。<br>雅典对外政策的帝国主义发展<br>2政治学问题<br>人口控制，素食主义，回归自然 犬儒派第欧根尼 圣西门，傅里叶，威廉莫里斯以及托尔斯泰<br>民主制度的可怕<br>3.心理学问题<br>政治心理学问题<br>每个人心中都潜藏着兽性<br>贪婪易妒好斗好色<br>我们必须有宗教<br>脱离家庭式个体主义</p>
<p>耶稣说道德是善待弱者<br>你才说道德是强者的英勇<br>柏拉图说道德是全体的有效和谐</p>
<p>俄共和柏拉图的理想国 责任稀释</p>
<p>柏拉图最欠缺的或许是赫拉克利特的变化意识：他过于焦急的想将这个和世界凝固成一幅静止的图画</p>
<h3 id="第二章-亚里士多德和希腊科学"><a href="#第二章-亚里士多德和希腊科学" class="headerlink" title="第二章  亚里士多德和希腊科学"></a>第二章  亚里士多德和希腊科学</h3><p>反柏拉图</p>
<blockquote><p>马其顿国王菲利普坚持要让自己的儿子接受最优质的教育，因为他已在其他各个方面为儿子设计了不可限量的前程。他于公元前356年征服了色雷斯，控制了当地的金矿，由此生产出的金子十倍于当时日渐衰败的劳里恩银矿运到雅典的银两；他的臣民是勤劳的农民和勇敢的战士，尚未被城市的浮华俘虏：这里将是数百个弱小城邦结合、形成政治上统一的大希腊的希望之地。菲利普对擅长艺术和学术创作的希腊人没有丝毫的同情，并将她的社会秩序一举击破；在这些零散城邦的首都中，他看到的不是令人窒息的文明或无与伦比的艺术，而是处处显露的商业腐败和政治混乱；他看到贪婪的商人和银行家将国家的重要资产据为己有，无能的政治家和善于诡辩的说客将自顾不暇的民众引向一个又一个灾难般的阴谋和战争，政党分裂阶级，阶级又聚变成森严的社会等级：这不是一个国家，菲利普说，而是一群鱼龙混杂、良莠不齐的个体——天才和奴隶。他要给这片混乱的土地带来秩序，将全希腊团结起来，将其建成强大的世界政治中心和根基。他在底比斯的幼年时期曾投到著名的伊巴密浓达[4]门下学习军事策略和市政管理；现在凭借无比的勇气和远大的志向，他将所学到的东西发挥得出神入化。公元前338年，他在克罗尼亚大败雅典人，并最终用锁链成功建立起统一的希腊。然而，正当高踞胜利宝座的他谋划着如何和儿子一起实施统治世界的下一步时，他被刺杀了。</p>
</blockquote>

<p>逻辑学的创立</p>
<p>科学学派<br>希腊之前：天文学<br>赫拉克利特<br>亚里士多德和希腊科学 唯物主义决定论的原子学说<br>博学家 物理学家 生物学胚胎学 形而上学和上帝的本质————无为之王，什么都不做，英国女王<br>心理学（意志的自由和灵魂的不灭）和艺术的本质</p>
<p>政治学<br>共产主义和保守主义<br>婚姻和教育<br>民主制和贵族制<br>  民主制整体上仍旧不如贵族制，因为它建立在一个虚假的平等基础上<br>  立宪政府提供了可惜的结合<br>不以物喜亚里士多德<br>伦理学和幸福的本质<br>亚里士多德观察收集数据并分类，却得不出研究结果<br>亚里士多德认为理想化的生活就是正规的三段论，不可取</p>
<h3 id="第三章-弗朗西斯培根"><a href="#第三章-弗朗西斯培根" class="headerlink" title="第三章 弗朗西斯培根"></a>第三章 弗朗西斯培根</h3><p>从亚里士多德到文艺复兴<br>斯多葛学说 和 伊壁鸠鲁学说（崇尚克制，悲观主义者）<br>一个坦然接受失败 一个在快乐的怀抱中忘掉失败<br>两者都是关于征服与被奴役之下如何求得幸福的理论<br>恰好就像十九世纪，持有悲观的东方斯多葛主义的叔本华和持有消极的伊壁鸠鲁主义的勒南，象征着一败涂地的法国大革命与支离破碎的法国<br>叔本华认为个人意志无法战胜宇宙意志<br>对于一个敏感的人来说，无论是做主人还是做仆人都是困难重重<br>罗马哲学 无论是皇帝马可奥勒留还是努力爱比克泰斯，大多都属于芝诺学派</p>
<p>《论说文集》<br>知识不运用于行动便只是苍白无力的学术虚荣而已<br>手工业者讨厌学问，头脑简单之人敬仰学问，而真正的智慧之刃运用学问<br>创造新学科 社会心理学<br>培根爱的是哲学 不是科学。科学本身必须体验组织性。<br>【个人想法】我们大多数人都是更热爱哲学而非科学</p>
<p>《新工具》<br>谬误 种族偶像 洞穴偶像 市场偶像 剧场偶像<br>怀疑<br>单纯经验<br>假设，演绎和实验<br>评价<br>培根并没有超越前人<br>歌德说“一个人的短处来自于他的时代，一个人的优点来自他的自身”</p>
<h3 id="第四章-斯宾诺莎"><a href="#第四章-斯宾诺莎" class="headerlink" title="第四章 斯宾诺莎"></a>第四章 斯宾诺莎</h3><p>研究神学<br>他觉得《迷途指津》中更多的是迷途，鲜少有指津<br>莱布尼茨，洛克，贝克莱，休谟和康德发起的三百年的哲学战争<br>开除教籍<br>《神学政治论》<br>《知性改进论》<br>《伦理学》<br>斯宾诺莎体系三大关键词 实体属性和样式<br>【咚咚锵】你应该来编程<br>自然和上帝 物质和精神 理智和道德<br>他从把幸福快乐作为各种行为的目标开始，将快乐非常简单地界定为愉悦的存在和伤痛的消除。但是愉悦和痛是相关的，不是绝对的，它们不是既成的状态，而是转换的过程。“愉悦是人从一个相对不完美的状态”（完美也就是指圆满或者满足）“转换至一个更加完美的状态的过程”。“这其中包含着快乐，一个人的力量也因此得到增强。”[95]“伤痛则是一个人从比较完美的状态转至不那么完美的状态。我之所以说是转换，因为愉悦本身并不完美。如果一个人生来就拥有完美，那么他也将没有……愉悦的感觉。与之相反的情况就更显而易见了。”[96]所有的激情都是过客，所有的感情都会改变，它们或者更加接近或者更加远离圆满和力量。</p>
<p>尼采和斯宾诺莎 不支持谦卑</p>
<p>集大成者《政治论》</p>
<h3 id="第五章-伏尔泰和法国启蒙运动"><a href="#第五章-伏尔泰和法国启蒙运动" class="headerlink" title="第五章 伏尔泰和法国启蒙运动"></a>第五章 伏尔泰和法国启蒙运动</h3><p>哲学小说</p>
<h3 id="第六章-伊曼努尔康德和德国唯心主义"><a href="#第六章-伊曼努尔康德和德国唯心主义" class="headerlink" title="第六章 伊曼努尔康德和德国唯心主义"></a>第六章 伊曼努尔康德和德国唯心主义</h3><p>康德《纯粹理性批判》<br>休谟《人性论》<br>休谟认为，他已经证明了心灵不存在，科学亦不存在；心灵只是观念的排列和联结；我们认为的必然其实只是随时可能被推翻的偶然。康德认为，休谟的这些结论都是错误的，因为前提就已经错了。他反驳休谟说：假设所有的认识都来源于“独立的、不同的”感觉，那认识就不存在必然性，也不可能给予我们不变的确定结果；如此一来，你肯定不能指望“看到”你的心灵，即使是用内在感觉的双眼也不行。如果所有的认识都来自感官，来自独立的外部世界，这个世界又是不稳定的，那认识的绝对可靠性就是不可能的。但是如果有些认识是独立于感官经验之外的呢？比如有些知识的可靠性先于我们的经验——即先验。这样的话，绝对真理和绝对科学就是可能的，难道不是吗？存在这样的绝对知识吗？这就是《纯粹理性批判》讨论的问题。</p>
<p>先验感性论<br>《实践理性批判》</p>
<p>论宗教和理性《判断力批判》《纯粹理性范围内的宗教》<br>论政治与持久和平《论联系全宇宙政治史观念的政治秩序的自然原则》</p>
<p>评论<br>英国的皮尔逊，德国的马赫，法国的亨利庞加莱等一些人的研究都更赞同休谟而非康德</p>
<p>黑格尔</p>
<h3 id="第七章-叔本华"><a href="#第七章-叔本华" class="headerlink" title="第七章 叔本华"></a>第七章 叔本华</h3><p>《作为意志和表象的世界》<br>理性会疲劳，意志永远不会<br>意志是人的本质</p>
<p>卢梭之后 理智主义开始衰落，康德之后半死不活，叔本华之后理智主义彻底告别了世界</p>
<h3 id="第八章-赫伯特斯宾塞"><a href="#第八章-赫伯特斯宾塞" class="headerlink" title="第八章 赫伯特斯宾塞"></a>第八章 赫伯特斯宾塞</h3><p>孕育出实证主义运动的奠基人<br>哲学并非异于科学，哲学以提升人生为目的，是对一切科学的协助，综合<br>根据培根的思想传统，思想的对象是事物，而心灵的对象是物质；霍布斯的唯物论、洛克的感觉论、休谟的怀疑论、边沁[1]的功利主义，都是同一主题的不同变奏，这个主题就是现实而又忙碌的生活。</p>
<p>十七世纪，数学主宰哲学，于是出现了笛卡尔、霍布斯、斯宾诺莎、莱布尼茨、帕斯卡[12]；随着心理学的兴起，哲学界出现了贝克莱、休谟、孔狄亚克、康德；十九世纪，谢林、叔本华、斯宾塞、尼采、柏格森等哲学家扮演着主要角色，此时的哲学思想以生物学为背景。在这些时代里，影响最为深远的思想都是思想家成果的零碎片断，或多或少都有些晦涩；但是，每一种具有影响力的思想都与整理、阐述它们的思想家密不可分，正如“新大陆”以亚美利哥·韦斯普奇命名，因为亚美利哥绘制了一幅地图。赫伯特·斯宾塞是达尔文时代的韦斯普奇，从某种程度上来说，也许还是达尔文时代的哥伦布。</p>
<p>《综合哲学》《第一原理》 不可知论<br>《社会静力学》《社会学原理》<br>社会主义是军事国家和封建国家的产物<br>《伦理学原理》</p>
<p>批评<br>我们必须记住，斯宾塞是在两个时代的夹缝中生活的：他的政治思想形成于自由放任政策时代，并深受亚当·斯密的影响；而在他的晚年，英国正绞尽脑汁通过社会控制来纠正其对工业政权的滥用。斯宾塞不厌其烦地重申其反对国家干涉的立场，他反对任何由政府资助的教育，反对政府在金融诈骗方面对公民进行保护。[164]有一次他甚至还主张，对战争的运筹也应是私人的事，而不应是国家的事。[165]斯宾塞所希望的，用威尔斯[166]的话说就是，“提升公众的懒散性，通过国家政策使这种懒散受到尊重”。斯宾塞亲自将手稿送到印刷厂，他不敢把稿子交给邮局，因为他对政府机构不抱任何信心。[167]他是一个个性极为强烈的人，无论何种情况都坚持独处，否则便会大发雷霆。在他看说，每一项新法案都是对个人自由的侵犯。</p>
<h3 id="第九章-弗里德里希尼采"><a href="#第九章-弗里德里希尼采" class="headerlink" title="第九章 弗里德里希尼采"></a>第九章 弗里德里希尼采</h3><p>崇拜叔本华</p>
<p>在罗马人（哪怕是一个普通民众）看来，所谓的美德便是男人气概、勇气、冒险和胆量。但在亚洲，尤其是在犹太人的脑海中，却孕育了另一种道德标准：遭受政治压迫的人们变得谦逊、无助、无私。实际上，这是在求助。在庶民道德的笼罩下，人们热爱安定与和平，厌恶冒险和权力；人们不再追求力量，他们乐于狡诈，人与人之间的报复不再公开，而是变得隐秘；怜悯代替了严厉，模仿代替了创新，人们不再因享有殊荣而自豪，而是无情地谴责自己的良心，因为荣誉只属于异教徒、罗马人、封建主和贵族，良心才属于犹太人、基督徒、资产阶级和大众。[74]从阿摩司[75]到耶稣，一大批能说会道的先知将奴隶阶层的思想发扬光大，使之几乎成为普世伦理观。于是，“俗世”和“肉体”成为罪恶的代名词，贫穷成了道德的象征。[76]</p>
<p>而耶稣则将这种价值标准推至顶峰。在他看来，人人都拥有平等的价值，享有平等的权利。</p>
<p>后来，耶稣的教义又发展出民主思想、功利主义、社会主义。于是，人们开始根据庶民哲学、渐进的平等化和庸俗化、颓废和堕落的生活来定义进步。[77]颓废生活的最后一幕便是对怜悯慈悲、自我牺牲的赞美，对罪大恶极者不理性的安慰，以及“人类社会排泄功能的丧失”。积极的同情是可取的，而怜悯则是一种麻痹心灵的奢侈品，对那些无可救药、昏庸无能、穷凶极恶的废物，那些满是缺陷、活该害病、违法犯罪的畜生来说，怜悯则是浪费感情。怜悯隐含着粗俗，是一种侵犯，比如，“‘探望病人’是想到邻居无助之时，心生的一种类似性高潮的优越感”</p>
<p>颓废<br>因此，贵族是通往超人的必由之路。民主——“这种热衷于清点人数的制度”——必须尽早铲除。对所有高贵的人而言，废除民主的第一步便是毁灭基督教。民主始于基督的胜利；“第一位基督徒，在其本能最深处，是一位反对任何特权的叛逆者，他为了‘平等的权利’生活，并为了‘平等的权利’不懈斗争，要是在现代，他早就被流放到西伯利亚去了”。“如果他是你们当中最伟大的人，就让他成为你们的仆人吧”——这是一切政治智慧、一切健全头脑爱玩的颠覆游戏。的确，一个人在阅读《福音书》的时候，会感觉自己像是沉浸在俄国小说的氛围中；原来，《福音书》是对陀思妥耶夫斯基的剽窃。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>2021</tag>
      </tags>
  </entry>
</search>
